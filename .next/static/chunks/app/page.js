/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fcomponents%2FMap.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!":
/*!****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fcomponents%2FMap.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false! ***!
  \****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./components/Map.tsx */ \"(app-pages-browser)/./components/Map.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/link.js */ \"(app-pages-browser)/./node_modules/next/dist/client/link.js\", 23));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtaWNoYWVsZHJlZXNlbiUyRkRvY3VtZW50cyUyRlByb2dyYW1taW5nJTJGYnVzaW5lc3MtcHJvamVjdHMlMkZwZXJyaWdvLWluc3VyYW5jZSUyRmNvbXBvbmVudHMlMkZNYXAudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyZGVmYXVsdCUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRm1pY2hhZWxkcmVlc2VuJTJGRG9jdW1lbnRzJTJGUHJvZ3JhbW1pbmclMkZidXNpbmVzcy1wcm9qZWN0cyUyRnBlcnJpZ28taW5zdXJhbmNlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZpbWFnZS1jb21wb25lbnQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtaWNoYWVsZHJlZXNlbiUyRkRvY3VtZW50cyUyRlByb2dyYW1taW5nJTJGYnVzaW5lc3MtcHJvamVjdHMlMkZwZXJyaWdvLWluc3VyYW5jZSUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGbGluay5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMiolMjIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxrS0FBb0s7QUFDcEs7QUFDQSxvT0FBcUs7QUFDcks7QUFDQSw4TUFBMEoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9mN2MxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiZGVmYXVsdFwiXSAqLyBcIi9Vc2Vycy9taWNoYWVsZHJlZXNlbi9Eb2N1bWVudHMvUHJvZ3JhbW1pbmcvYnVzaW5lc3MtcHJvamVjdHMvcGVycmlnby1pbnN1cmFuY2UvY29tcG9uZW50cy9NYXAudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvbWljaGFlbGRyZWVzZW4vRG9jdW1lbnRzL1Byb2dyYW1taW5nL2J1c2luZXNzLXByb2plY3RzL3BlcnJpZ28taW5zdXJhbmNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL21pY2hhZWxkcmVlc2VuL0RvY3VtZW50cy9Qcm9ncmFtbWluZy9idXNpbmVzcy1wcm9qZWN0cy9wZXJyaWdvLWluc3VyYW5jZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fcomponents%2FMap.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-google-maps/api/dist/esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-google-maps/api/dist/esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Autocomplete: function() { return /* binding */ Autocomplete; },\n/* harmony export */   BicyclingLayer: function() { return /* binding */ BicyclingLayer; },\n/* harmony export */   BicyclingLayerF: function() { return /* binding */ BicyclingLayerF; },\n/* harmony export */   Circle: function() { return /* binding */ Circle; },\n/* harmony export */   CircleF: function() { return /* binding */ CircleF; },\n/* harmony export */   Data: function() { return /* binding */ Data; },\n/* harmony export */   DataF: function() { return /* binding */ DataF; },\n/* harmony export */   DirectionsRenderer: function() { return /* binding */ DirectionsRenderer; },\n/* harmony export */   DirectionsService: function() { return /* binding */ DirectionsService; },\n/* harmony export */   DistanceMatrixService: function() { return /* binding */ DistanceMatrixService; },\n/* harmony export */   DrawingManager: function() { return /* binding */ DrawingManager; },\n/* harmony export */   DrawingManagerF: function() { return /* binding */ DrawingManagerF; },\n/* harmony export */   FLOAT_PANE: function() { return /* binding */ FLOAT_PANE; },\n/* harmony export */   GoogleMap: function() { return /* binding */ GoogleMap; },\n/* harmony export */   GoogleMapsMarkerClusterer: function() { return /* binding */ index_esm; },\n/* harmony export */   GoogleMarkerClusterer: function() { return /* binding */ GoogleMarkerClusterer$1; },\n/* harmony export */   GroundOverlay: function() { return /* binding */ GroundOverlay; },\n/* harmony export */   GroundOverlayF: function() { return /* binding */ GroundOverlayF; },\n/* harmony export */   HeatmapLayer: function() { return /* binding */ HeatmapLayer; },\n/* harmony export */   HeatmapLayerF: function() { return /* binding */ HeatmapLayerF; },\n/* harmony export */   InfoBox: function() { return /* binding */ InfoBoxComponent; },\n/* harmony export */   InfoBoxF: function() { return /* binding */ InfoBoxF; },\n/* harmony export */   InfoWindow: function() { return /* binding */ InfoWindow; },\n/* harmony export */   InfoWindowF: function() { return /* binding */ InfoWindowF; },\n/* harmony export */   KmlLayer: function() { return /* binding */ KmlLayer; },\n/* harmony export */   LoadScript: function() { return /* binding */ LoadScript; },\n/* harmony export */   LoadScriptNext: function() { return /* binding */ LoadScriptNext$1; },\n/* harmony export */   MAP_PANE: function() { return /* binding */ MAP_PANE; },\n/* harmony export */   MARKER_LAYER: function() { return /* binding */ MARKER_LAYER; },\n/* harmony export */   MapContext: function() { return /* binding */ MapContext; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   MarkerClusterer: function() { return /* binding */ ClustererComponent; },\n/* harmony export */   MarkerClustererF: function() { return /* binding */ MarkerClustererF; },\n/* harmony export */   MarkerF: function() { return /* binding */ MarkerF; },\n/* harmony export */   OVERLAY_LAYER: function() { return /* binding */ OVERLAY_LAYER; },\n/* harmony export */   OVERLAY_MOUSE_TARGET: function() { return /* binding */ OVERLAY_MOUSE_TARGET; },\n/* harmony export */   OverlayView: function() { return /* binding */ OverlayView; },\n/* harmony export */   OverlayViewF: function() { return /* binding */ OverlayViewF; },\n/* harmony export */   Polygon: function() { return /* binding */ Polygon; },\n/* harmony export */   PolygonF: function() { return /* binding */ PolygonF; },\n/* harmony export */   Polyline: function() { return /* binding */ Polyline; },\n/* harmony export */   PolylineF: function() { return /* binding */ PolylineF; },\n/* harmony export */   Rectangle: function() { return /* binding */ Rectangle; },\n/* harmony export */   RectangleF: function() { return /* binding */ RectangleF; },\n/* harmony export */   StandaloneSearchBox: function() { return /* binding */ StandaloneSearchBox; },\n/* harmony export */   StreetViewPanorama: function() { return /* binding */ StreetViewPanorama; },\n/* harmony export */   StreetViewService: function() { return /* binding */ StreetViewService; },\n/* harmony export */   TrafficLayer: function() { return /* binding */ TrafficLayer; },\n/* harmony export */   TrafficLayerF: function() { return /* binding */ TrafficLayerF; },\n/* harmony export */   TransitLayer: function() { return /* binding */ TransitLayer; },\n/* harmony export */   TransitLayerF: function() { return /* binding */ TransitLayerF; },\n/* harmony export */   useGoogleMap: function() { return /* binding */ useGoogleMap; },\n/* harmony export */   useJsApiLoader: function() { return /* binding */ useJsApiLoader; },\n/* harmony export */   useLoadScript: function() { return /* binding */ useLoadScript; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n\n\n\n\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction getDefaultExportFromCjs$1 (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar invariant_1;\nvar hasRequiredInvariant;\nfunction requireInvariant() {\n  if (hasRequiredInvariant) return invariant_1;\n  hasRequiredInvariant = 1;\n\n  /**\n   * Use invariant() to assert state which your program assumes to be true.\n   *\n   * Provide sprintf-style format (only %s is supported) and arguments\n   * to provide information about what broke and what you were\n   * expecting.\n   *\n   * The invariant message will be stripped in production, but the invariant\n   * will remain to ensure logic does not differ in production.\n   */\n\n  var NODE_ENV = \"development\";\n  var invariant = function invariant(condition, format, a, b, c, d, e, f) {\n    if (NODE_ENV !== 'production') {\n      if (format === undefined) {\n        throw new Error('invariant requires an error message argument');\n      }\n    }\n    if (!condition) {\n      var error;\n      if (format === undefined) {\n        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n      } else {\n        var args = [a, b, c, d, e, f];\n        var argIndex = 0;\n        error = new Error(format.replace(/%s/g, function () {\n          return args[argIndex++];\n        }));\n        error.name = 'Invariant Violation';\n      }\n      error.framesToPop = 1; // we don't care about invariant's own frame\n      throw error;\n    }\n  };\n  invariant_1 = invariant;\n  return invariant_1;\n}\n\nvar invariantExports = requireInvariant();\nvar invariant = /*@__PURE__*/getDefaultExportFromCjs$1(invariantExports);\n\nvar MapContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction useGoogleMap() {\n  invariant(!!react__WEBPACK_IMPORTED_MODULE_1__.useContext, 'useGoogleMap is React hook and requires React version 16.8+');\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  invariant(!!map, 'useGoogleMap needs a GoogleMap available up in the tree');\n  return map;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction reduce(obj, fn, acc) {\n  return Object.keys(obj).reduce(function reducer(newAcc, key) {\n    return fn(newAcc, obj[key], key);\n  }, acc);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction forEach(obj, fn) {\n  Object.keys(obj).forEach(key => {\n    return fn(obj[key], key);\n  });\n}\n\n/* global google */\n/* eslint-disable filenames/match-regex */\nfunction applyUpdaterToNextProps(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nupdaterMap,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprevProps,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnextProps,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var map = {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var iter = (fn, key) => {\n    var nextValue = nextProps[key];\n    if (nextValue !== prevProps[key]) {\n      map[key] = nextValue;\n      fn(instance, nextValue);\n    }\n  };\n  forEach(updaterMap, iter);\n  return map;\n}\nfunction registerEvents(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprops,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance, eventMap) {\n  var registeredList = reduce(eventMap, function reducer(acc, googleEventName,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  onEventName) {\n    if (typeof props[onEventName] === 'function') {\n      acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));\n    }\n    return acc;\n  }, []);\n  return registeredList;\n}\nfunction unregisterEvent(registered) {\n  google.maps.event.removeListener(registered);\n}\nfunction unregisterEvents() {\n  var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  events.forEach(unregisterEvent);\n}\nfunction applyUpdatersToPropsAndRegisterEvents(_ref) {\n  var {\n    updaterMap,\n    eventMap,\n    prevProps,\n    nextProps,\n    instance\n  } = _ref;\n  var registeredEvents = registerEvents(nextProps, instance, eventMap);\n  applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);\n  return registeredEvents;\n}\n\nvar eventMap$i = {\n  onDblClick: 'dblclick',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseDown: 'mousedown',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick',\n  onTilesLoaded: 'tilesloaded',\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onDrag: 'drag',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onProjectionChanged: 'projection_changed',\n  onResize: 'resize',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed'\n};\nvar updaterMap$i = {\n  extraMapTypes(map, extra) {\n    extra.forEach(function forEachExtra(it, i) {\n      map.mapTypes.set(String(i), it);\n    });\n  },\n  center(map, center) {\n    map.setCenter(center);\n  },\n  clickableIcons(map, clickable) {\n    map.setClickableIcons(clickable);\n  },\n  heading(map, heading) {\n    map.setHeading(heading);\n  },\n  mapTypeId(map, mapTypeId) {\n    map.setMapTypeId(mapTypeId);\n  },\n  options(map, options) {\n    map.setOptions(options);\n  },\n  streetView(map, streetView) {\n    map.setStreetView(streetView);\n  },\n  tilt(map, tilt) {\n    map.setTilt(tilt);\n  },\n  zoom(map, zoom) {\n    map.setZoom(zoom);\n  }\n};\n// TODO: unfinished!\nfunction GoogleMapFunctional(_ref) {\n  var {\n    children,\n    options,\n    id,\n    mapContainerStyle,\n    mapContainerClassName,\n    center,\n    // clickableIcons,\n    // extraMapTypes,\n    // heading,\n    // mapTypeId,\n    onClick,\n    onDblClick,\n    onDrag,\n    onDragEnd,\n    onDragStart,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseDown,\n    onMouseUp,\n    onRightClick,\n    // onMapTypeIdChanged,\n    // onTilesLoaded,\n    // onBoundsChanged,\n    onCenterChanged,\n    // onHeadingChanged,\n    // onIdle,\n    // onProjectionChanged,\n    // onResize,\n    // onTiltChanged,\n    // onZoomChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  // const [extraMapTypesListener, setExtraMapTypesListener] = useState<google.maps.MapsEventListener | null>(null)\n  var [centerChangedListener, setCenterChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && map !== null) {\n      map.setOptions(options);\n    }\n  }, [map, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map !== null && typeof center !== 'undefined') {\n      map.setCenter(center);\n    }\n  }, [map, center]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(map, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onDragEnd) {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(map, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onDragStart) {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(map, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(map, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onMouseMove) {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(map, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(map, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(map, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(map, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onRightClick) {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(map, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(map, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onDrag) {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(map, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && onCenterChanged) {\n      if (centerChangedListener !== null) {\n        google.maps.event.removeListener(centerChangedListener);\n      }\n      setCenterChangedListener(google.maps.event.addListener(map, 'center_changed', onCenterChanged));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var map = ref.current === null ? null : new google.maps.Map(ref.current, options);\n    setMap(map);\n    if (map !== null && onLoad) {\n      onLoad(map);\n    }\n    return () => {\n      if (map !== null) {\n        if (onUnmount) {\n          onUnmount(map);\n        }\n      }\n    };\n  }, []);\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    id: id,\n    ref: ref,\n    style: mapContainerStyle,\n    className: mapContainerClassName,\n    children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MapContext.Provider, {\n      value: map,\n      children: map !== null ? children : null\n    })\n  });\n}\n(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GoogleMapFunctional);\nclass GoogleMap extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      map: null\n    });\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"mapRef\", null);\n    _defineProperty(this, \"getInstance\", () => {\n      if (this.mapRef === null) {\n        return null;\n      }\n      return new google.maps.Map(this.mapRef, this.props.options);\n    });\n    _defineProperty(this, \"panTo\", latLng => {\n      var map = this.getInstance();\n      if (map) {\n        map.panTo(latLng);\n      }\n    });\n    _defineProperty(this, \"setMapCallback\", () => {\n      if (this.state.map !== null) {\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.map);\n        }\n      }\n    });\n    _defineProperty(this, \"getRef\", ref => {\n      this.mapRef = ref;\n    });\n  }\n  componentDidMount() {\n    var map = this.getInstance();\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$i,\n      eventMap: eventMap$i,\n      prevProps: {},\n      nextProps: this.props,\n      instance: map\n    });\n    this.setState(function setMap() {\n      return {\n        map\n      };\n    }, this.setMapCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.map !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$i,\n        eventMap: eventMap$i,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.map\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.map !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.map);\n      }\n      unregisterEvents(this.registeredEvents);\n    }\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      id: this.props.id,\n      ref: this.getRef,\n      style: this.props.mapContainerStyle,\n      className: this.props.mapContainerClassName,\n      children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MapContext.Provider, {\n        value: this.state.map,\n        children: this.state.map !== null ? this.props.children : null\n      })\n    });\n  }\n}\n\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\n\nfunction makeLoadScriptUrl(_ref) {\n  var {\n    googleMapsApiKey,\n    googleMapsClientId,\n    version = 'weekly',\n    language,\n    region,\n    libraries,\n    channel,\n    mapIds,\n    authReferrerPolicy\n  } = _ref;\n  var params = [];\n  invariant(googleMapsApiKey && googleMapsClientId || !(googleMapsApiKey && googleMapsClientId), 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.');\n  if (googleMapsApiKey) {\n    params.push(\"key=\".concat(googleMapsApiKey));\n  } else if (googleMapsClientId) {\n    params.push(\"client=\".concat(googleMapsClientId));\n  }\n  if (version) {\n    params.push(\"v=\".concat(version));\n  }\n  if (language) {\n    params.push(\"language=\".concat(language));\n  }\n  if (region) {\n    params.push(\"region=\".concat(region));\n  }\n  if (libraries && libraries.length) {\n    params.push(\"libraries=\".concat(libraries.sort().join(',')));\n  }\n  if (channel) {\n    params.push(\"channel=\".concat(channel));\n  }\n  if (mapIds && mapIds.length) {\n    params.push(\"map_ids=\".concat(mapIds.join(',')));\n  }\n  if (authReferrerPolicy) {\n    params.push(\"auth_referrer_policy=\".concat(authReferrerPolicy));\n  }\n  params.push('loading=async');\n  params.push('callback=initMap');\n  return \"https://maps.googleapis.com/maps/api/js?\".concat(params.join('&'));\n}\n\nvar isBrowser = typeof document !== 'undefined';\n\nfunction injectScript(_ref) {\n  var {\n    url,\n    id,\n    nonce\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } = _ref;\n  if (!isBrowser) {\n    return Promise.reject(new Error('document is undefined'));\n  }\n  return new Promise(function injectScriptCallback(resolve, reject) {\n    var existingScript = document.getElementById(id);\n    var windowWithGoogleMap = window;\n    if (existingScript) {\n      // Same script id/url: keep same script\n      var dataStateAttribute = existingScript.getAttribute('data-state');\n      if (existingScript.src === url && dataStateAttribute !== 'error') {\n        if (dataStateAttribute === 'ready') {\n          return resolve(id);\n        } else {\n          var originalInitMap = windowWithGoogleMap.initMap;\n          var originalErrorCallback = existingScript.onerror;\n          windowWithGoogleMap.initMap = function initMap() {\n            if (originalInitMap) {\n              originalInitMap();\n            }\n            resolve(id);\n          };\n          existingScript.onerror = function (err) {\n            if (originalErrorCallback) {\n              originalErrorCallback(err);\n            }\n            reject(err);\n          };\n          return;\n        }\n      }\n      // Same script id, but either\n      // 1. requested URL is different\n      // 2. script failed to load\n      else {\n        existingScript.remove();\n      }\n    }\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url;\n    script.id = id;\n    script.async = true;\n    script.nonce = nonce || '';\n    script.onerror = function onerror(err) {\n      script.setAttribute('data-state', 'error');\n      reject(err);\n    };\n    windowWithGoogleMap.initMap = function onload() {\n      script.setAttribute('data-state', 'ready');\n      resolve(id);\n    };\n    document.head.appendChild(script);\n  }).catch(err => {\n    console.error('injectScript error: ', err);\n    throw err;\n  });\n}\n\nfunction isGoogleFontStyle(element) {\n  // 'Roboto' or 'Google Sans Text' font download\n  var href = element.href;\n  if (href && (href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0 || href.indexOf('https://fonts.googleapis.com/css?family=Google+Sans+Text') === 0)) {\n    return true;\n  }\n  // font style elements\n  if (\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.tagName.toLowerCase() === 'style' &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet.cssText &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.styleSheet.cssText.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.styleSheet.cssText = '';\n    return true;\n  }\n  // font style elements for other browsers\n  if (\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.tagName.toLowerCase() === 'style' &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.innerHTML &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.innerHTML.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.innerHTML = '';\n    return true;\n  }\n  // when google tries to add empty style\n  if (\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  element.tagName.toLowerCase() === 'style' &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  !element.styleSheet &&\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  !element.innerHTML) {\n    return true;\n  }\n  return false;\n}\n// Preventing the Google Maps library from downloading an extra font\nfunction preventGoogleFonts() {\n  // we override these methods only for one particular head element\n  // default methods for other elements are not affected\n  var head = document.getElementsByTagName('head')[0];\n  if (head) {\n    var trueInsertBefore = head.insertBefore.bind(head);\n    // TODO: adding return before reflect solves the TS issue\n    head.insertBefore = function insertBefore(newElement, referenceElement) {\n      if (!isGoogleFontStyle(newElement)) {\n        Reflect.apply(trueInsertBefore, head, [newElement, referenceElement]);\n      }\n      return newElement;\n    };\n    var trueAppend = head.appendChild.bind(head);\n    // TODO: adding return before reflect solves the TS issue\n    head.appendChild = function appendChild(textNode) {\n      if (!isGoogleFontStyle(textNode)) {\n        Reflect.apply(trueAppend, head, [textNode]);\n      }\n      return textNode;\n    };\n  }\n}\n\nvar cleaningUp = false;\nfunction DefaultLoadingElement() {\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n    children: \"Loading...\"\n  });\n}\nvar defaultLoadScriptProps = {\n  id: 'script-loader',\n  version: 'weekly'\n};\nclass LoadScript extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"check\", (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)());\n    _defineProperty(this, \"state\", {\n      loaded: false\n    });\n    _defineProperty(this, \"cleanupCallback\", () => {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      delete window.google.maps;\n      this.injectScript();\n    });\n    _defineProperty(this, \"isCleaningUp\", /*#__PURE__*/_asyncToGenerator(function* () {\n      function promiseCallback(resolve) {\n        if (!cleaningUp) {\n          resolve();\n        } else {\n          if (isBrowser) {\n            var timer = window.setInterval(function interval() {\n              if (!cleaningUp) {\n                window.clearInterval(timer);\n                resolve();\n              }\n            }, 1);\n          }\n        }\n        return;\n      }\n      return new Promise(promiseCallback);\n    }));\n    _defineProperty(this, \"cleanup\", () => {\n      cleaningUp = true;\n      var script = document.getElementById(this.props.id);\n      if (script && script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n      Array.prototype.slice.call(document.getElementsByTagName('script')).filter(function filter(script) {\n        return typeof script.src === 'string' && script.src.includes('maps.googleapis');\n      }).forEach(function forEach(script) {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n      });\n      Array.prototype.slice.call(document.getElementsByTagName('link')).filter(function filter(link) {\n        return link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans';\n      }).forEach(function forEach(link) {\n        if (link.parentNode) {\n          link.parentNode.removeChild(link);\n        }\n      });\n      Array.prototype.slice.call(document.getElementsByTagName('style')).filter(function filter(style) {\n        return style.innerText !== undefined && style.innerText.length > 0 && style.innerText.includes('.gm-');\n      }).forEach(function forEach(style) {\n        if (style.parentNode) {\n          style.parentNode.removeChild(style);\n        }\n      });\n    });\n    _defineProperty(this, \"injectScript\", () => {\n      if (this.props.preventGoogleFontsLoading) {\n        preventGoogleFonts();\n      }\n      invariant(!!this.props.id, 'LoadScript requires \"id\" prop to be a string: %s', this.props.id);\n      var injectScriptOptions = {\n        id: this.props.id,\n        nonce: this.props.nonce,\n        url: makeLoadScriptUrl(this.props)\n      };\n      injectScript(injectScriptOptions).then(() => {\n        if (this.props.onLoad) {\n          this.props.onLoad();\n        }\n        this.setState(function setLoaded() {\n          return {\n            loaded: true\n          };\n        });\n        return;\n      }).catch(err => {\n        if (this.props.onError) {\n          this.props.onError(err);\n        }\n        console.error(\"\\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(this.props.googleMapsApiKey || '-', \") or Client ID (\").concat(this.props.googleMapsClientId || '-', \") to <LoadScript />\\n          Otherwise it is a Network issue.\\n        \"));\n      });\n    });\n  }\n  componentDidMount() {\n    if (isBrowser) {\n      if (window.google && window.google.maps && !cleaningUp) {\n        console.error('google api is already presented');\n        return;\n      }\n      this.isCleaningUp().then(this.injectScript).catch(function error(err) {\n        console.error('Error at injecting script after cleaning up: ', err);\n      });\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.props.libraries !== prevProps.libraries) {\n      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n    }\n    if (isBrowser && prevProps.language !== this.props.language) {\n      this.cleanup();\n      // TODO: refactor to use gDSFP maybe... wait for hooks refactoring.\n      this.setState(function setLoaded() {\n        return {\n          loaded: false\n        };\n      }, this.cleanupCallback);\n    }\n  }\n  componentWillUnmount() {\n    if (isBrowser) {\n      this.cleanup();\n      var timeoutCallback = () => {\n        if (!this.check.current) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          delete window.google;\n          cleaningUp = false;\n        }\n      };\n      window.setTimeout(timeoutCallback, 1);\n      if (this.props.onUnmount) {\n        this.props.onUnmount();\n      }\n    }\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n      children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        ref: this.check\n      }), this.state.loaded ? this.props.children : this.props.loadingElement || (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultLoadingElement, {})]\n    });\n  }\n}\n_defineProperty(LoadScript, \"defaultProps\", defaultLoadScriptProps);\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n/* eslint-disable filenames/match-regex */\nvar previouslyLoadedUrl;\nfunction useLoadScript(_ref) {\n  var {\n    id = defaultLoadScriptProps.id,\n    version = defaultLoadScriptProps.version,\n    nonce,\n    googleMapsApiKey,\n    googleMapsClientId,\n    language,\n    region,\n    libraries,\n    preventGoogleFontsLoading,\n    channel,\n    mapIds,\n    authReferrerPolicy\n  } = _ref;\n  var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  var [isLoaded, setLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  var [loadError, setLoadError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function trackMountedState() {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function applyPreventGoogleFonts() {\n    if (isBrowser && preventGoogleFontsLoading) {\n      preventGoogleFonts();\n    }\n  }, [preventGoogleFontsLoading]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function validateLoadedState() {\n    if (isLoaded) {\n      invariant(!!window.google, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.');\n    }\n  }, [isLoaded]);\n  var url = makeLoadScriptUrl({\n    version,\n    googleMapsApiKey,\n    googleMapsClientId,\n    language,\n    region,\n    libraries,\n    channel,\n    mapIds,\n    authReferrerPolicy\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function loadScriptAndModifyLoadedState() {\n    if (!isBrowser) {\n      return;\n    }\n    function setLoadedIfMounted() {\n      if (isMounted.current) {\n        setLoaded(true);\n        previouslyLoadedUrl = url;\n      }\n    }\n    if (window.google && window.google.maps && previouslyLoadedUrl === url) {\n      setLoadedIfMounted();\n      return;\n    }\n    injectScript({\n      id,\n      url,\n      nonce\n    }).then(setLoadedIfMounted).catch(function handleInjectError(err) {\n      if (isMounted.current) {\n        setLoadError(err);\n      }\n      console.warn(\"\\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(googleMapsApiKey || '-', \") or Client ID (\").concat(googleMapsClientId || '-', \")\\n        Otherwise it is a Network issue.\\n      \"));\n      console.error(err);\n    });\n  }, [id, url, nonce]);\n  var prevLibraries = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function checkPerformance() {\n    if (prevLibraries.current && libraries !== prevLibraries.current) {\n      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n    }\n    prevLibraries.current = libraries;\n  }, [libraries]);\n  return {\n    isLoaded,\n    loadError,\n    url\n  };\n}\n\nvar _excluded$1 = [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"];\nvar defaultLoadingElement = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultLoadingElement, {});\nfunction LoadScriptNext(_ref) {\n  var {\n      loadingElement,\n      onLoad,\n      onError,\n      onUnmount,\n      children\n    } = _ref,\n    hookOptions = _objectWithoutProperties(_ref, _excluded$1);\n  var {\n    isLoaded,\n    loadError\n  } = useLoadScript(hookOptions);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnLoad() {\n    if (isLoaded && typeof onLoad === 'function') {\n      onLoad();\n    }\n  }, [isLoaded, onLoad]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnError() {\n    if (loadError && typeof onError === 'function') {\n      onError(loadError);\n    }\n  }, [loadError, onError]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnUnmount() {\n    return () => {\n      if (onUnmount) {\n        onUnmount();\n      }\n    };\n  }, [onUnmount]);\n  return isLoaded ? children : loadingElement || defaultLoadingElement;\n}\nvar LoadScriptNext$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(LoadScriptNext);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, [])).next());\n  });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n// do not edit .js files directly - edit src/index.jst\n\nvar fastDeepEqual$1 = function equal(a, b) {\n  if (a === b) return true;\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n    for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a !== a && b !== b;\n};\nvar isEqual = /*@__PURE__*/getDefaultExportFromCjs(fastDeepEqual$1);\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at.\n *\n *      Http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_ID = \"__googleMapsScriptId\";\n/**\n * The status of the [[Loader]].\n */\nvar LoaderStatus;\n(function (LoaderStatus) {\n  LoaderStatus[LoaderStatus[\"INITIALIZED\"] = 0] = \"INITIALIZED\";\n  LoaderStatus[LoaderStatus[\"LOADING\"] = 1] = \"LOADING\";\n  LoaderStatus[LoaderStatus[\"SUCCESS\"] = 2] = \"SUCCESS\";\n  LoaderStatus[LoaderStatus[\"FAILURE\"] = 3] = \"FAILURE\";\n})(LoaderStatus || (LoaderStatus = {}));\n/**\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\n * dynamically using\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n * It works by dynamically creating and appending a script node to the the\n * document head and wrapping the callback function so as to return a promise.\n *\n * ```\n * const loader = new Loader({\n *   apiKey: \"\",\n *   version: \"weekly\",\n *   libraries: [\"places\"]\n * });\n *\n * loader.load().then((google) => {\n *   const map = new google.maps.Map(...)\n * })\n * ```\n */\nclass Loader {\n  /**\n   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\n   * using this library, instead the defaults are set by the Google Maps\n   * JavaScript API server.\n   *\n   * ```\n   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\n   * ```\n   */\n  constructor(_ref) {\n    var {\n      apiKey,\n      authReferrerPolicy,\n      channel,\n      client,\n      id = DEFAULT_ID,\n      language,\n      libraries = [],\n      mapIds,\n      nonce,\n      region,\n      retries = 3,\n      url = \"https://maps.googleapis.com/maps/api/js\",\n      version\n    } = _ref;\n    this.callbacks = [];\n    this.done = false;\n    this.loading = false;\n    this.errors = [];\n    this.apiKey = apiKey;\n    this.authReferrerPolicy = authReferrerPolicy;\n    this.channel = channel;\n    this.client = client;\n    this.id = id || DEFAULT_ID; // Do not allow empty string\n    this.language = language;\n    this.libraries = libraries;\n    this.mapIds = mapIds;\n    this.nonce = nonce;\n    this.region = region;\n    this.retries = retries;\n    this.url = url;\n    this.version = version;\n    if (Loader.instance) {\n      if (!isEqual(this.options, Loader.instance.options)) {\n        throw new Error(\"Loader must not be called again with different options. \".concat(JSON.stringify(this.options), \" !== \").concat(JSON.stringify(Loader.instance.options)));\n      }\n      return Loader.instance;\n    }\n    Loader.instance = this;\n  }\n  get options() {\n    return {\n      version: this.version,\n      apiKey: this.apiKey,\n      channel: this.channel,\n      client: this.client,\n      id: this.id,\n      libraries: this.libraries,\n      language: this.language,\n      region: this.region,\n      mapIds: this.mapIds,\n      nonce: this.nonce,\n      url: this.url,\n      authReferrerPolicy: this.authReferrerPolicy\n    };\n  }\n  get status() {\n    if (this.errors.length) {\n      return LoaderStatus.FAILURE;\n    }\n    if (this.done) {\n      return LoaderStatus.SUCCESS;\n    }\n    if (this.loading) {\n      return LoaderStatus.LOADING;\n    }\n    return LoaderStatus.INITIALIZED;\n  }\n  get failed() {\n    return this.done && !this.loading && this.errors.length >= this.retries + 1;\n  }\n  /**\n   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\n   *\n   * @ignore\n   * @deprecated\n   */\n  createUrl() {\n    var url = this.url;\n    url += \"?callback=__googleMapsCallback&loading=async\";\n    if (this.apiKey) {\n      url += \"&key=\".concat(this.apiKey);\n    }\n    if (this.channel) {\n      url += \"&channel=\".concat(this.channel);\n    }\n    if (this.client) {\n      url += \"&client=\".concat(this.client);\n    }\n    if (this.libraries.length > 0) {\n      url += \"&libraries=\".concat(this.libraries.join(\",\"));\n    }\n    if (this.language) {\n      url += \"&language=\".concat(this.language);\n    }\n    if (this.region) {\n      url += \"&region=\".concat(this.region);\n    }\n    if (this.version) {\n      url += \"&v=\".concat(this.version);\n    }\n    if (this.mapIds) {\n      url += \"&map_ids=\".concat(this.mapIds.join(\",\"));\n    }\n    if (this.authReferrerPolicy) {\n      url += \"&auth_referrer_policy=\".concat(this.authReferrerPolicy);\n    }\n    return url;\n  }\n  deleteScript() {\n    var script = document.getElementById(this.id);\n    if (script) {\n      script.remove();\n    }\n  }\n  /**\n   * Load the Google Maps JavaScript API script and return a Promise.\n   * @deprecated, use importLibrary() instead.\n   */\n  load() {\n    return this.loadPromise();\n  }\n  /**\n   * Load the Google Maps JavaScript API script and return a Promise.\n   *\n   * @ignore\n   * @deprecated, use importLibrary() instead.\n   */\n  loadPromise() {\n    return new Promise((resolve, reject) => {\n      this.loadCallback(err => {\n        if (!err) {\n          resolve(window.google);\n        } else {\n          reject(err.error);\n        }\n      });\n    });\n  }\n  importLibrary(name) {\n    this.execute();\n    return google.maps.importLibrary(name);\n  }\n  /**\n   * Load the Google Maps JavaScript API script with a callback.\n   * @deprecated, use importLibrary() instead.\n   */\n  loadCallback(fn) {\n    this.callbacks.push(fn);\n    this.execute();\n  }\n  /**\n   * Set the script on document.\n   */\n  setScript() {\n    var _a, _b;\n    if (document.getElementById(this.id)) {\n      // TODO wrap onerror callback for cases where the script was loaded elsewhere\n      this.callback();\n      return;\n    }\n    var params = {\n      key: this.apiKey,\n      channel: this.channel,\n      client: this.client,\n      libraries: this.libraries.length && this.libraries,\n      v: this.version,\n      mapIds: this.mapIds,\n      language: this.language,\n      region: this.region,\n      authReferrerPolicy: this.authReferrerPolicy\n    };\n    // keep the URL minimal:\n    Object.keys(params).forEach(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    key => !params[key] && delete params[key]);\n    if (!((_b = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary)) {\n      // tweaked copy of https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n      // which also sets the base url, the id, and the nonce\n      /* eslint-disable */\n      (g => {\n        // @ts-ignore\n        var h,\n          a,\n          k,\n          p = \"The Google Maps JavaScript API\",\n          c = \"google\",\n          l = \"importLibrary\",\n          q = \"__ib__\",\n          m = document,\n          b = window;\n        // @ts-ignore\n        b = b[c] || (b[c] = {});\n        // @ts-ignore\n        var d = b.maps || (b.maps = {}),\n          r = new Set(),\n          e = new URLSearchParams(),\n          u = () =>\n          // @ts-ignore\n          h || (h = new Promise((f, n) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            yield a = m.createElement(\"script\");\n            a.id = this.id;\n            e.set(\"libraries\", [...r] + \"\");\n            // @ts-ignore\n            for (k in g) e.set(k.replace(/[A-Z]/g, t => \"_\" + t[0].toLowerCase()), g[k]);\n            e.set(\"callback\", c + \".maps.\" + q);\n            a.src = this.url + \"?\" + e;\n            d[q] = f;\n            a.onerror = () => h = n(Error(p + \" could not load.\"));\n            // @ts-ignore\n            a.nonce = this.nonce || ((_a = m.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n            m.head.append(a);\n          })));\n        // @ts-ignore\n        d[l] ? console.warn(p + \" only loads once. Ignoring:\", g) : d[l] = function (f) {\n          for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            n[_key - 1] = arguments[_key];\n          }\n          return r.add(f) && u().then(() => d[l](f, ...n));\n        };\n      })(params);\n      /* eslint-enable */\n    }\n    // While most libraries populate the global namespace when loaded via bootstrap params,\n    // this is not the case for \"marker\" when used with the inline bootstrap loader\n    // (and maybe others in the future). So ensure there is an importLibrary for each:\n    var libraryPromises = this.libraries.map(library => this.importLibrary(library));\n    // ensure at least one library, to kick off loading...\n    if (!libraryPromises.length) {\n      libraryPromises.push(this.importLibrary(\"core\"));\n    }\n    Promise.all(libraryPromises).then(() => this.callback(), error => {\n      var event = new ErrorEvent(\"error\", {\n        error\n      }); // for backwards compat\n      this.loadErrorCallback(event);\n    });\n  }\n  /**\n   * Reset the loader state.\n   */\n  reset() {\n    this.deleteScript();\n    this.done = false;\n    this.loading = false;\n    this.errors = [];\n    this.onerrorEvent = null;\n  }\n  resetIfRetryingFailed() {\n    if (this.failed) {\n      this.reset();\n    }\n  }\n  loadErrorCallback(e) {\n    this.errors.push(e);\n    if (this.errors.length <= this.retries) {\n      var delay = this.errors.length * Math.pow(2, this.errors.length);\n      console.error(\"Failed to load Google Maps script, retrying in \".concat(delay, \" ms.\"));\n      setTimeout(() => {\n        this.deleteScript();\n        this.setScript();\n      }, delay);\n    } else {\n      this.onerrorEvent = e;\n      this.callback();\n    }\n  }\n  callback() {\n    this.done = true;\n    this.loading = false;\n    this.callbacks.forEach(cb => {\n      cb(this.onerrorEvent);\n    });\n    this.callbacks = [];\n  }\n  execute() {\n    this.resetIfRetryingFailed();\n    if (this.loading) {\n      // do nothing but wait\n      return;\n    }\n    if (this.done) {\n      this.callback();\n    } else {\n      // short circuit and warn if google.maps is already loaded\n      if (window.google && window.google.maps && window.google.maps.version) {\n        console.warn(\"Google Maps already loaded outside @googlemaps/js-api-loader. \" + \"This may result in undesirable behavior as options and script parameters may not match.\");\n        this.callback();\n        return;\n      }\n      this.loading = true;\n      this.setScript();\n    }\n  }\n}\n\nvar defaultLibraries = ['maps'];\nfunction useJsApiLoader(_ref) {\n  var {\n    id = defaultLoadScriptProps.id,\n    version = defaultLoadScriptProps.version,\n    nonce,\n    googleMapsApiKey,\n    // googleMapsClientId,\n    language,\n    region,\n    libraries = defaultLibraries,\n    preventGoogleFontsLoading,\n    // channel,\n    mapIds,\n    authReferrerPolicy\n  } = _ref;\n  var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  var [isLoaded, setLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  var [loadError, setLoadError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function trackMountedState() {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  var loader = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new Loader({\n      id,\n      apiKey: googleMapsApiKey,\n      version,\n      libraries,\n      language: language || 'en',\n      region: region || 'US',\n      mapIds: mapIds || [],\n      nonce: nonce || '',\n      authReferrerPolicy: authReferrerPolicy || 'origin'\n    });\n  }, [id, googleMapsApiKey, version, libraries, language, region, mapIds, nonce, authReferrerPolicy]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function effect() {\n    if (isLoaded) {\n      return;\n    } else {\n      loader.load().then(() => {\n        if (isMounted.current) {\n          setLoaded(true);\n        }\n        return;\n      }).catch(error => {\n        setLoadError(error);\n      });\n    }\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (isBrowser && preventGoogleFontsLoading) {\n      preventGoogleFonts();\n    }\n  }, [preventGoogleFontsLoading]);\n  var prevLibraries = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (prevLibraries.current && libraries !== prevLibraries.current) {\n      console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n    }\n    prevLibraries.current = libraries;\n  }, [libraries]);\n  return {\n    isLoaded,\n    loadError\n  };\n}\n\nfunction ownKeys$f(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$f(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$f(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$f(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$h = {};\nvar updaterMap$h = {\n  options(instance, options) {\n    instance.setOptions(options);\n  }\n};\nfunction TrafficLayerFunctional(_ref) {\n  var {\n    options,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var trafficLayer = new google.maps.TrafficLayer(_objectSpread$f(_objectSpread$f({}, options), {}, {\n      map\n    }));\n    setInstance(trafficLayer);\n    if (onLoad) {\n      onLoad(trafficLayer);\n    }\n    return () => {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar TrafficLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TrafficLayerFunctional);\nclass TrafficLayer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      trafficLayer: null\n    });\n    _defineProperty(this, \"setTrafficLayerCallback\", () => {\n      if (this.state.trafficLayer !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.trafficLayer);\n      }\n    });\n    _defineProperty(this, \"registeredEvents\", []);\n  }\n  componentDidMount() {\n    var trafficLayer = new google.maps.TrafficLayer(_objectSpread$f(_objectSpread$f({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$h,\n      eventMap: eventMap$h,\n      prevProps: {},\n      nextProps: this.props,\n      instance: trafficLayer\n    });\n    this.setState(function setTrafficLayer() {\n      return {\n        trafficLayer\n      };\n    }, this.setTrafficLayerCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.trafficLayer !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$h,\n        eventMap: eventMap$h,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.trafficLayer\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.trafficLayer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.trafficLayer);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.trafficLayer.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(TrafficLayer, \"contextType\", MapContext);\n\nfunction BicyclingLayerFunctional(_ref) {\n  var {\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var bicyclingLayer = new google.maps.BicyclingLayer();\n    setInstance(bicyclingLayer);\n    bicyclingLayer.setMap(map);\n    if (onLoad) {\n      onLoad(bicyclingLayer);\n    }\n    return () => {\n      if (bicyclingLayer !== null) {\n        if (onUnmount) {\n          onUnmount(bicyclingLayer);\n        }\n        bicyclingLayer.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar BicyclingLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BicyclingLayerFunctional);\nclass BicyclingLayer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      bicyclingLayer: null\n    });\n    _defineProperty(this, \"setBicyclingLayerCallback\", () => {\n      if (this.state.bicyclingLayer !== null) {\n        this.state.bicyclingLayer.setMap(this.context);\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.bicyclingLayer);\n        }\n      }\n    });\n  }\n  componentDidMount() {\n    var bicyclingLayer = new google.maps.BicyclingLayer();\n    this.setState(() => {\n      return {\n        bicyclingLayer\n      };\n    }, this.setBicyclingLayerCallback);\n  }\n  componentWillUnmount() {\n    if (this.state.bicyclingLayer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.bicyclingLayer);\n      }\n      this.state.bicyclingLayer.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(BicyclingLayer, \"contextType\", MapContext);\n\nfunction TransitLayerFunctional(_ref) {\n  var {\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var transitLayer = new google.maps.TransitLayer();\n    setInstance(transitLayer);\n    transitLayer.setMap(map);\n    if (onLoad) {\n      onLoad(transitLayer);\n    }\n    return () => {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar TransitLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TransitLayerFunctional);\nclass TransitLayer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      transitLayer: null\n    });\n    _defineProperty(this, \"setTransitLayerCallback\", () => {\n      if (this.state.transitLayer !== null) {\n        this.state.transitLayer.setMap(this.context);\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.transitLayer);\n        }\n      }\n    });\n  }\n  componentDidMount() {\n    var transitLayer = new google.maps.TransitLayer();\n    this.setState(function setTransitLayer() {\n      return {\n        transitLayer\n      };\n    }, this.setTransitLayerCallback);\n  }\n  componentWillUnmount() {\n    if (this.state.transitLayer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.transitLayer);\n      }\n      this.state.transitLayer.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(TransitLayer, \"contextType\", MapContext);\n\nfunction ownKeys$e(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$e(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$e(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$e(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$g = {\n  onCircleComplete: 'circlecomplete',\n  onMarkerComplete: 'markercomplete',\n  onOverlayComplete: 'overlaycomplete',\n  onPolygonComplete: 'polygoncomplete',\n  onPolylineComplete: 'polylinecomplete',\n  onRectangleComplete: 'rectanglecomplete'\n};\nvar updaterMap$g = {\n  drawingMode(instance, drawingMode) {\n    instance.setDrawingMode(drawingMode);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  }\n};\nfunction DrawingManagerFunctional(_ref) {\n  var {\n    options,\n    drawingMode,\n    onCircleComplete,\n    onMarkerComplete,\n    onOverlayComplete,\n    onPolygonComplete,\n    onPolylineComplete,\n    onRectangleComplete,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [circlecompleteListener, setCircleCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [markercompleteListener, setMarkerCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [overlaycompleteListener, setOverlayCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [polygoncompleteListener, setPolygonCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [polylinecompleteListener, setPolylineCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rectanglecompleteListener, setRectangleCompleteListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setDrawingMode(drawingMode !== null && drawingMode !== void 0 ? drawingMode : null);\n    }\n  }, [instance, drawingMode]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onCircleComplete) {\n      if (circlecompleteListener !== null) {\n        google.maps.event.removeListener(circlecompleteListener);\n      }\n      setCircleCompleteListener(google.maps.event.addListener(instance, 'circlecomplete', onCircleComplete));\n    }\n  }, [instance, onCircleComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMarkerComplete) {\n      if (markercompleteListener !== null) {\n        google.maps.event.removeListener(markercompleteListener);\n      }\n      setMarkerCompleteListener(google.maps.event.addListener(instance, 'markercomplete', onMarkerComplete));\n    }\n  }, [instance, onMarkerComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onOverlayComplete) {\n      if (overlaycompleteListener !== null) {\n        google.maps.event.removeListener(overlaycompleteListener);\n      }\n      setOverlayCompleteListener(google.maps.event.addListener(instance, 'overlaycomplete', onOverlayComplete));\n    }\n  }, [instance, onOverlayComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onPolygonComplete) {\n      if (polygoncompleteListener !== null) {\n        google.maps.event.removeListener(polygoncompleteListener);\n      }\n      setPolygonCompleteListener(google.maps.event.addListener(instance, 'polygoncomplete', onPolygonComplete));\n    }\n  }, [instance, onPolygonComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onPolylineComplete) {\n      if (polylinecompleteListener !== null) {\n        google.maps.event.removeListener(polylinecompleteListener);\n      }\n      setPolylineCompleteListener(google.maps.event.addListener(instance, 'polylinecomplete', onPolylineComplete));\n    }\n  }, [instance, onPolylineComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRectangleComplete) {\n      if (rectanglecompleteListener !== null) {\n        google.maps.event.removeListener(rectanglecompleteListener);\n      }\n      setRectangleCompleteListener(google.maps.event.addListener(instance, 'rectanglecomplete', onRectangleComplete));\n    }\n  }, [instance, onRectangleComplete]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    invariant(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n    var drawingManager = new google.maps.drawing.DrawingManager(_objectSpread$e(_objectSpread$e({}, options), {}, {\n      map\n    }));\n    if (drawingMode) {\n      drawingManager.setDrawingMode(drawingMode);\n    }\n    if (onCircleComplete) {\n      setCircleCompleteListener(google.maps.event.addListener(drawingManager, 'circlecomplete', onCircleComplete));\n    }\n    if (onMarkerComplete) {\n      setMarkerCompleteListener(google.maps.event.addListener(drawingManager, 'markercomplete', onMarkerComplete));\n    }\n    if (onOverlayComplete) {\n      setOverlayCompleteListener(google.maps.event.addListener(drawingManager, 'overlaycomplete', onOverlayComplete));\n    }\n    if (onPolygonComplete) {\n      setPolygonCompleteListener(google.maps.event.addListener(drawingManager, 'polygoncomplete', onPolygonComplete));\n    }\n    if (onPolylineComplete) {\n      setPolylineCompleteListener(google.maps.event.addListener(drawingManager, 'polylinecomplete', onPolylineComplete));\n    }\n    if (onRectangleComplete) {\n      setRectangleCompleteListener(google.maps.event.addListener(drawingManager, 'rectanglecomplete', onRectangleComplete));\n    }\n    setInstance(drawingManager);\n    if (onLoad) {\n      onLoad(drawingManager);\n    }\n    return () => {\n      if (instance !== null) {\n        if (circlecompleteListener) {\n          google.maps.event.removeListener(circlecompleteListener);\n        }\n        if (markercompleteListener) {\n          google.maps.event.removeListener(markercompleteListener);\n        }\n        if (overlaycompleteListener) {\n          google.maps.event.removeListener(overlaycompleteListener);\n        }\n        if (polygoncompleteListener) {\n          google.maps.event.removeListener(polygoncompleteListener);\n        }\n        if (polylinecompleteListener) {\n          google.maps.event.removeListener(polylinecompleteListener);\n        }\n        if (rectanglecompleteListener) {\n          google.maps.event.removeListener(rectanglecompleteListener);\n        }\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar DrawingManagerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(DrawingManagerFunctional);\nclass DrawingManager extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor(props) {\n    super(props);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      drawingManager: null\n    });\n    _defineProperty(this, \"setDrawingManagerCallback\", () => {\n      if (this.state.drawingManager !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.drawingManager);\n      }\n    });\n    invariant(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n  }\n  componentDidMount() {\n    var drawingManager = new google.maps.drawing.DrawingManager(_objectSpread$e(_objectSpread$e({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$g,\n      eventMap: eventMap$g,\n      prevProps: {},\n      nextProps: this.props,\n      instance: drawingManager\n    });\n    this.setState(function setDrawingManager() {\n      return {\n        drawingManager\n      };\n    }, this.setDrawingManagerCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.drawingManager !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$g,\n        eventMap: eventMap$g,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.drawingManager\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.drawingManager !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.drawingManager);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.drawingManager.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(DrawingManager, \"contextType\", MapContext);\n\nfunction ownKeys$d(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$d(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$d(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$d(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$f = {\n  onAnimationChanged: 'animation_changed',\n  onClick: 'click',\n  onClickableChanged: 'clickable_changed',\n  onCursorChanged: 'cursor_changed',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDraggableChanged: 'draggable_changed',\n  onDragStart: 'dragstart',\n  onFlatChanged: 'flat_changed',\n  onIconChanged: 'icon_changed',\n  onMouseDown: 'mousedown',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onPositionChanged: 'position_changed',\n  onRightClick: 'rightclick',\n  onShapeChanged: 'shape_changed',\n  onTitleChanged: 'title_changed',\n  onVisibleChanged: 'visible_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$f = {\n  animation(instance, animation) {\n    instance.setAnimation(animation);\n  },\n  clickable(instance, clickable) {\n    instance.setClickable(clickable);\n  },\n  cursor(instance, cursor) {\n    instance.setCursor(cursor);\n  },\n  draggable(instance, draggable) {\n    instance.setDraggable(draggable);\n  },\n  icon(instance, icon) {\n    instance.setIcon(icon);\n  },\n  label(instance, label) {\n    instance.setLabel(label);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  opacity(instance, opacity) {\n    instance.setOpacity(opacity);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  position(instance, position) {\n    instance.setPosition(position);\n  },\n  shape(instance, shape) {\n    instance.setShape(shape);\n  },\n  title(instance, title) {\n    instance.setTitle(title);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  },\n  zIndex(instance, zIndex) {\n    instance.setZIndex(zIndex);\n  }\n};\nvar defaultOptions$5 = {};\nfunction MarkerFunctional(_ref) {\n  var {\n    position,\n    options,\n    clusterer,\n    noClustererRedraw,\n    children,\n    draggable,\n    visible,\n    animation,\n    clickable,\n    cursor,\n    icon,\n    label,\n    opacity,\n    shape,\n    title,\n    zIndex,\n    onClick,\n    onDblClick,\n    onDrag,\n    onDragEnd,\n    onDragStart,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onMouseDown,\n    onRightClick,\n    onClickableChanged,\n    onCursorChanged,\n    onAnimationChanged,\n    onDraggableChanged,\n    onFlatChanged,\n    onIconChanged,\n    onPositionChanged,\n    onShapeChanged,\n    onTitleChanged,\n    onVisibleChanged,\n    onZindexChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickableChangedListener, setClickableChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [cursorChangedListener, setCursorChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [animationChangedListener, setAnimationChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [draggableChangedListener, setDraggableChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [flatChangedListener, setFlatChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [iconChangedListener, setIconChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [positionChangedListener, setPositionChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [shapeChangedListener, setShapeChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [titleChangedListener, setTitleChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [visibleChangedListener, setVisibleChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [zIndexChangedListener, setZindexChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof options !== 'undefined' && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof draggable !== 'undefined' && instance !== null) {\n      instance.setDraggable(draggable);\n    }\n  }, [instance, draggable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (position && instance !== null) {\n      instance.setPosition(position);\n    }\n  }, [instance, position]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && instance !== null) {\n      instance.setVisible(visible);\n    }\n  }, [instance, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    instance === null || instance === void 0 || instance.setAnimation(animation);\n  }, [instance, animation]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && clickable !== undefined) {\n      instance.setClickable(clickable);\n    }\n  }, [instance, clickable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && cursor !== undefined) {\n      instance.setCursor(cursor);\n    }\n  }, [instance, cursor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && icon !== undefined) {\n      instance.setIcon(icon);\n    }\n  }, [instance, icon]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && label !== undefined) {\n      instance.setLabel(label);\n    }\n  }, [instance, label]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && opacity !== undefined) {\n      instance.setOpacity(opacity);\n    }\n  }, [instance, opacity]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && shape !== undefined) {\n      instance.setShape(shape);\n    }\n  }, [instance, shape]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && title !== undefined) {\n      instance.setTitle(title);\n    }\n  }, [instance, title]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && zIndex !== undefined) {\n      instance.setZIndex(zIndex);\n    }\n  }, [instance, zIndex]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragEnd) {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragStart) {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRightClick) {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDrag) {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClickableChanged) {\n      if (clickableChangedListener !== null) {\n        google.maps.event.removeListener(clickableChangedListener);\n      }\n      setClickableChangedListener(google.maps.event.addListener(instance, 'clickable_changed', onClickableChanged));\n    }\n  }, [onClickableChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onCursorChanged) {\n      if (cursorChangedListener !== null) {\n        google.maps.event.removeListener(cursorChangedListener);\n      }\n      setCursorChangedListener(google.maps.event.addListener(instance, 'cursor_changed', onCursorChanged));\n    }\n  }, [onCursorChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onAnimationChanged) {\n      if (animationChangedListener !== null) {\n        google.maps.event.removeListener(animationChangedListener);\n      }\n      setAnimationChangedListener(google.maps.event.addListener(instance, 'animation_changed', onAnimationChanged));\n    }\n  }, [onAnimationChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDraggableChanged) {\n      if (draggableChangedListener !== null) {\n        google.maps.event.removeListener(draggableChangedListener);\n      }\n      setDraggableChangedListener(google.maps.event.addListener(instance, 'draggable_changed', onDraggableChanged));\n    }\n  }, [onDraggableChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onFlatChanged) {\n      if (flatChangedListener !== null) {\n        google.maps.event.removeListener(flatChangedListener);\n      }\n      setFlatChangedListener(google.maps.event.addListener(instance, 'flat_changed', onFlatChanged));\n    }\n  }, [onFlatChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onIconChanged) {\n      if (iconChangedListener !== null) {\n        google.maps.event.removeListener(iconChangedListener);\n      }\n      setIconChangedListener(google.maps.event.addListener(instance, 'icon_changed', onIconChanged));\n    }\n  }, [onIconChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onPositionChanged) {\n      if (positionChangedListener !== null) {\n        google.maps.event.removeListener(positionChangedListener);\n      }\n      setPositionChangedListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n    }\n  }, [onPositionChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onShapeChanged) {\n      if (shapeChangedListener !== null) {\n        google.maps.event.removeListener(shapeChangedListener);\n      }\n      setShapeChangedListener(google.maps.event.addListener(instance, 'shape_changed', onShapeChanged));\n    }\n  }, [onShapeChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onTitleChanged) {\n      if (titleChangedListener !== null) {\n        google.maps.event.removeListener(titleChangedListener);\n      }\n      setTitleChangedListener(google.maps.event.addListener(instance, 'title_changed', onTitleChanged));\n    }\n  }, [onTitleChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onVisibleChanged) {\n      if (visibleChangedListener !== null) {\n        google.maps.event.removeListener(visibleChangedListener);\n      }\n      setVisibleChangedListener(google.maps.event.addListener(instance, 'visible_changed', onVisibleChanged));\n    }\n  }, [onVisibleChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onZindexChanged) {\n      if (zIndexChangedListener !== null) {\n        google.maps.event.removeListener(zIndexChangedListener);\n      }\n      setZindexChangedListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n    }\n  }, [onZindexChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var markerOptions = _objectSpread$d(_objectSpread$d(_objectSpread$d({}, options || defaultOptions$5), clusterer ? defaultOptions$5 : {\n      map\n    }), {}, {\n      position\n    });\n    var marker = new google.maps.Marker(markerOptions);\n    if (clusterer) {\n      clusterer.addMarker(marker, !!noClustererRedraw);\n    } else {\n      marker.setMap(map);\n    }\n    if (position) {\n      marker.setPosition(position);\n    }\n    if (typeof visible !== 'undefined') {\n      marker.setVisible(visible);\n    }\n    if (typeof draggable !== 'undefined') {\n      marker.setDraggable(draggable);\n    }\n    if (typeof clickable !== 'undefined') {\n      marker.setClickable(clickable);\n    }\n    if (typeof cursor === 'string') {\n      marker.setCursor(cursor);\n    }\n    if (icon) {\n      marker.setIcon(icon);\n    }\n    if (typeof label !== 'undefined') {\n      marker.setLabel(label);\n    }\n    if (typeof opacity !== 'undefined') {\n      marker.setOpacity(opacity);\n    }\n    if (shape) {\n      marker.setShape(shape);\n    }\n    if (typeof title === 'string') {\n      marker.setTitle(title);\n    }\n    if (typeof zIndex === 'number') {\n      marker.setZIndex(zIndex);\n    }\n    if (onDblClick) {\n      setDblclickListener(google.maps.event.addListener(marker, 'dblclick', onDblClick));\n    }\n    if (onDragEnd) {\n      setDragendListener(google.maps.event.addListener(marker, 'dragend', onDragEnd));\n    }\n    if (onDragStart) {\n      setDragstartListener(google.maps.event.addListener(marker, 'dragstart', onDragStart));\n    }\n    if (onMouseDown) {\n      setMousedownListener(google.maps.event.addListener(marker, 'mousedown', onMouseDown));\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(marker, 'mouseout', onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(marker, 'mouseover', onMouseOver));\n    }\n    if (onMouseUp) {\n      setMouseupListener(google.maps.event.addListener(marker, 'mouseup', onMouseUp));\n    }\n    if (onRightClick) {\n      setRightclickListener(google.maps.event.addListener(marker, 'rightclick', onRightClick));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(marker, 'click', onClick));\n    }\n    if (onDrag) {\n      setDragListener(google.maps.event.addListener(marker, 'drag', onDrag));\n    }\n    if (onClickableChanged) {\n      setClickableChangedListener(google.maps.event.addListener(marker, 'clickable_changed', onClickableChanged));\n    }\n    if (onCursorChanged) {\n      setCursorChangedListener(google.maps.event.addListener(marker, 'cursor_changed', onCursorChanged));\n    }\n    if (onAnimationChanged) {\n      setAnimationChangedListener(google.maps.event.addListener(marker, 'animation_changed', onAnimationChanged));\n    }\n    if (onDraggableChanged) {\n      setDraggableChangedListener(google.maps.event.addListener(marker, 'draggable_changed', onDraggableChanged));\n    }\n    if (onFlatChanged) {\n      setFlatChangedListener(google.maps.event.addListener(marker, 'flat_changed', onFlatChanged));\n    }\n    if (onIconChanged) {\n      setIconChangedListener(google.maps.event.addListener(marker, 'icon_changed', onIconChanged));\n    }\n    if (onPositionChanged) {\n      setPositionChangedListener(google.maps.event.addListener(marker, 'position_changed', onPositionChanged));\n    }\n    if (onShapeChanged) {\n      setShapeChangedListener(google.maps.event.addListener(marker, 'shape_changed', onShapeChanged));\n    }\n    if (onTitleChanged) {\n      setTitleChangedListener(google.maps.event.addListener(marker, 'title_changed', onTitleChanged));\n    }\n    if (onVisibleChanged) {\n      setVisibleChangedListener(google.maps.event.addListener(marker, 'visible_changed', onVisibleChanged));\n    }\n    if (onZindexChanged) {\n      setZindexChangedListener(google.maps.event.addListener(marker, 'zindex_changed', onZindexChanged));\n    }\n    setInstance(marker);\n    if (onLoad) {\n      onLoad(marker);\n    }\n    return () => {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (clickableChangedListener !== null) {\n        google.maps.event.removeListener(clickableChangedListener);\n      }\n      if (cursorChangedListener !== null) {\n        google.maps.event.removeListener(cursorChangedListener);\n      }\n      if (animationChangedListener !== null) {\n        google.maps.event.removeListener(animationChangedListener);\n      }\n      if (draggableChangedListener !== null) {\n        google.maps.event.removeListener(draggableChangedListener);\n      }\n      if (flatChangedListener !== null) {\n        google.maps.event.removeListener(flatChangedListener);\n      }\n      if (iconChangedListener !== null) {\n        google.maps.event.removeListener(iconChangedListener);\n      }\n      if (positionChangedListener !== null) {\n        google.maps.event.removeListener(positionChangedListener);\n      }\n      if (titleChangedListener !== null) {\n        google.maps.event.removeListener(titleChangedListener);\n      }\n      if (visibleChangedListener !== null) {\n        google.maps.event.removeListener(visibleChangedListener);\n      }\n      if (zIndexChangedListener !== null) {\n        google.maps.event.removeListener(zIndexChangedListener);\n      }\n      if (onUnmount) {\n        onUnmount(marker);\n      }\n      if (clusterer) {\n        clusterer.removeMarker(marker, !!noClustererRedraw);\n      } else if (marker) {\n        marker.setMap(null);\n      }\n    };\n  }, []);\n  var chx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return children ? react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, child => {\n      if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child)) {\n        return child;\n      }\n      var elementChild = child;\n      return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elementChild, {\n        anchor: instance\n      });\n    }) : null;\n  }, [children, instance]);\n  return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n    children: chx\n  }) || null;\n}\nvar MarkerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerFunctional);\nclass Marker extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n  }\n  componentDidMount() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      var markerOptions = _objectSpread$d(_objectSpread$d(_objectSpread$d({}, _this.props.options || defaultOptions$5), _this.props.clusterer ? defaultOptions$5 : {\n        map: _this.context\n      }), {}, {\n        position: _this.props.position\n      });\n      // Unfortunately we can't just do this in the contstructor, because the\n      // `MapContext` might not be filled in yet.\n      _this.marker = new google.maps.Marker(markerOptions);\n      if (_this.props.clusterer) {\n        _this.props.clusterer.addMarker(_this.marker, !!_this.props.noClustererRedraw);\n      } else {\n        _this.marker.setMap(_this.context);\n      }\n      _this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$f,\n        eventMap: eventMap$f,\n        prevProps: {},\n        nextProps: _this.props,\n        instance: _this.marker\n      });\n      if (_this.props.onLoad) {\n        _this.props.onLoad(_this.marker);\n      }\n    })();\n  }\n  componentDidUpdate(prevProps) {\n    if (this.marker) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$f,\n        eventMap: eventMap$f,\n        prevProps,\n        nextProps: this.props,\n        instance: this.marker\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (!this.marker) {\n      return;\n    }\n    if (this.props.onUnmount) {\n      this.props.onUnmount(this.marker);\n    }\n    unregisterEvents(this.registeredEvents);\n    if (this.props.clusterer) {\n      this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw);\n    } else if (this.marker) {\n      this.marker.setMap(null);\n    }\n  }\n  render() {\n    var children = this.props.children ? react__WEBPACK_IMPORTED_MODULE_1__.Children.map(this.props.children, child => {\n      if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child)) {\n        return child;\n      }\n      var elementChild = child;\n      return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elementChild, {\n        anchor: this.marker\n      });\n    }) : null;\n    return children || null;\n  }\n}\n_defineProperty(Marker, \"contextType\", MapContext);\n\nvar ClusterIcon = /** @class */function () {\n  function ClusterIcon(cluster, styles) {\n    cluster.getClusterer().extend(ClusterIcon, google.maps.OverlayView);\n    this.cluster = cluster;\n    this.clusterClassName = this.cluster.getClusterer().getClusterClass();\n    this.className = this.clusterClassName;\n    this.styles = styles;\n    this.center = undefined;\n    this.div = null;\n    this.sums = null;\n    this.visible = false;\n    this.boundsChangedListener = null;\n    this.url = '';\n    this.height = 0;\n    this.width = 0;\n    this.anchorText = [0, 0];\n    this.anchorIcon = [0, 0];\n    this.textColor = 'black';\n    this.textSize = 11;\n    this.textDecoration = 'none';\n    this.fontWeight = 'bold';\n    this.fontStyle = 'normal';\n    this.fontFamily = 'Arial,sans-serif';\n    this.backgroundPosition = '0 0';\n    this.cMouseDownInCluster = null;\n    this.cDraggingMapByCluster = null;\n    this.timeOut = null;\n    this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n    this.onBoundsChanged = this.onBoundsChanged.bind(this);\n    this.onMouseDown = this.onMouseDown.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onMouseOver = this.onMouseOver.bind(this);\n    this.onMouseOut = this.onMouseOut.bind(this);\n    this.onAdd = this.onAdd.bind(this);\n    this.onRemove = this.onRemove.bind(this);\n    this.draw = this.draw.bind(this);\n    this.hide = this.hide.bind(this);\n    this.show = this.show.bind(this);\n    this.useStyle = this.useStyle.bind(this);\n    this.setCenter = this.setCenter.bind(this);\n    this.getPosFromLatLng = this.getPosFromLatLng.bind(this);\n  }\n  ClusterIcon.prototype.onBoundsChanged = function () {\n    this.cDraggingMapByCluster = this.cMouseDownInCluster;\n  };\n  ClusterIcon.prototype.onMouseDown = function () {\n    this.cMouseDownInCluster = true;\n    this.cDraggingMapByCluster = false;\n  };\n  ClusterIcon.prototype.onClick = function (event) {\n    this.cMouseDownInCluster = false;\n    if (!this.cDraggingMapByCluster) {\n      var markerClusterer_1 = this.cluster.getClusterer();\n      /**\n       * This event is fired when a cluster marker is clicked.\n       * @name MarkerClusterer#click\n       * @param {Cluster} c The cluster that was clicked.\n       * @event\n       */\n      google.maps.event.trigger(markerClusterer_1, 'click', this.cluster);\n      google.maps.event.trigger(markerClusterer_1, 'clusterclick', this.cluster); // deprecated name\n      // The default click handler follows. Disable it by setting\n      // the zoomOnClick property to false.\n      if (markerClusterer_1.getZoomOnClick()) {\n        // Zoom into the cluster.\n        var maxZoom_1 = markerClusterer_1.getMaxZoom();\n        var bounds_1 = this.cluster.getBounds();\n        var map = markerClusterer_1.getMap();\n        if (map !== null && 'fitBounds' in map) {\n          map.fitBounds(bounds_1);\n        }\n        // There is a fix for Issue 170 here:\n        this.timeOut = window.setTimeout(function () {\n          var map = markerClusterer_1.getMap();\n          if (map !== null) {\n            if ('fitBounds' in map) {\n              map.fitBounds(bounds_1);\n            }\n            var zoom = map.getZoom() || 0;\n            // Don't zoom beyond the max zoom level\n            if (maxZoom_1 !== null && zoom > maxZoom_1) {\n              map.setZoom(maxZoom_1 + 1);\n            }\n          }\n        }, 100);\n      }\n      // Prevent event propagation to the map:\n      event.cancelBubble = true;\n      if (event.stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  };\n  ClusterIcon.prototype.onMouseOver = function () {\n    /**\n     * This event is fired when the mouse moves over a cluster marker.\n     * @name MarkerClusterer#mouseover\n     * @param {Cluster} c The cluster that the mouse moved over.\n     * @event\n     */\n    google.maps.event.trigger(this.cluster.getClusterer(), 'mouseover', this.cluster);\n  };\n  ClusterIcon.prototype.onMouseOut = function () {\n    /**\n     * This event is fired when the mouse moves out of a cluster marker.\n     * @name MarkerClusterer#mouseout\n     * @param {Cluster} c The cluster that the mouse moved out of.\n     * @event\n     */\n    google.maps.event.trigger(this.cluster.getClusterer(), 'mouseout', this.cluster);\n  };\n  ClusterIcon.prototype.onAdd = function () {\n    var _a;\n    this.div = document.createElement('div');\n    this.div.className = this.className;\n    if (this.visible) {\n      this.show();\n    }\n    (_a = this.getPanes()) === null || _a === void 0 ? void 0 : _a.overlayMouseTarget.appendChild(this.div);\n    var map = this.getMap();\n    if (map !== null) {\n      // Fix for Issue 157\n      this.boundsChangedListener = google.maps.event.addListener(map, 'bounds_changed', this.onBoundsChanged);\n      this.div.addEventListener('mousedown', this.onMouseDown);\n      this.div.addEventListener('click', this.onClick);\n      this.div.addEventListener('mouseover', this.onMouseOver);\n      this.div.addEventListener('mouseout', this.onMouseOut);\n    }\n  };\n  ClusterIcon.prototype.onRemove = function () {\n    if (this.div && this.div.parentNode) {\n      this.hide();\n      if (this.boundsChangedListener !== null) {\n        google.maps.event.removeListener(this.boundsChangedListener);\n      }\n      this.div.removeEventListener('mousedown', this.onMouseDown);\n      this.div.removeEventListener('click', this.onClick);\n      this.div.removeEventListener('mouseover', this.onMouseOver);\n      this.div.removeEventListener('mouseout', this.onMouseOut);\n      this.div.parentNode.removeChild(this.div);\n      if (this.timeOut !== null) {\n        window.clearTimeout(this.timeOut);\n        this.timeOut = null;\n      }\n      this.div = null;\n    }\n  };\n  ClusterIcon.prototype.draw = function () {\n    if (this.visible && this.div !== null && this.center) {\n      var pos = this.getPosFromLatLng(this.center);\n      this.div.style.top = pos !== null ? \"\".concat(pos.y, \"px\") : '0';\n      this.div.style.left = pos !== null ? \"\".concat(pos.x, \"px\") : '0';\n    }\n  };\n  ClusterIcon.prototype.hide = function () {\n    if (this.div) {\n      this.div.style.display = 'none';\n    }\n    this.visible = false;\n  };\n  ClusterIcon.prototype.show = function () {\n    var _a, _b, _c, _d, _e, _f;\n    if (this.div && this.center) {\n      var divTitle = this.sums === null || typeof this.sums.title === 'undefined' || this.sums.title === '' ? this.cluster.getClusterer().getTitle() : this.sums.title;\n      // NOTE: values must be specified in px units\n      var bp = this.backgroundPosition.split(' ');\n      var spriteH = parseInt(((_a = bp[0]) === null || _a === void 0 ? void 0 : _a.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n      var spriteV = parseInt(((_b = bp[1]) === null || _b === void 0 ? void 0 : _b.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n      var pos = this.getPosFromLatLng(this.center);\n      this.div.className = this.className;\n      this.div.setAttribute('style', \"cursor: pointer; position: absolute; top: \".concat(pos !== null ? \"\".concat(pos.y, \"px\") : '0', \"; left: \").concat(pos !== null ? \"\".concat(pos.x, \"px\") : '0', \"; width: \").concat(this.width, \"px; height: \").concat(this.height, \"px; \"));\n      var img = document.createElement('img');\n      img.alt = divTitle;\n      img.src = this.url;\n      img.width = this.width;\n      img.height = this.height;\n      img.setAttribute('style', \"position: absolute; top: \".concat(spriteV, \"px; left: \").concat(spriteH, \"px\"));\n      if (!this.cluster.getClusterer().enableRetinaIcons) {\n        img.style.clip = \"rect(-\".concat(spriteV, \"px, -\").concat(spriteH + this.width, \"px, -\").concat(spriteV + this.height, \", -\").concat(spriteH, \")\");\n      }\n      var textElm = document.createElement('div');\n      textElm.setAttribute('style', \"position: absolute; top: \".concat(this.anchorText[0], \"px; left: \").concat(this.anchorText[1], \"px; color: \").concat(this.textColor, \"; font-size: \").concat(this.textSize, \"px; font-family: \").concat(this.fontFamily, \"; font-weight: \").concat(this.fontWeight, \"; fontStyle: \").concat(this.fontStyle, \"; text-decoration: \").concat(this.textDecoration, \"; text-align: center; width: \").concat(this.width, \"px; line-height: \").concat(this.height, \"px\"));\n      if ((_c = this.sums) === null || _c === void 0 ? void 0 : _c.text) textElm.innerText = \"\".concat((_d = this.sums) === null || _d === void 0 ? void 0 : _d.text);\n      if ((_e = this.sums) === null || _e === void 0 ? void 0 : _e.html) textElm.innerHTML = \"\".concat((_f = this.sums) === null || _f === void 0 ? void 0 : _f.html);\n      this.div.innerHTML = '';\n      this.div.appendChild(img);\n      this.div.appendChild(textElm);\n      this.div.title = divTitle;\n      this.div.style.display = '';\n    }\n    this.visible = true;\n  };\n  ClusterIcon.prototype.useStyle = function (sums) {\n    this.sums = sums;\n    var styles = this.cluster.getClusterer().getStyles();\n    var style = styles[Math.min(styles.length - 1, Math.max(0, sums.index - 1))];\n    if (style) {\n      this.url = style.url;\n      this.height = style.height;\n      this.width = style.width;\n      if (style.className) {\n        this.className = \"\".concat(this.clusterClassName, \" \").concat(style.className);\n      }\n      this.anchorText = style.anchorText || [0, 0];\n      this.anchorIcon = style.anchorIcon || [this.height / 2, this.width / 2];\n      this.textColor = style.textColor || 'black';\n      this.textSize = style.textSize || 11;\n      this.textDecoration = style.textDecoration || 'none';\n      this.fontWeight = style.fontWeight || 'bold';\n      this.fontStyle = style.fontStyle || 'normal';\n      this.fontFamily = style.fontFamily || 'Arial,sans-serif';\n      this.backgroundPosition = style.backgroundPosition || '0 0';\n    }\n  };\n  ClusterIcon.prototype.setCenter = function (center) {\n    this.center = center;\n  };\n  ClusterIcon.prototype.getPosFromLatLng = function (latlng) {\n    var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n    if (pos !== null) {\n      pos.x -= this.anchorIcon[1];\n      pos.y -= this.anchorIcon[0];\n    }\n    return pos;\n  };\n  return ClusterIcon;\n}();\n\n/* global google */\nvar Cluster$1 = /** @class */function () {\n  function Cluster(markerClusterer) {\n    this.markerClusterer = markerClusterer;\n    this.map = this.markerClusterer.getMap();\n    this.gridSize = this.markerClusterer.getGridSize();\n    this.minClusterSize = this.markerClusterer.getMinimumClusterSize();\n    this.averageCenter = this.markerClusterer.getAverageCenter();\n    this.markers = [];\n    this.center = undefined;\n    this.bounds = null;\n    this.clusterIcon = new ClusterIcon(this, this.markerClusterer.getStyles());\n    this.getSize = this.getSize.bind(this);\n    this.getMarkers = this.getMarkers.bind(this);\n    this.getCenter = this.getCenter.bind(this);\n    this.getMap = this.getMap.bind(this);\n    this.getClusterer = this.getClusterer.bind(this);\n    this.getBounds = this.getBounds.bind(this);\n    this.remove = this.remove.bind(this);\n    this.addMarker = this.addMarker.bind(this);\n    this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this);\n    this.calculateBounds = this.calculateBounds.bind(this);\n    this.updateIcon = this.updateIcon.bind(this);\n    this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);\n  }\n  Cluster.prototype.getSize = function () {\n    return this.markers.length;\n  };\n  Cluster.prototype.getMarkers = function () {\n    return this.markers;\n  };\n  Cluster.prototype.getCenter = function () {\n    return this.center;\n  };\n  Cluster.prototype.getMap = function () {\n    return this.map;\n  };\n  Cluster.prototype.getClusterer = function () {\n    return this.markerClusterer;\n  };\n  Cluster.prototype.getBounds = function () {\n    var bounds = new google.maps.LatLngBounds(this.center, this.center);\n    var markers = this.getMarkers();\n    for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n      var marker = markers_1[_i];\n      var position = marker.getPosition();\n      if (position) {\n        bounds.extend(position);\n      }\n    }\n    return bounds;\n  };\n  Cluster.prototype.remove = function () {\n    this.clusterIcon.setMap(null);\n    this.markers = [];\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    delete this.markers;\n  };\n  Cluster.prototype.addMarker = function (marker) {\n    var _a;\n    if (this.isMarkerAlreadyAdded(marker)) {\n      return false;\n    }\n    if (!this.center) {\n      var position = marker.getPosition();\n      if (position) {\n        this.center = position;\n        this.calculateBounds();\n      }\n    } else {\n      if (this.averageCenter) {\n        var position = marker.getPosition();\n        if (position) {\n          var length_1 = this.markers.length + 1;\n          this.center = new google.maps.LatLng((this.center.lat() * (length_1 - 1) + position.lat()) / length_1, (this.center.lng() * (length_1 - 1) + position.lng()) / length_1);\n          this.calculateBounds();\n        }\n      }\n    }\n    marker.isAdded = true;\n    this.markers.push(marker);\n    var mCount = this.markers.length;\n    var maxZoom = this.markerClusterer.getMaxZoom();\n    var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n    if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n      // Zoomed in past max zoom, so show the marker.\n      if (marker.getMap() !== this.map) {\n        marker.setMap(this.map);\n      }\n    } else if (mCount < this.minClusterSize) {\n      // Min cluster size not reached so show the marker.\n      if (marker.getMap() !== this.map) {\n        marker.setMap(this.map);\n      }\n    } else if (mCount === this.minClusterSize) {\n      // Hide the markers that were showing.\n      for (var _i = 0, _b = this.markers; _i < _b.length; _i++) {\n        var markerElement = _b[_i];\n        markerElement.setMap(null);\n      }\n    } else {\n      marker.setMap(null);\n    }\n    return true;\n  };\n  Cluster.prototype.isMarkerInClusterBounds = function (marker) {\n    if (this.bounds !== null) {\n      var position = marker.getPosition();\n      if (position) {\n        return this.bounds.contains(position);\n      }\n    }\n    return false;\n  };\n  Cluster.prototype.calculateBounds = function () {\n    this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));\n  };\n  Cluster.prototype.updateIcon = function () {\n    var _a;\n    var mCount = this.markers.length;\n    var maxZoom = this.markerClusterer.getMaxZoom();\n    var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n    if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n      this.clusterIcon.hide();\n      return;\n    }\n    if (mCount < this.minClusterSize) {\n      // Min cluster size not yet reached.\n      this.clusterIcon.hide();\n      return;\n    }\n    if (this.center) {\n      this.clusterIcon.setCenter(this.center);\n    }\n    this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length));\n    this.clusterIcon.show();\n  };\n  Cluster.prototype.isMarkerAlreadyAdded = function (marker) {\n    if (this.markers.includes) {\n      return this.markers.includes(marker);\n    }\n    for (var i = 0; i < this.markers.length; i++) {\n      if (marker === this.markers[i]) {\n        return true;\n      }\n    }\n    return false;\n  };\n  return Cluster;\n}();\n\n/* global google */\n/* eslint-disable filenames/match-regex */\n/**\n * Supports up to 9007199254740991 (Number.MAX_SAFE_INTEGER) markers\n * which is not a problem as max array length is 4294967296 (2**32)\n */\nfunction CALCULATOR(markers, numStyles) {\n  var count = markers.length;\n  var numberOfDigits = count.toString().length;\n  var index = Math.min(numberOfDigits, numStyles);\n  return {\n    text: count.toString(),\n    index: index,\n    title: ''\n  };\n}\nvar BATCH_SIZE = 2000;\nvar BATCH_SIZE_IE = 500;\nvar IMAGE_PATH = 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m';\nvar IMAGE_EXTENSION = 'png';\nvar IMAGE_SIZES = [53, 56, 66, 78, 90];\nvar CLUSTERER_CLASS = 'cluster';\nvar Clusterer = /** @class */function () {\n  function Clusterer(map, optMarkers, optOptions) {\n    if (optMarkers === void 0) {\n      optMarkers = [];\n    }\n    if (optOptions === void 0) {\n      optOptions = {};\n    }\n    this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this);\n    this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this);\n    this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this);\n    this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this);\n    this.addToClosestCluster = this.addToClosestCluster.bind(this);\n    this.getImageExtension = this.getImageExtension.bind(this);\n    this.setImageExtension = this.setImageExtension.bind(this);\n    this.getExtendedBounds = this.getExtendedBounds.bind(this);\n    this.getAverageCenter = this.getAverageCenter.bind(this);\n    this.setAverageCenter = this.setAverageCenter.bind(this);\n    this.getTotalClusters = this.getTotalClusters.bind(this);\n    this.fitMapToMarkers = this.fitMapToMarkers.bind(this);\n    this.getIgnoreHidden = this.getIgnoreHidden.bind(this);\n    this.setIgnoreHidden = this.setIgnoreHidden.bind(this);\n    this.getClusterClass = this.getClusterClass.bind(this);\n    this.setClusterClass = this.setClusterClass.bind(this);\n    this.getTotalMarkers = this.getTotalMarkers.bind(this);\n    this.getZoomOnClick = this.getZoomOnClick.bind(this);\n    this.setZoomOnClick = this.setZoomOnClick.bind(this);\n    this.getBatchSizeIE = this.getBatchSizeIE.bind(this);\n    this.setBatchSizeIE = this.setBatchSizeIE.bind(this);\n    this.createClusters = this.createClusters.bind(this);\n    this.onZoomChanged = this.onZoomChanged.bind(this);\n    this.getImageSizes = this.getImageSizes.bind(this);\n    this.setImageSizes = this.setImageSizes.bind(this);\n    this.getCalculator = this.getCalculator.bind(this);\n    this.setCalculator = this.setCalculator.bind(this);\n    this.removeMarkers = this.removeMarkers.bind(this);\n    this.resetViewport = this.resetViewport.bind(this);\n    this.getImagePath = this.getImagePath.bind(this);\n    this.setImagePath = this.setImagePath.bind(this);\n    this.pushMarkerTo = this.pushMarkerTo.bind(this);\n    this.removeMarker = this.removeMarker.bind(this);\n    this.clearMarkers = this.clearMarkers.bind(this);\n    this.setupStyles = this.setupStyles.bind(this);\n    this.getGridSize = this.getGridSize.bind(this);\n    this.setGridSize = this.setGridSize.bind(this);\n    this.getClusters = this.getClusters.bind(this);\n    this.getMaxZoom = this.getMaxZoom.bind(this);\n    this.setMaxZoom = this.setMaxZoom.bind(this);\n    this.getMarkers = this.getMarkers.bind(this);\n    this.addMarkers = this.addMarkers.bind(this);\n    this.getStyles = this.getStyles.bind(this);\n    this.setStyles = this.setStyles.bind(this);\n    this.addMarker = this.addMarker.bind(this);\n    this.onRemove = this.onRemove.bind(this);\n    this.getTitle = this.getTitle.bind(this);\n    this.setTitle = this.setTitle.bind(this);\n    this.repaint = this.repaint.bind(this);\n    this.onIdle = this.onIdle.bind(this);\n    this.redraw = this.redraw.bind(this);\n    this.onAdd = this.onAdd.bind(this);\n    this.draw = this.draw.bind(this);\n    this.extend = this.extend.bind(this);\n    this.extend(Clusterer, google.maps.OverlayView);\n    this.markers = [];\n    this.clusters = [];\n    this.listeners = [];\n    this.activeMap = null;\n    this.ready = false;\n    this.gridSize = optOptions.gridSize || 60;\n    this.minClusterSize = optOptions.minimumClusterSize || 2;\n    this.maxZoom = optOptions.maxZoom || null;\n    this.styles = optOptions.styles || [];\n    this.title = optOptions.title || '';\n    this.zoomOnClick = true;\n    if (optOptions.zoomOnClick !== undefined) {\n      this.zoomOnClick = optOptions.zoomOnClick;\n    }\n    this.averageCenter = false;\n    if (optOptions.averageCenter !== undefined) {\n      this.averageCenter = optOptions.averageCenter;\n    }\n    this.ignoreHidden = false;\n    if (optOptions.ignoreHidden !== undefined) {\n      this.ignoreHidden = optOptions.ignoreHidden;\n    }\n    this.enableRetinaIcons = false;\n    if (optOptions.enableRetinaIcons !== undefined) {\n      this.enableRetinaIcons = optOptions.enableRetinaIcons;\n    }\n    this.imagePath = optOptions.imagePath || IMAGE_PATH;\n    this.imageExtension = optOptions.imageExtension || IMAGE_EXTENSION;\n    this.imageSizes = optOptions.imageSizes || IMAGE_SIZES;\n    this.calculator = optOptions.calculator || CALCULATOR;\n    this.batchSize = optOptions.batchSize || BATCH_SIZE;\n    this.batchSizeIE = optOptions.batchSizeIE || BATCH_SIZE_IE;\n    this.clusterClass = optOptions.clusterClass || CLUSTERER_CLASS;\n    if (navigator.userAgent.toLowerCase().indexOf('msie') !== -1) {\n      // Try to avoid IE timeout when processing a huge number of markers:\n      this.batchSize = this.batchSizeIE;\n    }\n    this.timerRefStatic = null;\n    this.setupStyles();\n    this.addMarkers(optMarkers, true);\n    this.setMap(map); // Note: this causes onAdd to be called\n  }\n  Clusterer.prototype.onZoomChanged = function () {\n    var _a, _b;\n    this.resetViewport(false);\n    // Workaround for this Google bug: when map is at level 0 and \"-\" of\n    // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n    // the map doesn't zoom out any further. In this situation, no \"idle\"\n    // event is triggered so the cluster markers that have been removed\n    // do not get redrawn. Same goes for a zoom in at maxZoom.\n    if (((_a = this.getMap()) === null || _a === void 0 ? void 0 : _a.getZoom()) === (this.get('minZoom') || 0) || ((_b = this.getMap()) === null || _b === void 0 ? void 0 : _b.getZoom()) === this.get('maxZoom')) {\n      google.maps.event.trigger(this, 'idle');\n    }\n  };\n  Clusterer.prototype.onIdle = function () {\n    this.redraw();\n  };\n  Clusterer.prototype.onAdd = function () {\n    var map = this.getMap();\n    this.activeMap = map;\n    this.ready = true;\n    this.repaint();\n    if (map !== null) {\n      // Add the map event listeners\n      this.listeners = [google.maps.event.addListener(map, 'zoom_changed', this.onZoomChanged), google.maps.event.addListener(map, 'idle', this.onIdle)];\n    }\n  };\n  Clusterer.prototype.onRemove = function () {\n    // Put all the managed markers back on the map:\n    for (var _i = 0, _a = this.markers; _i < _a.length; _i++) {\n      var marker = _a[_i];\n      if (marker.getMap() !== this.activeMap) {\n        marker.setMap(this.activeMap);\n      }\n    }\n    // Remove all clusters:\n    for (var _b = 0, _c = this.clusters; _b < _c.length; _b++) {\n      var cluster = _c[_b];\n      cluster.remove();\n    }\n    this.clusters = [];\n    // Remove map event listeners:\n    for (var _d = 0, _e = this.listeners; _d < _e.length; _d++) {\n      var listener = _e[_d];\n      google.maps.event.removeListener(listener);\n    }\n    this.listeners = [];\n    this.activeMap = null;\n    this.ready = false;\n  };\n  Clusterer.prototype.draw = function () {\n    return;\n  };\n  Clusterer.prototype.getMap = function () {\n    return null;\n  };\n  Clusterer.prototype.getPanes = function () {\n    return null;\n  };\n  Clusterer.prototype.getProjection = function () {\n    return {\n      fromContainerPixelToLatLng: function fromContainerPixelToLatLng() {\n        return null;\n      },\n      fromDivPixelToLatLng: function fromDivPixelToLatLng() {\n        return null;\n      },\n      fromLatLngToContainerPixel: function fromLatLngToContainerPixel() {\n        return null;\n      },\n      fromLatLngToDivPixel: function fromLatLngToDivPixel() {\n        return null;\n      },\n      getVisibleRegion: function getVisibleRegion() {\n        return null;\n      },\n      getWorldWidth: function getWorldWidth() {\n        return 0;\n      }\n    };\n  };\n  Clusterer.prototype.setMap = function () {\n    return;\n  };\n  Clusterer.prototype.addListener = function () {\n    return {\n      remove: function remove() {\n        return;\n      }\n    };\n  };\n  Clusterer.prototype.bindTo = function () {\n    return;\n  };\n  Clusterer.prototype.get = function () {\n    return;\n  };\n  Clusterer.prototype.notify = function () {\n    return;\n  };\n  Clusterer.prototype.set = function () {\n    return;\n  };\n  Clusterer.prototype.setValues = function () {\n    return;\n  };\n  Clusterer.prototype.unbind = function () {\n    return;\n  };\n  Clusterer.prototype.unbindAll = function () {\n    return;\n  };\n  Clusterer.prototype.setupStyles = function () {\n    if (this.styles.length > 0) {\n      return;\n    }\n    for (var i = 0; i < this.imageSizes.length; i++) {\n      this.styles.push({\n        url: \"\".concat(this.imagePath + (i + 1), \".\").concat(this.imageExtension),\n        height: this.imageSizes[i] || 0,\n        width: this.imageSizes[i] || 0\n      });\n    }\n  };\n  Clusterer.prototype.fitMapToMarkers = function () {\n    var markers = this.getMarkers();\n    var bounds = new google.maps.LatLngBounds();\n    for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n      var marker = markers_1[_i];\n      var position = marker.getPosition();\n      if (position) {\n        bounds.extend(position);\n      }\n    }\n    var map = this.getMap();\n    if (map !== null && 'fitBounds' in map) {\n      map.fitBounds(bounds);\n    }\n  };\n  Clusterer.prototype.getGridSize = function () {\n    return this.gridSize;\n  };\n  Clusterer.prototype.setGridSize = function (gridSize) {\n    this.gridSize = gridSize;\n  };\n  Clusterer.prototype.getMinimumClusterSize = function () {\n    return this.minClusterSize;\n  };\n  Clusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n    this.minClusterSize = minimumClusterSize;\n  };\n  Clusterer.prototype.getMaxZoom = function () {\n    return this.maxZoom;\n  };\n  Clusterer.prototype.setMaxZoom = function (maxZoom) {\n    this.maxZoom = maxZoom;\n  };\n  Clusterer.prototype.getStyles = function () {\n    return this.styles;\n  };\n  Clusterer.prototype.setStyles = function (styles) {\n    this.styles = styles;\n  };\n  Clusterer.prototype.getTitle = function () {\n    return this.title;\n  };\n  Clusterer.prototype.setTitle = function (title) {\n    this.title = title;\n  };\n  Clusterer.prototype.getZoomOnClick = function () {\n    return this.zoomOnClick;\n  };\n  Clusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n    this.zoomOnClick = zoomOnClick;\n  };\n  Clusterer.prototype.getAverageCenter = function () {\n    return this.averageCenter;\n  };\n  Clusterer.prototype.setAverageCenter = function (averageCenter) {\n    this.averageCenter = averageCenter;\n  };\n  Clusterer.prototype.getIgnoreHidden = function () {\n    return this.ignoreHidden;\n  };\n  Clusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n    this.ignoreHidden = ignoreHidden;\n  };\n  Clusterer.prototype.getEnableRetinaIcons = function () {\n    return this.enableRetinaIcons;\n  };\n  Clusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n    this.enableRetinaIcons = enableRetinaIcons;\n  };\n  Clusterer.prototype.getImageExtension = function () {\n    return this.imageExtension;\n  };\n  Clusterer.prototype.setImageExtension = function (imageExtension) {\n    this.imageExtension = imageExtension;\n  };\n  Clusterer.prototype.getImagePath = function () {\n    return this.imagePath;\n  };\n  Clusterer.prototype.setImagePath = function (imagePath) {\n    this.imagePath = imagePath;\n  };\n  Clusterer.prototype.getImageSizes = function () {\n    return this.imageSizes;\n  };\n  Clusterer.prototype.setImageSizes = function (imageSizes) {\n    this.imageSizes = imageSizes;\n  };\n  Clusterer.prototype.getCalculator = function () {\n    return this.calculator;\n  };\n  Clusterer.prototype.setCalculator = function (calculator) {\n    this.calculator = calculator;\n  };\n  Clusterer.prototype.getBatchSizeIE = function () {\n    return this.batchSizeIE;\n  };\n  Clusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n    this.batchSizeIE = batchSizeIE;\n  };\n  Clusterer.prototype.getClusterClass = function () {\n    return this.clusterClass;\n  };\n  Clusterer.prototype.setClusterClass = function (clusterClass) {\n    this.clusterClass = clusterClass;\n  };\n  Clusterer.prototype.getMarkers = function () {\n    return this.markers;\n  };\n  Clusterer.prototype.getTotalMarkers = function () {\n    return this.markers.length;\n  };\n  Clusterer.prototype.getClusters = function () {\n    return this.clusters;\n  };\n  Clusterer.prototype.getTotalClusters = function () {\n    return this.clusters.length;\n  };\n  Clusterer.prototype.addMarker = function (marker, optNoDraw) {\n    this.pushMarkerTo(marker);\n    if (!optNoDraw) {\n      this.redraw();\n    }\n  };\n  Clusterer.prototype.addMarkers = function (markers, optNoDraw) {\n    for (var key in markers) {\n      if (Object.prototype.hasOwnProperty.call(markers, key)) {\n        var marker = markers[key];\n        if (marker) {\n          this.pushMarkerTo(marker);\n        }\n      }\n    }\n    if (!optNoDraw) {\n      this.redraw();\n    }\n  };\n  Clusterer.prototype.pushMarkerTo = function (marker) {\n    var _this = this;\n    // If the marker is draggable add a listener so we can update the clusters on the dragend:\n    if (marker.getDraggable()) {\n      google.maps.event.addListener(marker, 'dragend', function () {\n        if (_this.ready) {\n          marker.isAdded = false;\n          _this.repaint();\n        }\n      });\n    }\n    marker.isAdded = false;\n    this.markers.push(marker);\n  };\n  Clusterer.prototype.removeMarker_ = function (marker) {\n    var index = -1;\n    if (this.markers.indexOf) {\n      index = this.markers.indexOf(marker);\n    } else {\n      for (var i = 0; i < this.markers.length; i++) {\n        if (marker === this.markers[i]) {\n          index = i;\n          break;\n        }\n      }\n    }\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n    return true;\n  };\n  Clusterer.prototype.removeMarker = function (marker, optNoDraw) {\n    var removed = this.removeMarker_(marker);\n    if (!optNoDraw && removed) {\n      this.repaint();\n    }\n    return removed;\n  };\n  Clusterer.prototype.removeMarkers = function (markers, optNoDraw) {\n    var removed = false;\n    for (var _i = 0, markers_2 = markers; _i < markers_2.length; _i++) {\n      var marker = markers_2[_i];\n      removed = removed || this.removeMarker_(marker);\n    }\n    if (!optNoDraw && removed) {\n      this.repaint();\n    }\n    return removed;\n  };\n  Clusterer.prototype.clearMarkers = function () {\n    this.resetViewport(true);\n    this.markers = [];\n  };\n  Clusterer.prototype.repaint = function () {\n    var oldClusters = this.clusters.slice();\n    this.clusters = [];\n    this.resetViewport(false);\n    this.redraw();\n    // Remove the old clusters.\n    // Do it in a timeout to prevent blinking effect.\n    setTimeout(function timeout() {\n      for (var _i = 0, oldClusters_1 = oldClusters; _i < oldClusters_1.length; _i++) {\n        var oldCluster = oldClusters_1[_i];\n        oldCluster.remove();\n      }\n    }, 0);\n  };\n  Clusterer.prototype.getExtendedBounds = function (bounds) {\n    var projection = this.getProjection();\n    // Convert the points to pixels and the extend out by the grid size.\n    var trPix = projection.fromLatLngToDivPixel(\n    // Turn the bounds into latlng.\n    new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()));\n    if (trPix !== null) {\n      trPix.x += this.gridSize;\n      trPix.y -= this.gridSize;\n    }\n    var blPix = projection.fromLatLngToDivPixel(\n    // Turn the bounds into latlng.\n    new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()));\n    if (blPix !== null) {\n      blPix.x -= this.gridSize;\n      blPix.y += this.gridSize;\n    }\n    // Extend the bounds to contain the new bounds.\n    if (trPix !== null) {\n      // Convert the pixel points back to LatLng nw\n      var point1 = projection.fromDivPixelToLatLng(trPix);\n      if (point1 !== null) {\n        bounds.extend(point1);\n      }\n    }\n    if (blPix !== null) {\n      // Convert the pixel points back to LatLng sw\n      var point2 = projection.fromDivPixelToLatLng(blPix);\n      if (point2 !== null) {\n        bounds.extend(point2);\n      }\n    }\n    return bounds;\n  };\n  Clusterer.prototype.redraw = function () {\n    // Redraws all the clusters.\n    this.createClusters(0);\n  };\n  Clusterer.prototype.resetViewport = function (optHide) {\n    // Remove all the clusters\n    for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n      var cluster = _a[_i];\n      cluster.remove();\n    }\n    this.clusters = [];\n    // Reset the markers to not be added and to be removed from the map.\n    for (var _b = 0, _c = this.markers; _b < _c.length; _b++) {\n      var marker = _c[_b];\n      marker.isAdded = false;\n      if (optHide) {\n        marker.setMap(null);\n      }\n    }\n  };\n  Clusterer.prototype.distanceBetweenPoints = function (p1, p2) {\n    var R = 6371; // Radius of the Earth in km\n    var dLat = (p2.lat() - p1.lat()) * Math.PI / 180;\n    var dLon = (p2.lng() - p1.lng()) * Math.PI / 180;\n    var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));\n  };\n  Clusterer.prototype.isMarkerInBounds = function (marker, bounds) {\n    var position = marker.getPosition();\n    if (position) {\n      return bounds.contains(position);\n    }\n    return false;\n  };\n  Clusterer.prototype.addToClosestCluster = function (marker) {\n    var cluster;\n    var distance = 40000; // Some large number\n    var clusterToAddTo = null;\n    for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n      var clusterElement = _a[_i];\n      cluster = clusterElement;\n      var center = cluster.getCenter();\n      var position = marker.getPosition();\n      if (center && position) {\n        var d = this.distanceBetweenPoints(center, position);\n        if (d < distance) {\n          distance = d;\n          clusterToAddTo = cluster;\n        }\n      }\n    }\n    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n      clusterToAddTo.addMarker(marker);\n    } else {\n      cluster = new Cluster$1(this);\n      cluster.addMarker(marker);\n      this.clusters.push(cluster);\n    }\n  };\n  Clusterer.prototype.createClusters = function (iFirst) {\n    var _this = this;\n    if (!this.ready) {\n      return;\n    }\n    // Cancel previous batch processing if we're working on the first batch:\n    if (iFirst === 0) {\n      /**\n       * This event is fired when the <code>Clusterer</code> begins\n       *  clustering markers.\n       * @name Clusterer#clusteringbegin\n       * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n       * @event\n       */\n      google.maps.event.trigger(this, 'clusteringbegin', this);\n      if (this.timerRefStatic !== null) {\n        window.clearTimeout(this.timerRefStatic);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        delete this.timerRefStatic;\n      }\n    }\n    var map = this.getMap();\n    var bounds = map !== null && 'getBounds' in map ? map.getBounds() : null;\n    var zoom = (map === null || map === void 0 ? void 0 : map.getZoom()) || 0;\n    // Get our current map view bounds.\n    // Create a new bounds object so we don't affect the map.\n    //\n    // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n    var mapBounds = zoom > 3 ? new google.maps.LatLngBounds(bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest(), bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n    var extendedMapBounds = this.getExtendedBounds(mapBounds);\n    var iLast = Math.min(iFirst + this.batchSize, this.markers.length);\n    for (var i = iFirst; i < iLast; i++) {\n      var marker = this.markers[i];\n      if (marker && !marker.isAdded && this.isMarkerInBounds(marker, extendedMapBounds) && (!this.ignoreHidden || this.ignoreHidden && marker.getVisible())) {\n        this.addToClosestCluster(marker);\n      }\n    }\n    if (iLast < this.markers.length) {\n      this.timerRefStatic = window.setTimeout(function () {\n        _this.createClusters(iLast);\n      }, 0);\n    } else {\n      this.timerRefStatic = null;\n      /**\n       * This event is fired when the <code>Clusterer</code> stops\n       *  clustering markers.\n       * @name Clusterer#clusteringend\n       * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n       * @event\n       */\n      google.maps.event.trigger(this, 'clusteringend', this);\n      for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n        var cluster = _a[_i];\n        cluster.updateIcon();\n      }\n    }\n  };\n  Clusterer.prototype.extend = function (obj1, obj2) {\n    return function applyExtend(object) {\n      for (var property in object.prototype) {\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        var prop = property;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.prototype[prop] = object.prototype[prop];\n      }\n      return this;\n    }.apply(obj1, [obj2]);\n  };\n  return Clusterer;\n}();\n\nfunction ownKeys$c(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$c(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$c(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$c(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$e = {\n  onClick: 'click',\n  onClusteringBegin: 'clusteringbegin',\n  onClusteringEnd: 'clusteringend',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover'\n};\nvar updaterMap$e = {\n  averageCenter(instance, averageCenter) {\n    instance.setAverageCenter(averageCenter);\n  },\n  batchSizeIE(instance, batchSizeIE) {\n    instance.setBatchSizeIE(batchSizeIE);\n  },\n  calculator(instance, calculator) {\n    instance.setCalculator(calculator);\n  },\n  clusterClass(instance, clusterClass) {\n    instance.setClusterClass(clusterClass);\n  },\n  enableRetinaIcons(instance, enableRetinaIcons) {\n    instance.setEnableRetinaIcons(enableRetinaIcons);\n  },\n  gridSize(instance, gridSize) {\n    instance.setGridSize(gridSize);\n  },\n  ignoreHidden(instance, ignoreHidden) {\n    instance.setIgnoreHidden(ignoreHidden);\n  },\n  imageExtension(instance, imageExtension) {\n    instance.setImageExtension(imageExtension);\n  },\n  imagePath(instance, imagePath) {\n    instance.setImagePath(imagePath);\n  },\n  imageSizes(instance, imageSizes) {\n    instance.setImageSizes(imageSizes);\n  },\n  maxZoom(instance, maxZoom) {\n    instance.setMaxZoom(maxZoom);\n  },\n  minimumClusterSize(instance, minimumClusterSize) {\n    instance.setMinimumClusterSize(minimumClusterSize);\n  },\n  styles(instance, styles) {\n    instance.setStyles(styles);\n  },\n  title(instance, title) {\n    instance.setTitle(title);\n  },\n  zoomOnClick(instance, zoomOnClick) {\n    instance.setZoomOnClick(zoomOnClick);\n  }\n};\nvar defaultOptions$4 = {};\nfunction MarkerClustererFunctional(props) {\n  var {\n    children,\n    options,\n    averageCenter,\n    batchSizeIE,\n    calculator,\n    clusterClass,\n    enableRetinaIcons,\n    gridSize,\n    ignoreHidden,\n    imageExtension,\n    imagePath,\n    imageSizes,\n    maxZoom,\n    minimumClusterSize,\n    styles,\n    title,\n    zoomOnClick,\n    onClick,\n    onClusteringBegin,\n    onClusteringEnd,\n    onMouseOver,\n    onMouseOut,\n    onLoad,\n    onUnmount\n  } = props;\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clusteringBeginListener, setClusteringBeginListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clusteringEndListener, setClusteringEndListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, eventMap$e.onMouseOut, onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, eventMap$e.onMouseOver, onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, eventMap$e.onClick, onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClusteringBegin) {\n      if (clusteringBeginListener !== null) {\n        google.maps.event.removeListener(clusteringBeginListener);\n      }\n      setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringBegin, onClusteringBegin));\n    }\n  }, [onClusteringBegin]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClusteringEnd) {\n      if (clusteringEndListener !== null) {\n        google.maps.event.removeListener(clusteringEndListener);\n      }\n      setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringEnd, onClusteringEnd));\n    }\n  }, [onClusteringEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof averageCenter !== 'undefined' && instance !== null) {\n      updaterMap$e.averageCenter(instance, averageCenter);\n    }\n  }, [instance, averageCenter]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof batchSizeIE !== 'undefined' && instance !== null) {\n      updaterMap$e.batchSizeIE(instance, batchSizeIE);\n    }\n  }, [instance, batchSizeIE]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof calculator !== 'undefined' && instance !== null) {\n      updaterMap$e.calculator(instance, calculator);\n    }\n  }, [instance, calculator]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof clusterClass !== 'undefined' && instance !== null) {\n      updaterMap$e.clusterClass(instance, clusterClass);\n    }\n  }, [instance, clusterClass]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof enableRetinaIcons !== 'undefined' && instance !== null) {\n      updaterMap$e.enableRetinaIcons(instance, enableRetinaIcons);\n    }\n  }, [instance, enableRetinaIcons]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof gridSize !== 'undefined' && instance !== null) {\n      updaterMap$e.gridSize(instance, gridSize);\n    }\n  }, [instance, gridSize]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof ignoreHidden !== 'undefined' && instance !== null) {\n      updaterMap$e.ignoreHidden(instance, ignoreHidden);\n    }\n  }, [instance, ignoreHidden]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof imageExtension !== 'undefined' && instance !== null) {\n      updaterMap$e.imageExtension(instance, imageExtension);\n    }\n  }, [instance, imageExtension]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof imagePath !== 'undefined' && instance !== null) {\n      updaterMap$e.imagePath(instance, imagePath);\n    }\n  }, [instance, imagePath]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof imageSizes !== 'undefined' && instance !== null) {\n      updaterMap$e.imageSizes(instance, imageSizes);\n    }\n  }, [instance, imageSizes]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof maxZoom !== 'undefined' && instance !== null) {\n      updaterMap$e.maxZoom(instance, maxZoom);\n    }\n  }, [instance, maxZoom]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof minimumClusterSize !== 'undefined' && instance !== null) {\n      updaterMap$e.minimumClusterSize(instance, minimumClusterSize);\n    }\n  }, [instance, minimumClusterSize]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof styles !== 'undefined' && instance !== null) {\n      updaterMap$e.styles(instance, styles);\n    }\n  }, [instance, styles]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof title !== 'undefined' && instance !== null) {\n      updaterMap$e.title(instance, title);\n    }\n  }, [instance, title]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof zoomOnClick !== 'undefined' && instance !== null) {\n      updaterMap$e.zoomOnClick(instance, zoomOnClick);\n    }\n  }, [instance, zoomOnClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!map) return;\n    var clustererOptions = _objectSpread$c({}, options || defaultOptions$4);\n    var clusterer = new Clusterer(map, [], clustererOptions);\n    if (averageCenter) {\n      updaterMap$e.averageCenter(clusterer, averageCenter);\n    }\n    if (batchSizeIE) {\n      updaterMap$e.batchSizeIE(clusterer, batchSizeIE);\n    }\n    if (calculator) {\n      updaterMap$e.calculator(clusterer, calculator);\n    }\n    if (clusterClass) {\n      updaterMap$e.clusterClass(clusterer, clusterClass);\n    }\n    if (enableRetinaIcons) {\n      updaterMap$e.enableRetinaIcons(clusterer, enableRetinaIcons);\n    }\n    if (gridSize) {\n      updaterMap$e.gridSize(clusterer, gridSize);\n    }\n    if (ignoreHidden) {\n      updaterMap$e.ignoreHidden(clusterer, ignoreHidden);\n    }\n    if (imageExtension) {\n      updaterMap$e.imageExtension(clusterer, imageExtension);\n    }\n    if (imagePath) {\n      updaterMap$e.imagePath(clusterer, imagePath);\n    }\n    if (imageSizes) {\n      updaterMap$e.imageSizes(clusterer, imageSizes);\n    }\n    if (maxZoom) {\n      updaterMap$e.maxZoom(clusterer, maxZoom);\n    }\n    if (minimumClusterSize) {\n      updaterMap$e.minimumClusterSize(clusterer, minimumClusterSize);\n    }\n    if (styles) {\n      updaterMap$e.styles(clusterer, styles);\n    }\n    if (title) {\n      updaterMap$e.title(clusterer, title);\n    }\n    if (zoomOnClick) {\n      updaterMap$e.zoomOnClick(clusterer, zoomOnClick);\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOut, onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOver, onMouseOver));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(clusterer, eventMap$e.onClick, onClick));\n    }\n    if (onClusteringBegin) {\n      setClusteringBeginListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringBegin, onClusteringBegin));\n    }\n    if (onClusteringEnd) {\n      setClusteringEndListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringEnd, onClusteringEnd));\n    }\n    setInstance(clusterer);\n    if (onLoad) {\n      onLoad(clusterer);\n    }\n    return () => {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (clusteringBeginListener !== null) {\n        google.maps.event.removeListener(clusteringBeginListener);\n      }\n      if (clusteringEndListener !== null) {\n        google.maps.event.removeListener(clusteringEndListener);\n      }\n      if (onUnmount) {\n        onUnmount(clusterer);\n      }\n    };\n  }, []);\n  return instance !== null ? children(instance) || null : null;\n}\nvar MarkerClustererF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerClustererFunctional);\nclass ClustererComponent extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      markerClusterer: null\n    });\n    _defineProperty(this, \"setClustererCallback\", () => {\n      if (this.state.markerClusterer !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.markerClusterer);\n      }\n    });\n  }\n  componentDidMount() {\n    if (this.context) {\n      var markerClusterer = new Clusterer(this.context, [], this.props.options);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$e,\n        eventMap: eventMap$e,\n        prevProps: {},\n        nextProps: this.props,\n        instance: markerClusterer\n      });\n      this.setState(() => {\n        return {\n          markerClusterer\n        };\n      }, this.setClustererCallback);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.markerClusterer) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$e,\n        eventMap: eventMap$e,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.markerClusterer\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.markerClusterer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.markerClusterer);\n      }\n      unregisterEvents(this.registeredEvents);\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.state.markerClusterer.setMap(null);\n    }\n  }\n  render() {\n    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;\n  }\n}\n_defineProperty(ClustererComponent, \"contextType\", MapContext);\n\n// This handler prevents an event in the InfoBox from being passed on to the map.\nfunction cancelHandler(event) {\n  event.cancelBubble = true;\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n}\nvar InfoBox = /** @class */function () {\n  function InfoBox(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.getCloseClickHandler = this.getCloseClickHandler.bind(this);\n    this.closeClickHandler = this.closeClickHandler.bind(this);\n    this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this);\n    this.addClickHandler = this.addClickHandler.bind(this);\n    this.getCloseBoxImg = this.getCloseBoxImg.bind(this);\n    this.getBoxWidths = this.getBoxWidths.bind(this);\n    this.setBoxStyle = this.setBoxStyle.bind(this);\n    this.setPosition = this.setPosition.bind(this);\n    this.getPosition = this.getPosition.bind(this);\n    this.setOptions = this.setOptions.bind(this);\n    this.setContent = this.setContent.bind(this);\n    this.setVisible = this.setVisible.bind(this);\n    this.getContent = this.getContent.bind(this);\n    this.getVisible = this.getVisible.bind(this);\n    this.setZIndex = this.setZIndex.bind(this);\n    this.getZIndex = this.getZIndex.bind(this);\n    this.onRemove = this.onRemove.bind(this);\n    this.panBox = this.panBox.bind(this);\n    this.extend = this.extend.bind(this);\n    this.close = this.close.bind(this);\n    this.draw = this.draw.bind(this);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.open = this.open.bind(this);\n    this.extend(InfoBox, google.maps.OverlayView);\n    // Standard options (in common with google.maps.InfoWindow):\n    this.content = options.content || '';\n    this.disableAutoPan = options.disableAutoPan || false;\n    this.maxWidth = options.maxWidth || 0;\n    this.pixelOffset = options.pixelOffset || new google.maps.Size(0, 0);\n    this.position = options.position || new google.maps.LatLng(0, 0);\n    this.zIndex = options.zIndex || null;\n    // Additional options (unique to InfoBox):\n    this.boxClass = options.boxClass || 'infoBox';\n    this.boxStyle = options.boxStyle || {};\n    this.closeBoxMargin = options.closeBoxMargin || '2px';\n    this.closeBoxURL = options.closeBoxURL || 'http://www.google.com/intl/en_us/mapfiles/close.gif';\n    if (options.closeBoxURL === '') {\n      this.closeBoxURL = '';\n    }\n    this.infoBoxClearance = options.infoBoxClearance || new google.maps.Size(1, 1);\n    if (typeof options.visible === 'undefined') {\n      if (typeof options.isHidden === 'undefined') {\n        options.visible = true;\n      } else {\n        options.visible = !options.isHidden;\n      }\n    }\n    this.isHidden = !options.visible;\n    this.alignBottom = options.alignBottom || false;\n    this.pane = options.pane || 'floatPane';\n    this.enableEventPropagation = options.enableEventPropagation || false;\n    this.div = null;\n    this.closeListener = null;\n    this.moveListener = null;\n    this.mapListener = null;\n    this.contextListener = null;\n    this.eventListeners = null;\n    this.fixedWidthSet = null;\n  }\n  InfoBox.prototype.createInfoBoxDiv = function () {\n    var _this = this;\n    // This handler ignores the current event in the InfoBox and conditionally prevents\n    // the event from being passed on to the map. It is used for the contextmenu event.\n    var ignoreHandler = function ignoreHandler(event) {\n      event.returnValue = false;\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n      if (!_this.enableEventPropagation) {\n        cancelHandler(event);\n      }\n    };\n    if (!this.div) {\n      this.div = document.createElement('div');\n      this.setBoxStyle();\n      if (typeof this.content === 'string') {\n        this.div.innerHTML = this.getCloseBoxImg() + this.content;\n      } else {\n        this.div.innerHTML = this.getCloseBoxImg();\n        this.div.appendChild(this.content);\n      }\n      var panes = this.getPanes();\n      if (panes !== null) {\n        panes[this.pane].appendChild(this.div); // Add the InfoBox div to the DOM\n      }\n      this.addClickHandler();\n      if (this.div.style.width) {\n        this.fixedWidthSet = true;\n      } else {\n        if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth) {\n          this.div.style.width = this.maxWidth + 'px';\n          this.fixedWidthSet = true;\n        } else {\n          // The following code is needed to overcome problems with MSIE\n          var bw = this.getBoxWidths();\n          this.div.style.width = this.div.offsetWidth - bw.left - bw.right + 'px';\n          this.fixedWidthSet = false;\n        }\n      }\n      this.panBox(this.disableAutoPan);\n      if (!this.enableEventPropagation) {\n        this.eventListeners = [];\n        // Cancel event propagation.\n        // Note: mousemove not included (to resolve Issue 152)\n        var events = ['mousedown', 'mouseover', 'mouseout', 'mouseup', 'click', 'dblclick', 'touchstart', 'touchend', 'touchmove'];\n        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n          var event_1 = events_1[_i];\n          this.eventListeners.push(google.maps.event.addListener(this.div, event_1, cancelHandler));\n        }\n        // Workaround for Google bug that causes the cursor to change to a pointer\n        // when the mouse moves over a marker underneath InfoBox.\n        this.eventListeners.push(google.maps.event.addListener(this.div, 'mouseover', function () {\n          if (_this.div) {\n            _this.div.style.cursor = 'default';\n          }\n        }));\n      }\n      this.contextListener = google.maps.event.addListener(this.div, 'contextmenu', ignoreHandler);\n      /**\n       * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.\n       * @name InfoBox#domready\n       * @event\n       */\n      google.maps.event.trigger(this, 'domready');\n    }\n  };\n  InfoBox.prototype.getCloseBoxImg = function () {\n    var img = '';\n    if (this.closeBoxURL !== '') {\n      img = '<img alt=\"\"';\n      img += ' aria-hidden=\"true\"';\n      img += \" src='\" + this.closeBoxURL + \"'\";\n      img += ' align=right'; // Do this because Opera chokes on style='float: right;'\n      img += \" style='\";\n      img += ' position: relative;'; // Required by MSIE\n      img += ' cursor: pointer;';\n      img += ' margin: ' + this.closeBoxMargin + ';';\n      img += \"'>\";\n    }\n    return img;\n  };\n  InfoBox.prototype.addClickHandler = function () {\n    this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== '' ? google.maps.event.addListener(this.div.firstChild, 'click', this.getCloseClickHandler()) : null;\n  };\n  InfoBox.prototype.closeClickHandler = function (event) {\n    // 1.0.3 fix: Always prevent propagation of a close box click to the map:\n    event.cancelBubble = true;\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    }\n    /**\n     * This event is fired when the InfoBox's close box is clicked.\n     * @name InfoBox#closeclick\n     * @event\n     */\n    google.maps.event.trigger(this, 'closeclick');\n    this.close();\n  };\n  InfoBox.prototype.getCloseClickHandler = function () {\n    return this.closeClickHandler;\n  };\n  InfoBox.prototype.panBox = function (disablePan) {\n    if (this.div && !disablePan) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      var map = this.getMap();\n      // Only pan if attached to map, not panorama\n      if (map instanceof google.maps.Map) {\n        var xOffset = 0;\n        var yOffset = 0;\n        var bounds = map.getBounds();\n        if (bounds && !bounds.contains(this.position)) {\n          // Marker not in visible area of map, so set center\n          // of map to the marker position first.\n          map.setCenter(this.position);\n        }\n        var mapDiv = map.getDiv();\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        var mapWidth = mapDiv.offsetWidth;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        var mapHeight = mapDiv.offsetHeight;\n        var iwOffsetX = this.pixelOffset.width;\n        var iwOffsetY = this.pixelOffset.height;\n        var iwWidth = this.div.offsetWidth;\n        var iwHeight = this.div.offsetHeight;\n        var padX = this.infoBoxClearance.width;\n        var padY = this.infoBoxClearance.height;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        var projection = this.getProjection();\n        var pixPosition = projection.fromLatLngToContainerPixel(this.position);\n        if (pixPosition !== null) {\n          if (pixPosition.x < -iwOffsetX + padX) {\n            xOffset = pixPosition.x + iwOffsetX - padX;\n          } else if (pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth) {\n            xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;\n          }\n          if (this.alignBottom) {\n            if (pixPosition.y < -iwOffsetY + padY + iwHeight) {\n              yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;\n            } else if (pixPosition.y + iwOffsetY + padY > mapHeight) {\n              yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;\n            }\n          } else {\n            if (pixPosition.y < -iwOffsetY + padY) {\n              yOffset = pixPosition.y + iwOffsetY - padY;\n            } else if (pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight) {\n              yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;\n            }\n          }\n        }\n        if (!(xOffset === 0 && yOffset === 0)) {\n          // Move the map to the shifted center.\n          map.panBy(xOffset, yOffset);\n        }\n      }\n    }\n  };\n  InfoBox.prototype.setBoxStyle = function () {\n    if (this.div) {\n      // Apply style values from the style sheet defined in the boxClass parameter:\n      this.div.className = this.boxClass;\n      // Clear existing inline style values:\n      this.div.style.cssText = '';\n      // Apply style values defined in the boxStyle parameter:\n      var boxStyle = this.boxStyle;\n      for (var i in boxStyle) {\n        if (Object.prototype.hasOwnProperty.call(boxStyle, i)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          this.div.style[i] = boxStyle[i];\n        }\n      }\n      // Fix for iOS disappearing InfoBox problem\n      // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad\n      this.div.style.webkitTransform = 'translateZ(0)';\n      // Fix up opacity style for benefit of MSIE\n      if (typeof this.div.style.opacity !== 'undefined' && this.div.style.opacity !== '') {\n        // See http://www.quirksmode.org/css/opacity.html\n        var opacity = parseFloat(this.div.style.opacity || '');\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.div.style.msFilter = '\"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + opacity * 100 + ')\"';\n        this.div.style.filter = 'alpha(opacity=' + opacity * 100 + ')';\n      }\n      // Apply required styles\n      this.div.style.position = 'absolute';\n      this.div.style.visibility = 'hidden';\n      if (this.zIndex !== null) {\n        this.div.style.zIndex = this.zIndex + '';\n      }\n      if (!this.div.style.overflow) {\n        this.div.style.overflow = 'auto';\n      }\n    }\n  };\n  InfoBox.prototype.getBoxWidths = function () {\n    var bw = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    if (!this.div) {\n      return bw;\n    }\n    if (document.defaultView) {\n      var ownerDocument = this.div.ownerDocument;\n      var computedStyle = ownerDocument && ownerDocument.defaultView ? ownerDocument.defaultView.getComputedStyle(this.div, '') : null;\n      if (computedStyle) {\n        // The computed styles are always in pixel units (good!)\n        bw.top = parseInt(computedStyle.borderTopWidth || '', 10) || 0;\n        bw.bottom = parseInt(computedStyle.borderBottomWidth || '', 10) || 0;\n        bw.left = parseInt(computedStyle.borderLeftWidth || '', 10) || 0;\n        bw.right = parseInt(computedStyle.borderRightWidth || '', 10) || 0;\n      }\n    } else if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    document.documentElement.currentStyle // MSIE\n    ) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      var currentStyle = this.div.currentStyle;\n      if (currentStyle) {\n        // The current styles may not be in pixel units, but assume they are (bad!)\n        bw.top = parseInt(currentStyle.borderTopWidth || '', 10) || 0;\n        bw.bottom = parseInt(currentStyle.borderBottomWidth || '', 10) || 0;\n        bw.left = parseInt(currentStyle.borderLeftWidth || '', 10) || 0;\n        bw.right = parseInt(currentStyle.borderRightWidth || '', 10) || 0;\n      }\n    }\n    return bw;\n  };\n  InfoBox.prototype.onRemove = function () {\n    if (this.div && this.div.parentNode) {\n      this.div.parentNode.removeChild(this.div);\n      this.div = null;\n    }\n  };\n  InfoBox.prototype.draw = function () {\n    this.createInfoBoxDiv();\n    if (this.div) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      var projection = this.getProjection();\n      var pixPosition = projection.fromLatLngToDivPixel(this.position);\n      if (pixPosition !== null) {\n        this.div.style.left = pixPosition.x + this.pixelOffset.width + 'px';\n        if (this.alignBottom) {\n          this.div.style.bottom = -(pixPosition.y + this.pixelOffset.height) + 'px';\n        } else {\n          this.div.style.top = pixPosition.y + this.pixelOffset.height + 'px';\n        }\n      }\n      if (this.isHidden) {\n        this.div.style.visibility = 'hidden';\n      } else {\n        this.div.style.visibility = 'visible';\n      }\n    }\n  };\n  InfoBox.prototype.setOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (typeof options.boxClass !== 'undefined') {\n      // Must be first\n      this.boxClass = options.boxClass;\n      this.setBoxStyle();\n    }\n    if (typeof options.boxStyle !== 'undefined') {\n      // Must be second\n      this.boxStyle = options.boxStyle;\n      this.setBoxStyle();\n    }\n    if (typeof options.content !== 'undefined') {\n      this.setContent(options.content);\n    }\n    if (typeof options.disableAutoPan !== 'undefined') {\n      this.disableAutoPan = options.disableAutoPan;\n    }\n    if (typeof options.maxWidth !== 'undefined') {\n      this.maxWidth = options.maxWidth;\n    }\n    if (typeof options.pixelOffset !== 'undefined') {\n      this.pixelOffset = options.pixelOffset;\n    }\n    if (typeof options.alignBottom !== 'undefined') {\n      this.alignBottom = options.alignBottom;\n    }\n    if (typeof options.position !== 'undefined') {\n      this.setPosition(options.position);\n    }\n    if (typeof options.zIndex !== 'undefined') {\n      this.setZIndex(options.zIndex);\n    }\n    if (typeof options.closeBoxMargin !== 'undefined') {\n      this.closeBoxMargin = options.closeBoxMargin;\n    }\n    if (typeof options.closeBoxURL !== 'undefined') {\n      this.closeBoxURL = options.closeBoxURL;\n    }\n    if (typeof options.infoBoxClearance !== 'undefined') {\n      this.infoBoxClearance = options.infoBoxClearance;\n    }\n    if (typeof options.isHidden !== 'undefined') {\n      this.isHidden = options.isHidden;\n    }\n    if (typeof options.visible !== 'undefined') {\n      this.isHidden = !options.visible;\n    }\n    if (typeof options.enableEventPropagation !== 'undefined') {\n      this.enableEventPropagation = options.enableEventPropagation;\n    }\n    if (this.div) {\n      this.draw();\n    }\n  };\n  InfoBox.prototype.setContent = function (content) {\n    this.content = content;\n    if (this.div) {\n      if (this.closeListener) {\n        google.maps.event.removeListener(this.closeListener);\n        this.closeListener = null;\n      }\n      // Odd code required to make things work with MSIE.\n      if (!this.fixedWidthSet) {\n        this.div.style.width = '';\n      }\n      if (typeof content === 'string') {\n        this.div.innerHTML = this.getCloseBoxImg() + content;\n      } else {\n        this.div.innerHTML = this.getCloseBoxImg();\n        this.div.appendChild(content);\n      }\n      // Perverse code required to make things work with MSIE.\n      // (Ensures the close box does, in fact, float to the right.)\n      if (!this.fixedWidthSet) {\n        this.div.style.width = this.div.offsetWidth + 'px';\n        if (typeof content === 'string') {\n          this.div.innerHTML = this.getCloseBoxImg() + content;\n        } else {\n          this.div.innerHTML = this.getCloseBoxImg();\n          this.div.appendChild(content);\n        }\n      }\n      this.addClickHandler();\n    }\n    /**\n     * This event is fired when the content of the InfoBox changes.\n     * @name InfoBox#content_changed\n     * @event\n     */\n    google.maps.event.trigger(this, 'content_changed');\n  };\n  InfoBox.prototype.setPosition = function (latLng) {\n    this.position = latLng;\n    if (this.div) {\n      this.draw();\n    }\n    /**\n     * This event is fired when the position of the InfoBox changes.\n     * @name InfoBox#position_changed\n     * @event\n     */\n    google.maps.event.trigger(this, 'position_changed');\n  };\n  InfoBox.prototype.setVisible = function (isVisible) {\n    this.isHidden = !isVisible;\n    if (this.div) {\n      this.div.style.visibility = this.isHidden ? 'hidden' : 'visible';\n    }\n  };\n  InfoBox.prototype.setZIndex = function (index) {\n    this.zIndex = index;\n    if (this.div) {\n      this.div.style.zIndex = index + '';\n    }\n    /**\n     * This event is fired when the zIndex of the InfoBox changes.\n     * @name InfoBox#zindex_changed\n     * @event\n     */\n    google.maps.event.trigger(this, 'zindex_changed');\n  };\n  InfoBox.prototype.getContent = function () {\n    return this.content;\n  };\n  InfoBox.prototype.getPosition = function () {\n    return this.position;\n  };\n  InfoBox.prototype.getZIndex = function () {\n    return this.zIndex;\n  };\n  InfoBox.prototype.getVisible = function () {\n    var map = this.getMap();\n    return typeof map === 'undefined' || map === null ? false : !this.isHidden;\n  };\n  InfoBox.prototype.show = function () {\n    this.isHidden = false;\n    if (this.div) {\n      this.div.style.visibility = 'visible';\n    }\n  };\n  InfoBox.prototype.hide = function () {\n    this.isHidden = true;\n    if (this.div) {\n      this.div.style.visibility = 'hidden';\n    }\n  };\n  InfoBox.prototype.open = function (map, anchor) {\n    var _this = this;\n    if (anchor) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.position = anchor.getPosition();\n      this.moveListener = google.maps.event.addListener(anchor, 'position_changed', function () {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        var position = anchor.getPosition();\n        _this.setPosition(position);\n      });\n      this.mapListener = google.maps.event.addListener(anchor, 'map_changed', function () {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        _this.setMap(anchor.map);\n      });\n    }\n    this.setMap(map);\n    if (this.div) {\n      this.panBox();\n    }\n  };\n  InfoBox.prototype.close = function () {\n    if (this.closeListener) {\n      google.maps.event.removeListener(this.closeListener);\n      this.closeListener = null;\n    }\n    if (this.eventListeners) {\n      for (var _i = 0, _a = this.eventListeners; _i < _a.length; _i++) {\n        var eventListener = _a[_i];\n        google.maps.event.removeListener(eventListener);\n      }\n      this.eventListeners = null;\n    }\n    if (this.moveListener) {\n      google.maps.event.removeListener(this.moveListener);\n      this.moveListener = null;\n    }\n    if (this.mapListener) {\n      google.maps.event.removeListener(this.mapListener);\n      this.mapListener = null;\n    }\n    if (this.contextListener) {\n      google.maps.event.removeListener(this.contextListener);\n      this.contextListener = null;\n    }\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.setMap(null);\n  };\n  InfoBox.prototype.extend = function (obj1, obj2) {\n    return function applyExtend(object) {\n      for (var property in object.prototype) {\n        if (!Object.prototype.hasOwnProperty.call(this, property)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          this.prototype[property] = object.prototype[property];\n        }\n      }\n      return this;\n    }.apply(obj1, [obj2]);\n  };\n  return InfoBox;\n}();\n\nvar _excluded = [\"position\"],\n  _excluded2 = [\"position\"];\nfunction ownKeys$b(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$b(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$b(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$b(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$d = {\n  onCloseClick: 'closeclick',\n  onContentChanged: 'content_changed',\n  onDomReady: 'domready',\n  onPositionChanged: 'position_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$d = {\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  position(instance, position) {\n    if (position instanceof google.maps.LatLng) {\n      instance.setPosition(position);\n    } else {\n      instance.setPosition(new google.maps.LatLng(position.lat, position.lng));\n    }\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  },\n  zIndex(instance, zIndex) {\n    instance.setZIndex(zIndex);\n  }\n};\nvar defaultOptions$3 = {};\nfunction InfoBoxFunctional(_ref) {\n  var {\n    children,\n    anchor,\n    options,\n    position,\n    zIndex,\n    onCloseClick,\n    onDomReady,\n    onContentChanged,\n    onPositionChanged,\n    onZindexChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [closeClickListener, setCloseClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [domReadyClickListener, setDomReadyClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [contentChangedClickListener, setContentChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [positionChangedClickListener, setPositionChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [zIndexChangedClickListener, setZindexChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var containerElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && instance !== null) {\n      instance.close();\n      if (anchor) {\n        instance.open(map, anchor);\n      } else if (instance.getPosition()) {\n        instance.open(map);\n      }\n    }\n  }, [map, instance, anchor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (position && instance !== null) {\n      var positionLatLng = position instanceof google.maps.LatLng ? position :\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      new google.maps.LatLng(position.lat, position.lng);\n      instance.setPosition(positionLatLng);\n    }\n  }, [position]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof zIndex === 'number' && instance !== null) {\n      instance.setZIndex(zIndex);\n    }\n  }, [zIndex]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onCloseClick) {\n      if (closeClickListener !== null) {\n        google.maps.event.removeListener(closeClickListener);\n      }\n      setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n    }\n  }, [onCloseClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDomReady) {\n      if (domReadyClickListener !== null) {\n        google.maps.event.removeListener(domReadyClickListener);\n      }\n      setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n    }\n  }, [onDomReady]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onContentChanged) {\n      if (contentChangedClickListener !== null) {\n        google.maps.event.removeListener(contentChangedClickListener);\n      }\n      setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n    }\n  }, [onContentChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onPositionChanged) {\n      if (positionChangedClickListener !== null) {\n        google.maps.event.removeListener(positionChangedClickListener);\n      }\n      setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n    }\n  }, [onPositionChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onZindexChanged) {\n      if (zIndexChangedClickListener !== null) {\n        google.maps.event.removeListener(zIndexChangedClickListener);\n      }\n      setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n    }\n  }, [onZindexChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map) {\n      var _ref2 = options || defaultOptions$3,\n        {\n          position: _position\n        } = _ref2,\n        infoBoxOptions = _objectWithoutProperties(_ref2, _excluded);\n      var positionLatLng;\n      if (_position && !(_position instanceof google.maps.LatLng)) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        positionLatLng = new google.maps.LatLng(_position.lat, _position.lng);\n      }\n      var infoBox = new InfoBox(_objectSpread$b(_objectSpread$b({}, infoBoxOptions), positionLatLng ? {\n        position: positionLatLng\n      } : {}));\n      containerElementRef.current = document.createElement('div');\n      setInstance(infoBox);\n      if (onCloseClick) {\n        setCloseClickListener(google.maps.event.addListener(infoBox, 'closeclick', onCloseClick));\n      }\n      if (onDomReady) {\n        setDomReadyClickListener(google.maps.event.addListener(infoBox, 'domready', onDomReady));\n      }\n      if (onContentChanged) {\n        setContentChangedClickListener(google.maps.event.addListener(infoBox, 'content_changed', onContentChanged));\n      }\n      if (onPositionChanged) {\n        setPositionChangedClickListener(google.maps.event.addListener(infoBox, 'position_changed', onPositionChanged));\n      }\n      if (onZindexChanged) {\n        setZindexChangedClickListener(google.maps.event.addListener(infoBox, 'zindex_changed', onZindexChanged));\n      }\n      infoBox.setContent(containerElementRef.current);\n      if (anchor) {\n        infoBox.open(map, anchor);\n      } else if (infoBox.getPosition()) {\n        infoBox.open(map);\n      } else {\n        invariant(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n      }\n      if (onLoad) {\n        onLoad(infoBox);\n      }\n    }\n    return () => {\n      if (instance !== null) {\n        if (closeClickListener) {\n          google.maps.event.removeListener(closeClickListener);\n        }\n        if (contentChangedClickListener) {\n          google.maps.event.removeListener(contentChangedClickListener);\n        }\n        if (domReadyClickListener) {\n          google.maps.event.removeListener(domReadyClickListener);\n        }\n        if (positionChangedClickListener) {\n          google.maps.event.removeListener(positionChangedClickListener);\n        }\n        if (zIndexChangedClickListener) {\n          google.maps.event.removeListener(zIndexChangedClickListener);\n        }\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.close();\n      }\n    };\n  }, []);\n  return containerElementRef.current ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children), containerElementRef.current) : null;\n}\nvar InfoBoxF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(InfoBoxFunctional);\nclass InfoBoxComponent extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"containerElement\", null);\n    _defineProperty(this, \"state\", {\n      infoBox: null\n    });\n    _defineProperty(this, \"open\", (infoBox, anchor) => {\n      if (anchor) {\n        if (this.context !== null) {\n          infoBox.open(this.context, anchor);\n        }\n      } else if (infoBox.getPosition()) {\n        if (this.context !== null) {\n          infoBox.open(this.context);\n        }\n      } else {\n        invariant(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n      }\n    });\n    _defineProperty(this, \"setInfoBoxCallback\", () => {\n      if (this.state.infoBox !== null && this.containerElement !== null) {\n        this.state.infoBox.setContent(this.containerElement);\n        this.open(this.state.infoBox, this.props.anchor);\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.infoBox);\n        }\n      }\n    });\n  }\n  componentDidMount() {\n    var _ref3 = this.props.options || {},\n      {\n        position\n      } = _ref3,\n      infoBoxOptions = _objectWithoutProperties(_ref3, _excluded2);\n    var positionLatLng;\n    if (position && !(position instanceof google.maps.LatLng)) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      positionLatLng = new google.maps.LatLng(position.lat, position.lng);\n    }\n    var infoBox = new InfoBox(_objectSpread$b(_objectSpread$b({}, infoBoxOptions), positionLatLng ? {\n      position: positionLatLng\n    } : {}));\n    this.containerElement = document.createElement('div');\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$d,\n      eventMap: eventMap$d,\n      prevProps: {},\n      nextProps: this.props,\n      instance: infoBox\n    });\n    this.setState({\n      infoBox\n    }, this.setInfoBoxCallback);\n  }\n  componentDidUpdate(prevProps) {\n    var {\n      infoBox\n    } = this.state;\n    if (infoBox !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$d,\n        eventMap: eventMap$d,\n        prevProps,\n        nextProps: this.props,\n        instance: infoBox\n      });\n    }\n  }\n  componentWillUnmount() {\n    var {\n      onUnmount\n    } = this.props;\n    var {\n      infoBox\n    } = this.state;\n    if (infoBox !== null) {\n      if (onUnmount) {\n        onUnmount(infoBox);\n      }\n      unregisterEvents(this.registeredEvents);\n      infoBox.close();\n    }\n  }\n  render() {\n    return this.containerElement ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children), this.containerElement) : null;\n  }\n}\n_defineProperty(InfoBoxComponent, \"contextType\", MapContext);\n\nvar fastDeepEqual;\nvar hasRequiredFastDeepEqual;\nfunction requireFastDeepEqual() {\n  if (hasRequiredFastDeepEqual) return fastDeepEqual;\n  hasRequiredFastDeepEqual = 1;\n\n  // do not edit .js files directly - edit src/index.jst\n\n  fastDeepEqual = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n      if (a.constructor !== b.constructor) return false;\n      var length, i, keys;\n      if (Array.isArray(a)) {\n        length = a.length;\n        if (length != b.length) return false;\n        for (i = length; i-- !== 0;) if (!equal(a[i], b[i])) return false;\n        return true;\n      }\n      if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n      if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n      keys = Object.keys(a);\n      length = keys.length;\n      if (length !== Object.keys(b).length) return false;\n      for (i = length; i-- !== 0;) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n      for (i = length; i-- !== 0;) {\n        var key = keys[i];\n        if (!equal(a[key], b[key])) return false;\n      }\n      return true;\n    }\n\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n  };\n  return fastDeepEqual;\n}\n\nvar fastDeepEqualExports = requireFastDeepEqual();\nvar equal = /*@__PURE__*/getDefaultExportFromCjs$1(fastDeepEqualExports);\n\nvar ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nvar VERSION = 1; // serialized format version\nvar HEADER_SIZE = 8;\nclass KDBush {\n  /**\n   * Creates an index from raw `ArrayBuffer` data.\n   * @param {ArrayBuffer} data\n   */\n  static from(data) {\n    if (!(data instanceof ArrayBuffer)) {\n      throw new Error('Data must be an instance of ArrayBuffer.');\n    }\n    var [magic, versionAndType] = new Uint8Array(data, 0, 2);\n    if (magic !== 0xdb) {\n      throw new Error('Data does not appear to be in a KDBush format.');\n    }\n    var version = versionAndType >> 4;\n    if (version !== VERSION) {\n      throw new Error(\"Got v\".concat(version, \" data when expected v\").concat(VERSION, \".\"));\n    }\n    var ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n    if (!ArrayType) {\n      throw new Error('Unrecognized array type.');\n    }\n    var [nodeSize] = new Uint16Array(data, 2, 1);\n    var [numItems] = new Uint32Array(data, 4, 1);\n    return new KDBush(numItems, nodeSize, ArrayType, data);\n  }\n\n  /**\n   * Creates an index that will hold a given number of items.\n   * @param {number} numItems\n   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n   * @param {ArrayBuffer} [data] (For internal use only)\n   */\n  constructor(numItems) {\n    var nodeSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;\n    var ArrayType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float64Array;\n    var data = arguments.length > 3 ? arguments[3] : undefined;\n    if (isNaN(numItems) || numItems < 0) throw new Error(\"Unpexpected numItems value: \".concat(numItems, \".\"));\n    this.numItems = +numItems;\n    this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n    this.ArrayType = ArrayType;\n    this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n    var arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n    var coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n    var idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n    var padCoords = (8 - idsByteSize % 8) % 8;\n    if (arrayTypeIndex < 0) {\n      throw new Error(\"Unexpected typed array class: \".concat(ArrayType, \".\"));\n    }\n    if (data && data instanceof ArrayBuffer) {\n      // reconstruct an index from a buffer\n      this.data = data;\n      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n      this._pos = numItems * 2;\n      this._finished = true;\n    } else {\n      // initialize a new index\n      this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n      this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n      this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n      this._pos = 0;\n      this._finished = false;\n\n      // set header\n      new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n      new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n      new Uint32Array(this.data, 4, 1)[0] = numItems;\n    }\n  }\n\n  /**\n   * Add a point to the index.\n   * @param {number} x\n   * @param {number} y\n   * @returns {number} An incremental index associated with the added item (starting from `0`).\n   */\n  add(x, y) {\n    var index = this._pos >> 1;\n    this.ids[index] = index;\n    this.coords[this._pos++] = x;\n    this.coords[this._pos++] = y;\n    return index;\n  }\n\n  /**\n   * Perform indexing of the added points.\n   */\n  finish() {\n    var numAdded = this._pos >> 1;\n    if (numAdded !== this.numItems) {\n      throw new Error(\"Added \".concat(numAdded, \" items when expected \").concat(this.numItems, \".\"));\n    }\n    // kd-sort both arrays for efficient search\n    sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n    this._finished = true;\n    return this;\n  }\n\n  /**\n   * Search the index for items within a given bounding box.\n   * @param {number} minX\n   * @param {number} minY\n   * @param {number} maxX\n   * @param {number} maxY\n   * @returns {number[]} An array of indices correponding to the found items.\n   */\n  range(minX, minY, maxX, maxY) {\n    if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n    var {\n      ids,\n      coords,\n      nodeSize\n    } = this;\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n\n    // recursively search for items in range in the kd-sorted arrays\n    while (stack.length) {\n      var axis = stack.pop() || 0;\n      var right = stack.pop() || 0;\n      var left = stack.pop() || 0;\n\n      // if we reached \"tree node\", search linearly\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          var _x = coords[2 * i];\n          var _y = coords[2 * i + 1];\n          if (_x >= minX && _x <= maxX && _y >= minY && _y <= maxY) result.push(ids[i]);\n        }\n        continue;\n      }\n\n      // otherwise find the middle index\n      var m = left + right >> 1;\n\n      // include the middle item if it's in range\n      var x = coords[2 * m];\n      var y = coords[2 * m + 1];\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n      // queue search in halves that intersect the query\n      if (axis === 0 ? minX <= x : minY <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(1 - axis);\n      }\n      if (axis === 0 ? maxX >= x : maxY >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(1 - axis);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Search the index for items within a given radius.\n   * @param {number} qx\n   * @param {number} qy\n   * @param {number} r Query radius.\n   * @returns {number[]} An array of indices correponding to the found items.\n   */\n  within(qx, qy, r) {\n    if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n    var {\n      ids,\n      coords,\n      nodeSize\n    } = this;\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    // recursively search for items within radius in the kd-sorted arrays\n    while (stack.length) {\n      var axis = stack.pop() || 0;\n      var right = stack.pop() || 0;\n      var left = stack.pop() || 0;\n\n      // if we reached \"tree node\", search linearly\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n        }\n        continue;\n      }\n\n      // otherwise find the middle index\n      var m = left + right >> 1;\n\n      // include the middle item if it's in range\n      var x = coords[2 * m];\n      var y = coords[2 * m + 1];\n      if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n      // queue search in halves that intersect the query\n      if (axis === 0 ? qx - r <= x : qy - r <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(1 - axis);\n      }\n      if (axis === 0 ? qx + r >= x : qy + r >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(1 - axis);\n      }\n    }\n    return result;\n  }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n  if (right - left <= nodeSize) return;\n  var m = left + right >> 1; // middle index\n\n  // sort ids and coords around the middle index so that the halves lie\n  // either left/right or top/bottom correspondingly (taking turns)\n  select(ids, coords, m, left, right, axis);\n\n  // recursively kd-sort first half and second half on the opposite axis\n  sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n  sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n  while (right > left) {\n    if (right - left > 600) {\n      var n = right - left + 1;\n      var m = k - left + 1;\n      var z = Math.log(n);\n      var s = 0.5 * Math.exp(2 * z / 3);\n      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n      select(ids, coords, k, newLeft, newRight, axis);\n    }\n    var t = coords[2 * k + axis];\n    var i = left;\n    var j = right;\n    swapItem(ids, coords, left, k);\n    if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n    while (i < j) {\n      swapItem(ids, coords, i, j);\n      i++;\n      j--;\n      while (coords[2 * i + axis] < t) i++;\n      while (coords[2 * j + axis] > t) j--;\n    }\n    if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);else {\n      j++;\n      swapItem(ids, coords, j, right);\n    }\n    if (j <= k) left = j + 1;\n    if (k <= j) right = j - 1;\n  }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n  swap(ids, i, j);\n  swap(coords, 2 * i, 2 * j);\n  swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n  var tmp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n  var dx = ax - bx;\n  var dy = ay - by;\n  return dx * dx + dy * dy;\n}\n\nvar defaultOptions$2 = {\n  minZoom: 0,\n  // min zoom to generate clusters on\n  maxZoom: 16,\n  // max zoom level to cluster the points on\n  minPoints: 2,\n  // minimum points to form a cluster\n  radius: 40,\n  // cluster radius in pixels\n  extent: 512,\n  // tile extent (radius is calculated relative to it)\n  nodeSize: 64,\n  // size of the KD-tree leaf node, affects performance\n  log: false,\n  // whether to log timing info\n\n  // whether to generate numeric ids for input features (in vector tiles)\n  generateId: false,\n  // a reduce function for calculating custom cluster properties\n  reduce: null,\n  // (accumulated, props) => { accumulated.sum += props.sum; }\n\n  // properties to use for individual points when running the reducer\n  map: props => props // props => ({sum: props.my_value})\n};\nvar fround = Math.fround || (tmp => x => {\n  tmp[0] = +x;\n  return tmp[0];\n})(new Float32Array(1));\nvar OFFSET_ZOOM = 2;\nvar OFFSET_ID = 3;\nvar OFFSET_PARENT = 4;\nvar OFFSET_NUM = 5;\nvar OFFSET_PROP = 6;\nclass Supercluster {\n  constructor(options) {\n    this.options = Object.assign(Object.create(defaultOptions$2), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n    this.stride = this.options.reduce ? 7 : 6;\n    this.clusterProps = [];\n  }\n  load(points) {\n    var {\n      log,\n      minZoom,\n      maxZoom\n    } = this.options;\n    if (log) console.time('total time');\n    var timerId = \"prepare \".concat(points.length, \" points\");\n    if (log) console.time(timerId);\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    var data = [];\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      if (!p.geometry) continue;\n      var [lng, lat] = p.geometry.coordinates;\n      var x = fround(lngX(lng));\n      var y = fround(latY(lat));\n      // store internal point/cluster data in flat numeric arrays for performance\n      data.push(x, y,\n      // projected point coordinates\n      Infinity,\n      // the last zoom the point was processed at\n      i,\n      // index of the source feature in the original input array\n      -1,\n      // parent cluster id\n      1 // number of points in a cluster\n      );\n      if (this.options.reduce) data.push(0); // noop\n    }\n    var tree = this.trees[maxZoom + 1] = this._createTree(data);\n    if (log) console.timeEnd(timerId);\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (var z = maxZoom; z >= minZoom; z--) {\n      var now = +Date.now();\n\n      // create a new set of clusters for the zoom and index them with a KD-tree\n      tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n      if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n    }\n    if (log) console.timeEnd('total time');\n    return this;\n  }\n  getClusters(bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n    var tree = this.trees[this._limitZoom(zoom)];\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var data = tree.data;\n    var clusters = [];\n    for (var id of ids) {\n      var k = this.stride * id;\n      clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n    }\n    return clusters;\n  }\n  getChildren(clusterId) {\n    var originId = this._getOriginId(clusterId);\n    var originZoom = this._getOriginZoom(clusterId);\n    var errorMsg = 'No cluster with the specified id.';\n    var tree = this.trees[originZoom];\n    if (!tree) throw new Error(errorMsg);\n    var data = tree.data;\n    if (originId * this.stride >= data.length) throw new Error(errorMsg);\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var x = data[originId * this.stride];\n    var y = data[originId * this.stride + 1];\n    var ids = tree.within(x, y, r);\n    var children = [];\n    for (var id of ids) {\n      var k = id * this.stride;\n      if (data[k + OFFSET_PARENT] === clusterId) {\n        children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n      }\n    }\n    if (children.length === 0) throw new Error(errorMsg);\n    return children;\n  }\n  getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    var leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n    return leaves;\n  }\n  getTile(z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n    var z2 = Math.pow(2, z);\n    var {\n      extent,\n      radius\n    } = this.options;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n    var tile = {\n      features: []\n    };\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.data, x, y, z2, tile);\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.data, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.data, -1, y, z2, tile);\n    }\n    return tile.features.length ? tile : null;\n  }\n  getClusterExpansionZoom(clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n      var children = this.getChildren(clusterId);\n      expansionZoom++;\n      if (children.length !== 1) break;\n      clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n  }\n  _appendLeaves(result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n    for (var child of children) {\n      var props = child.properties;\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n          // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n      if (result.length === limit) break;\n    }\n    return skipped;\n  }\n  _createTree(data) {\n    var tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n    for (var i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n    tree.finish();\n    tree.data = data;\n    return tree;\n  }\n  _addTileFeatures(ids, data, x, y, z2, tile) {\n    for (var i of ids) {\n      var k = i * this.stride;\n      var isCluster = data[k + OFFSET_NUM] > 1;\n      var tags = void 0,\n        px = void 0,\n        py = void 0;\n      if (isCluster) {\n        tags = getClusterProperties(data, k, this.clusterProps);\n        px = data[k];\n        py = data[k + 1];\n      } else {\n        var p = this.points[data[k + OFFSET_ID]];\n        tags = p.properties;\n        var [lng, lat] = p.geometry.coordinates;\n        px = lngX(lng);\n        py = latY(lat);\n      }\n      var f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags\n      };\n\n      // assign id\n      var id = void 0;\n      if (isCluster || this.options.generateId) {\n        // optionally generate id for points\n        id = data[k + OFFSET_ID];\n      } else {\n        // keep id if already assigned\n        id = this.points[data[k + OFFSET_ID]].id;\n      }\n      if (id !== undefined) f.id = id;\n      tile.features.push(f);\n    }\n  }\n  _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n  }\n  _cluster(tree, zoom) {\n    var {\n      radius,\n      extent,\n      reduce,\n      minPoints\n    } = this.options;\n    var r = radius / (extent * Math.pow(2, zoom));\n    var data = tree.data;\n    var nextData = [];\n    var stride = this.stride;\n\n    // loop through each point\n    for (var i = 0; i < data.length; i += stride) {\n      // if we've already visited the point at this zoom level, skip it\n      if (data[i + OFFSET_ZOOM] <= zoom) continue;\n      data[i + OFFSET_ZOOM] = zoom;\n\n      // find all nearby points\n      var x = data[i];\n      var y = data[i + 1];\n      var neighborIds = tree.within(data[i], data[i + 1], r);\n      var numPointsOrigin = data[i + OFFSET_NUM];\n      var numPoints = numPointsOrigin;\n\n      // count the number of points in a potential cluster\n      for (var neighborId of neighborIds) {\n        var k = neighborId * stride;\n        // filter out neighbors that are already processed\n        if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n      }\n\n      // if there were neighbors to merge, and there are enough points to form a cluster\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        var wx = x * numPointsOrigin;\n        var wy = y * numPointsOrigin;\n        var clusterProperties = void 0;\n        var clusterPropIndex = -1;\n\n        // encode both zoom and point index on which the cluster originated -- offset by total length of features\n        var id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n        for (var _neighborId of neighborIds) {\n          var _k = _neighborId * stride;\n          if (data[_k + OFFSET_ZOOM] <= zoom) continue;\n          data[_k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n          var numPoints2 = data[_k + OFFSET_NUM];\n          wx += data[_k] * numPoints2; // accumulate coordinates for calculating weighted center\n          wy += data[_k + 1] * numPoints2;\n          data[_k + OFFSET_PARENT] = id;\n          if (reduce) {\n            if (!clusterProperties) {\n              clusterProperties = this._map(data, i, true);\n              clusterPropIndex = this.clusterProps.length;\n              this.clusterProps.push(clusterProperties);\n            }\n            reduce(clusterProperties, this._map(data, _k));\n          }\n        }\n        data[i + OFFSET_PARENT] = id;\n        nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n        if (reduce) nextData.push(clusterPropIndex);\n      } else {\n        // left points as unclustered\n        for (var j = 0; j < stride; j++) nextData.push(data[i + j]);\n        if (numPoints > 1) {\n          for (var _neighborId2 of neighborIds) {\n            var _k2 = _neighborId2 * stride;\n            if (data[_k2 + OFFSET_ZOOM] <= zoom) continue;\n            data[_k2 + OFFSET_ZOOM] = zoom;\n            for (var _j = 0; _j < stride; _j++) nextData.push(data[_k2 + _j]);\n          }\n        }\n      }\n    }\n    return nextData;\n  }\n\n  // get index of the point from which the cluster originated\n  _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  }\n\n  // get zoom of the point from which the cluster originated\n  _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  }\n  _map(data, i, clone) {\n    if (data[i + OFFSET_NUM] > 1) {\n      var props = this.clusterProps[data[i + OFFSET_PROP]];\n      return clone ? Object.assign({}, props) : props;\n    }\n    var original = this.points[data[i + OFFSET_ID]].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? Object.assign({}, result) : result;\n  }\n}\nfunction getClusterJSON(data, i, clusterProps) {\n  return {\n    type: 'Feature',\n    id: data[i + OFFSET_ID],\n    properties: getClusterProperties(data, i, clusterProps),\n    geometry: {\n      type: 'Point',\n      coordinates: [xLng(data[i]), yLat(data[i + 1])]\n    }\n  };\n}\nfunction getClusterProperties(data, i, clusterProps) {\n  var count = data[i + OFFSET_NUM];\n  var abbrev = count >= 10000 ? \"\".concat(Math.round(count / 1000), \"k\") : count >= 1000 ? \"\".concat(Math.round(count / 100) / 10, \"k\") : count;\n  var propIndex = data[i + OFFSET_PROP];\n  var properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n  return Object.assign(properties, {\n    cluster: true,\n    cluster_id: data[i + OFFSET_ID],\n    point_count: count,\n    point_count_abbreviated: abbrev\n  });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n  return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n  var sin = Math.sin(lat * Math.PI / 180);\n  var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n  return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n  return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n  var y2 = (180 - y * 360) * Math.PI / 180;\n  return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\n/**\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * util class that creates a common set of convenience functions to wrap\n * shared behavior of Advanced Markers and Markers.\n */\nclass MarkerUtils {\n  static isAdvancedMarkerAvailable(map) {\n    return google.maps.marker && map.getMapCapabilities().isAdvancedMarkersAvailable === true;\n  }\n  static isAdvancedMarker(marker) {\n    return google.maps.marker && marker instanceof google.maps.marker.AdvancedMarkerElement;\n  }\n  static setMap(marker, map) {\n    if (this.isAdvancedMarker(marker)) {\n      marker.map = map;\n    } else {\n      marker.setMap(map);\n    }\n  }\n  static getPosition(marker) {\n    // SuperClusterAlgorithm.calculate expects a LatLng instance so we fake it for Adv Markers\n    if (this.isAdvancedMarker(marker)) {\n      if (marker.position) {\n        if (marker.position instanceof google.maps.LatLng) {\n          return marker.position;\n        }\n        // since we can't cast to LatLngLiteral for reasons =(\n        if (marker.position.lat && marker.position.lng) {\n          return new google.maps.LatLng(marker.position.lat, marker.position.lng);\n        }\n      }\n      return new google.maps.LatLng(null);\n    }\n    return marker.getPosition();\n  }\n  static getVisible(marker) {\n    if (this.isAdvancedMarker(marker)) {\n      /**\n       * Always return true for Advanced Markers because the clusterer\n       * uses getVisible as a way to count legacy markers not as an actual\n       * indicator of visibility for some reason. Even when markers are hidden\n       * Marker.getVisible returns `true` and this is used to set the marker count\n       * on the cluster. See the behavior of Cluster.count\n       */\n      return true;\n    }\n    return marker.getVisible();\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Cluster {\n  constructor(_ref) {\n    var {\n      markers,\n      position\n    } = _ref;\n    this.markers = markers;\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n  get bounds() {\n    if (this.markers.length === 0 && !this._position) {\n      return;\n    }\n    var bounds = new google.maps.LatLngBounds(this._position, this._position);\n    for (var marker of this.markers) {\n      bounds.extend(MarkerUtils.getPosition(marker));\n    }\n    return bounds;\n  }\n  get position() {\n    return this._position || this.bounds.getCenter();\n  }\n  /**\n   * Get the count of **visible** markers.\n   */\n  get count() {\n    return this.markers.filter(m => MarkerUtils.getVisible(m)).length;\n  }\n  /**\n   * Add a marker to the cluster.\n   */\n  push(marker) {\n    this.markers.push(marker);\n  }\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  delete() {\n    if (this.marker) {\n      MarkerUtils.setMap(this.marker, null);\n      this.marker = undefined;\n    }\n    this.markers.length = 0;\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the markers visible in a padded map viewport\n *\n * @param map\n * @param mapCanvasProjection\n * @param markers The list of marker to filter\n * @param viewportPaddingPixels The padding in pixel\n * @returns The list of markers in the padded viewport\n */\nvar filterMarkersToPaddedViewport = (map, mapCanvasProjection, markers, viewportPaddingPixels) => {\n  var extendedMapBounds = extendBoundsToPaddedViewport(map.getBounds(), mapCanvasProjection, viewportPaddingPixels);\n  return markers.filter(marker => extendedMapBounds.contains(MarkerUtils.getPosition(marker)));\n};\n/**\n * Extends a bounds by a number of pixels in each direction\n */\nvar extendBoundsToPaddedViewport = (bounds, projection, numPixels) => {\n  var {\n    northEast,\n    southWest\n  } = latLngBoundsToPixelBounds(bounds, projection);\n  var extendedPixelBounds = extendPixelBounds({\n    northEast,\n    southWest\n  }, numPixels);\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n/**\n * Gets the extended bounds as a bbox [westLng, southLat, eastLng, northLat]\n */\nvar getPaddedViewport = (bounds, projection, pixels) => {\n  var extended = extendBoundsToPaddedViewport(bounds, projection, pixels);\n  var ne = extended.getNorthEast();\n  var sw = extended.getSouthWest();\n  return [sw.lng(), sw.lat(), ne.lng(), ne.lat()];\n};\n/**\n * Returns the distance between 2 positions.\n *\n * @hidden\n */\nvar distanceBetweenPoints = (p1, p2) => {\n  var R = 6371; // Radius of the Earth in km\n  var dLat = (p2.lat - p1.lat) * Math.PI / 180;\n  var dLon = (p2.lng - p1.lng) * Math.PI / 180;\n  var sinDLat = Math.sin(dLat / 2);\n  var sinDLon = Math.sin(dLon / 2);\n  var a = sinDLat * sinDLat + Math.cos(p1.lat * Math.PI / 180) * Math.cos(p2.lat * Math.PI / 180) * sinDLon * sinDLon;\n  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n/**\n * Converts a LatLng bound to pixels.\n *\n * @hidden\n */\nvar latLngBoundsToPixelBounds = (bounds, projection) => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest())\n  };\n};\n/**\n * Extends a pixel bounds by numPixels in all directions.\n *\n * @hidden\n */\nvar extendPixelBounds = (_ref2, numPixels) => {\n  var {\n    northEast,\n    southWest\n  } = _ref2;\n  northEast.x += numPixels;\n  northEast.y -= numPixels;\n  southWest.x -= numPixels;\n  southWest.y += numPixels;\n  return {\n    northEast,\n    southWest\n  };\n};\n/**\n * @hidden\n */\nvar pixelBoundsToLatLngBounds = (_ref3, projection) => {\n  var {\n    northEast,\n    southWest\n  } = _ref3;\n  var sw = projection.fromDivPixelToLatLng(southWest);\n  var ne = projection.fromDivPixelToLatLng(northEast);\n  return new google.maps.LatLngBounds(sw, ne);\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @hidden\n */\nclass AbstractAlgorithm {\n  constructor(_ref4) {\n    var {\n      maxZoom = 16\n    } = _ref4;\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers})\n   *    }\n   * }\n   * ```\n   */\n  noop(_ref5) {\n    var {\n      markers\n    } = _ref5;\n    return noop$1(markers);\n  }\n}\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nclass AbstractViewportAlgorithm extends AbstractAlgorithm {\n  constructor(_a) {\n    var {\n        viewportPadding = 60\n      } = _a,\n      options = __rest(_a, [\"viewportPadding\"]);\n    super(options);\n    this.viewportPadding = 60;\n    this.viewportPadding = viewportPadding;\n  }\n  calculate(_ref6) {\n    var {\n      markers,\n      map,\n      mapCanvasProjection\n    } = _ref6;\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers\n        }),\n        changed: false\n      };\n    }\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n        map,\n        mapCanvasProjection\n      })\n    };\n  }\n}\n/**\n * @hidden\n */\nvar noop$1 = markers => {\n  var clusters = markers.map(marker => new Cluster({\n    position: MarkerUtils.getPosition(marker),\n    markers: [marker]\n  }));\n  return clusters;\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default Grid algorithm historically used in Google Maps marker\n * clustering.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n */\nclass GridAlgorithm extends AbstractViewportAlgorithm {\n  constructor(_a) {\n    var {\n        maxDistance = 40000,\n        gridSize = 40\n      } = _a,\n      options = __rest(_a, [\"maxDistance\", \"gridSize\"]);\n    super(options);\n    this.clusters = [];\n    this.state = {\n      zoom: -1\n    };\n    this.maxDistance = maxDistance;\n    this.gridSize = gridSize;\n  }\n  calculate(_ref7) {\n    var {\n      markers,\n      map,\n      mapCanvasProjection\n    } = _ref7;\n    var state = {\n      zoom: map.getZoom()\n    };\n    var changed = false;\n    if (this.state.zoom >= this.maxZoom && state.zoom >= this.maxZoom) ;else {\n      changed = !equal(this.state, state);\n    }\n    this.state = state;\n    if (map.getZoom() >= this.maxZoom) {\n      return {\n        clusters: this.noop({\n          markers\n        }),\n        changed\n      };\n    }\n    return {\n      clusters: this.cluster({\n        markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n        map,\n        mapCanvasProjection\n      })\n    };\n  }\n  cluster(_ref8) {\n    var {\n      markers,\n      map,\n      mapCanvasProjection\n    } = _ref8;\n    this.clusters = [];\n    markers.forEach(marker => {\n      this.addToClosestCluster(marker, map, mapCanvasProjection);\n    });\n    return this.clusters;\n  }\n  addToClosestCluster(marker, map, projection) {\n    var maxDistance = this.maxDistance; // Some large number\n    var cluster = null;\n    for (var i = 0; i < this.clusters.length; i++) {\n      var candidate = this.clusters[i];\n      var distance = distanceBetweenPoints(candidate.bounds.getCenter().toJSON(), MarkerUtils.getPosition(marker).toJSON());\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        cluster = candidate;\n      }\n    }\n    if (cluster && extendBoundsToPaddedViewport(cluster.bounds, projection, this.gridSize).contains(MarkerUtils.getPosition(marker))) {\n      cluster.push(marker);\n    } else {\n      var _cluster = new Cluster({\n        markers: [marker]\n      });\n      this.clusters.push(_cluster);\n    }\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nclass NoopAlgorithm extends AbstractAlgorithm {\n  constructor(_a) {\n    var options = __rest(_a, []);\n    super(options);\n  }\n  calculate(_ref9) {\n    var {\n      markers,\n      map,\n      mapCanvasProjection\n    } = _ref9;\n    return {\n      clusters: this.cluster({\n        markers,\n        map,\n        mapCanvasProjection\n      }),\n      changed: false\n    };\n  }\n  cluster(input) {\n    return this.noop(input);\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nclass SuperClusterAlgorithm extends AbstractAlgorithm {\n  constructor(_a) {\n    var {\n        maxZoom,\n        radius = 60\n      } = _a,\n      options = __rest(_a, [\"maxZoom\", \"radius\"]);\n    super({\n      maxZoom\n    });\n    this.state = {\n      zoom: -1\n    };\n    this.superCluster = new Supercluster(Object.assign({\n      maxZoom: this.maxZoom,\n      radius\n    }, options));\n  }\n  calculate(input) {\n    var changed = false;\n    var state = {\n      zoom: input.map.getZoom()\n    };\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n      var points = this.markers.map(marker => {\n        var position = MarkerUtils.getPosition(marker);\n        var coordinates = [position.lng(), position.lat()];\n        return {\n          type: \"Feature\",\n          geometry: {\n            type: \"Point\",\n            coordinates\n          },\n          properties: {\n            marker\n          }\n        };\n      });\n      this.superCluster.load(points);\n    }\n    if (!changed) {\n      if (this.state.zoom <= this.maxZoom || state.zoom <= this.maxZoom) {\n        changed = !equal(this.state, state);\n      }\n    }\n    this.state = state;\n    if (changed) {\n      this.clusters = this.cluster(input);\n    }\n    return {\n      clusters: this.clusters,\n      changed\n    };\n  }\n  cluster(_ref10) {\n    var {\n      map\n    } = _ref10;\n    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(map.getZoom())).map(feature => this.transformCluster(feature));\n  }\n  transformCluster(_ref11) {\n    var {\n      geometry: {\n        coordinates: [lng, lat]\n      },\n      properties\n    } = _ref11;\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster.getLeaves(properties.cluster_id, Infinity).map(leaf => leaf.properties.marker),\n        position: {\n          lat,\n          lng\n        }\n      });\n    }\n    var marker = properties.marker;\n    return new Cluster({\n      markers: [marker],\n      position: MarkerUtils.getPosition(marker)\n    });\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nclass SuperClusterViewportAlgorithm extends AbstractViewportAlgorithm {\n  constructor(_a) {\n    var {\n        maxZoom,\n        radius = 60,\n        viewportPadding = 60\n      } = _a,\n      options = __rest(_a, [\"maxZoom\", \"radius\", \"viewportPadding\"]);\n    super({\n      maxZoom,\n      viewportPadding\n    });\n    this.superCluster = new Supercluster(Object.assign({\n      maxZoom: this.maxZoom,\n      radius\n    }, options));\n    this.state = {\n      zoom: -1,\n      view: [0, 0, 0, 0]\n    };\n  }\n  calculate(input) {\n    var state = {\n      zoom: Math.round(input.map.getZoom()),\n      view: getPaddedViewport(input.map.getBounds(), input.mapCanvasProjection, this.viewportPadding)\n    };\n    var changed = !equal(this.state, state);\n    if (!equal(input.markers, this.markers)) {\n      changed = true;\n      // TODO use proxy to avoid copy?\n      this.markers = [...input.markers];\n      var points = this.markers.map(marker => {\n        var position = MarkerUtils.getPosition(marker);\n        var coordinates = [position.lng(), position.lat()];\n        return {\n          type: \"Feature\",\n          geometry: {\n            type: \"Point\",\n            coordinates\n          },\n          properties: {\n            marker\n          }\n        };\n      });\n      this.superCluster.load(points);\n    }\n    if (changed) {\n      this.clusters = this.cluster(input);\n      this.state = state;\n    }\n    return {\n      clusters: this.clusters,\n      changed\n    };\n  }\n  cluster(_ref12) {\n    var {\n      map,\n      mapCanvasProjection\n    } = _ref12;\n    /* recalculate new state because we can't use the cached version. */\n    var state = {\n      zoom: Math.round(map.getZoom()),\n      view: getPaddedViewport(map.getBounds(), mapCanvasProjection, this.viewportPadding)\n    };\n    return this.superCluster.getClusters(state.view, state.zoom).map(feature => this.transformCluster(feature));\n  }\n  transformCluster(_ref13) {\n    var {\n      geometry: {\n        coordinates: [lng, lat]\n      },\n      properties\n    } = _ref13;\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster.getLeaves(properties.cluster_id, Infinity).map(leaf => leaf.properties.marker),\n        position: {\n          lat,\n          lng\n        }\n      });\n    }\n    var marker = properties.marker;\n    return new Cluster({\n      markers: [marker],\n      position: MarkerUtils.getPosition(marker)\n    });\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nclass ClusterStats {\n  constructor(markers, clusters) {\n    this.markers = {\n      sum: markers.length\n    };\n    var clusterMarkerCounts = clusters.map(a => a.count);\n    var clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts)\n      }\n    };\n  }\n}\nclass DefaultRenderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  render(_ref14, stats, map) {\n    var {\n      count,\n      position\n    } = _ref14;\n    // change color if this cluster has more markers than the mean cluster\n    var color = count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n    // create svg literal with fill color\n    var svg = \"<svg fill=\\\"\".concat(color, \"\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 240 240\\\" width=\\\"50\\\" height=\\\"50\\\">\\n<circle cx=\\\"120\\\" cy=\\\"120\\\" opacity=\\\".6\\\" r=\\\"70\\\" />\\n<circle cx=\\\"120\\\" cy=\\\"120\\\" opacity=\\\".3\\\" r=\\\"90\\\" />\\n<circle cx=\\\"120\\\" cy=\\\"120\\\" opacity=\\\".2\\\" r=\\\"110\\\" />\\n<text x=\\\"50%\\\" y=\\\"50%\\\" style=\\\"fill:#fff\\\" text-anchor=\\\"middle\\\" font-size=\\\"50\\\" dominant-baseline=\\\"middle\\\" font-family=\\\"roboto,arial,sans-serif\\\">\").concat(count, \"</text>\\n</svg>\");\n    var title = \"Cluster of \".concat(count, \" markers\"),\n      // adjust zIndex to be above other markers\n      zIndex = Number(google.maps.Marker.MAX_ZINDEX) + count;\n    if (MarkerUtils.isAdvancedMarkerAvailable(map)) {\n      // create cluster SVG element\n      var parser = new DOMParser();\n      var svgEl = parser.parseFromString(svg, \"image/svg+xml\").documentElement;\n      svgEl.setAttribute(\"transform\", \"translate(0 25)\");\n      var _clusterOptions = {\n        map,\n        position,\n        zIndex,\n        title,\n        content: svgEl\n      };\n      return new google.maps.marker.AdvancedMarkerElement(_clusterOptions);\n    }\n    var clusterOptions = {\n      position,\n      zIndex,\n      title,\n      icon: {\n        url: \"data:image/svg+xml;base64,\".concat(btoa(svg)),\n        anchor: new google.maps.Point(25, 25)\n      }\n    };\n    return new google.maps.Marker(clusterOptions);\n  }\n}\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1, type2) {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (var property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n/**\n * @ignore\n */\nclass OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MarkerClustererEvents;\n(function (MarkerClustererEvents) {\n  MarkerClustererEvents[\"CLUSTERING_BEGIN\"] = \"clusteringbegin\";\n  MarkerClustererEvents[\"CLUSTERING_END\"] = \"clusteringend\";\n  MarkerClustererEvents[\"CLUSTER_CLICK\"] = \"click\";\n})(MarkerClustererEvents || (MarkerClustererEvents = {}));\nvar defaultOnClusterClickHandler = (_, cluster, map) => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n */\nclass MarkerClusterer extends OverlayViewSafe {\n  constructor(_ref15) {\n    var {\n      map,\n      markers = [],\n      algorithmOptions = {},\n      algorithm = new SuperClusterAlgorithm(algorithmOptions),\n      renderer = new DefaultRenderer(),\n      onClusterClick = defaultOnClusterClickHandler\n    } = _ref15;\n    super();\n    this.markers = [...markers];\n    this.clusters = [];\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n    this.onClusterClick = onClusterClick;\n    if (map) {\n      this.setMap(map);\n    }\n  }\n  addMarker(marker, noDraw) {\n    if (this.markers.includes(marker)) {\n      return;\n    }\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n  addMarkers(markers, noDraw) {\n    markers.forEach(marker => {\n      this.addMarker(marker, true);\n    });\n    if (!noDraw) {\n      this.render();\n    }\n  }\n  removeMarker(marker, noDraw) {\n    var index = this.markers.indexOf(marker);\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n    MarkerUtils.setMap(marker, null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n    if (!noDraw) {\n      this.render();\n    }\n    return true;\n  }\n  removeMarkers(markers, noDraw) {\n    var removed = false;\n    markers.forEach(marker => {\n      removed = this.removeMarker(marker, true) || removed;\n    });\n    if (removed && !noDraw) {\n      this.render();\n    }\n    return removed;\n  }\n  clearMarkers(noDraw) {\n    this.markers.length = 0;\n    if (!noDraw) {\n      this.render();\n    }\n  }\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  render() {\n    var map = this.getMap();\n    if (map instanceof google.maps.Map && map.getProjection()) {\n      google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);\n      var {\n        clusters,\n        changed\n      } = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection()\n      });\n      // Allow algorithms to return flag on whether the clusters/markers have changed.\n      if (changed || changed == undefined) {\n        // Accumulate the markers of the clusters composed of a single marker.\n        // Those clusters directly use the marker.\n        // Clusters with more than one markers use a group marker generated by a renderer.\n        var singleMarker = new Set();\n        for (var cluster of clusters) {\n          if (cluster.markers.length == 1) {\n            singleMarker.add(cluster.markers[0]);\n          }\n        }\n        var groupMarkers = [];\n        // Iterate the clusters that are currently rendered.\n        for (var _cluster2 of this.clusters) {\n          if (_cluster2.marker == null) {\n            continue;\n          }\n          if (_cluster2.markers.length == 1) {\n            if (!singleMarker.has(_cluster2.marker)) {\n              // The marker:\n              // - was previously rendered because it is from a cluster with 1 marker,\n              // - should no more be rendered as it is not in singleMarker.\n              MarkerUtils.setMap(_cluster2.marker, null);\n            }\n          } else {\n            // Delay the removal of old group markers to avoid flickering.\n            groupMarkers.push(_cluster2.marker);\n          }\n        }\n        this.clusters = clusters;\n        this.renderClusters();\n        // Delayed removal of the markers of the former groups.\n        requestAnimationFrame(() => groupMarkers.forEach(marker => MarkerUtils.setMap(marker, null)));\n      }\n      google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);\n    }\n  }\n  onAdd() {\n    this.idleListener = this.getMap().addListener(\"idle\", this.render.bind(this));\n    this.render();\n  }\n  onRemove() {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n  reset() {\n    this.markers.forEach(marker => MarkerUtils.setMap(marker, null));\n    this.clusters.forEach(cluster => cluster.delete());\n    this.clusters = [];\n  }\n  renderClusters() {\n    // Generate stats to pass to renderers.\n    var stats = new ClusterStats(this.markers, this.clusters);\n    var map = this.getMap();\n    this.clusters.forEach(cluster => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        // Generate the marker to represent the group.\n        cluster.marker = this.renderer.render(cluster, stats, map);\n        // Make sure all individual markers are removed from the map.\n        cluster.markers.forEach(marker => MarkerUtils.setMap(marker, null));\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\"click\", /* istanbul ignore next */\n          event => {\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTER_CLICK, cluster);\n            this.onClusterClick(event, cluster, map);\n          });\n        }\n      }\n      MarkerUtils.setMap(cluster.marker, map);\n    });\n  }\n}\n\nvar index_esm = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractAlgorithm: AbstractAlgorithm,\n  AbstractViewportAlgorithm: AbstractViewportAlgorithm,\n  Cluster: Cluster,\n  ClusterStats: ClusterStats,\n  DefaultRenderer: DefaultRenderer,\n  GridAlgorithm: GridAlgorithm,\n  MarkerClusterer: MarkerClusterer,\n  get MarkerClustererEvents () { return MarkerClustererEvents; },\n  MarkerUtils: MarkerUtils,\n  NoopAlgorithm: NoopAlgorithm,\n  SuperClusterAlgorithm: SuperClusterAlgorithm,\n  SuperClusterViewportAlgorithm: SuperClusterViewportAlgorithm,\n  defaultOnClusterClickHandler: defaultOnClusterClickHandler,\n  distanceBetweenPoints: distanceBetweenPoints,\n  extendBoundsToPaddedViewport: extendBoundsToPaddedViewport,\n  extendPixelBounds: extendPixelBounds,\n  filterMarkersToPaddedViewport: filterMarkersToPaddedViewport,\n  getPaddedViewport: getPaddedViewport,\n  noop: noop$1,\n  pixelBoundsToLatLngBounds: pixelBoundsToLatLngBounds\n});\n\nfunction ownKeys$a(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$a(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$a(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$a(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction useGoogleMarkerClusterer(options) {\n  var map = useGoogleMap();\n  var [markerClusterer, setMarkerClusterer] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map && markerClusterer === null) {\n      var markerCluster = new MarkerClusterer(_objectSpread$a(_objectSpread$a({}, options), {}, {\n        map\n      }));\n      setMarkerClusterer(markerCluster);\n    }\n  }, [map]);\n  return markerClusterer;\n}\n/** Wrapper around [@googlemaps/markerclusterer](https://github.com/googlemaps/js-markerclusterer)\n *\n * Accepts {@link  MarkerClustererOptionsSubset} which is a subset of  {@link MarkerClustererOptions}\n */\nfunction GoogleMarkerClusterer(_ref) {\n  var {\n    children,\n    options\n  } = _ref;\n  var markerClusterer = useGoogleMarkerClusterer(options);\n  return markerClusterer !== null ? children(markerClusterer) : null;\n}\nvar GoogleMarkerClusterer$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GoogleMarkerClusterer);\n\nvar eventMap$c = {\n  onCloseClick: 'closeclick',\n  onContentChanged: 'content_changed',\n  onDomReady: 'domready',\n  onPositionChanged: 'position_changed',\n  onZindexChanged: 'zindex_changed'\n};\nvar updaterMap$c = {\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  position(instance, position) {\n    instance.setPosition(position);\n  },\n  zIndex(instance, zIndex) {\n    instance.setZIndex(zIndex);\n  }\n};\nfunction InfoWindowFunctional(_ref) {\n  var {\n    children,\n    anchor,\n    options,\n    position,\n    zIndex,\n    onCloseClick,\n    onDomReady,\n    onContentChanged,\n    onPositionChanged,\n    onZindexChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [closeclickListener, setCloseClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [domreadyclickListener, setDomReadyClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [contentchangedclickListener, setContentChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [positionchangedclickListener, setPositionChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [zindexchangedclickListener, setZindexChangedClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var containerElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.close();\n      if (anchor) {\n        instance.open(map, anchor);\n      } else if (instance.getPosition()) {\n        instance.open(map);\n      }\n    }\n  }, [map, instance, anchor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (position && instance !== null) {\n      instance.setPosition(position);\n    }\n  }, [position]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof zIndex === 'number' && instance !== null) {\n      instance.setZIndex(zIndex);\n    }\n  }, [zIndex]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onCloseClick) {\n      if (closeclickListener !== null) {\n        google.maps.event.removeListener(closeclickListener);\n      }\n      setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n    }\n  }, [onCloseClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDomReady) {\n      if (domreadyclickListener !== null) {\n        google.maps.event.removeListener(domreadyclickListener);\n      }\n      setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n    }\n  }, [onDomReady]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onContentChanged) {\n      if (contentchangedclickListener !== null) {\n        google.maps.event.removeListener(contentchangedclickListener);\n      }\n      setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n    }\n  }, [onContentChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onPositionChanged) {\n      if (positionchangedclickListener !== null) {\n        google.maps.event.removeListener(positionchangedclickListener);\n      }\n      setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n    }\n  }, [onPositionChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onZindexChanged) {\n      if (zindexchangedclickListener !== null) {\n        google.maps.event.removeListener(zindexchangedclickListener);\n      }\n      setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n    }\n  }, [onZindexChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var infoWindow = new google.maps.InfoWindow(options);\n    setInstance(infoWindow);\n    containerElementRef.current = document.createElement('div');\n    if (onCloseClick) {\n      setCloseClickListener(google.maps.event.addListener(infoWindow, 'closeclick', onCloseClick));\n    }\n    if (onDomReady) {\n      setDomReadyClickListener(google.maps.event.addListener(infoWindow, 'domready', onDomReady));\n    }\n    if (onContentChanged) {\n      setContentChangedClickListener(google.maps.event.addListener(infoWindow, 'content_changed', onContentChanged));\n    }\n    if (onPositionChanged) {\n      setPositionChangedClickListener(google.maps.event.addListener(infoWindow, 'position_changed', onPositionChanged));\n    }\n    if (onZindexChanged) {\n      setZindexChangedClickListener(google.maps.event.addListener(infoWindow, 'zindex_changed', onZindexChanged));\n    }\n    infoWindow.setContent(containerElementRef.current);\n    if (position) {\n      infoWindow.setPosition(position);\n    }\n    if (zIndex) {\n      infoWindow.setZIndex(zIndex);\n    }\n    if (anchor) {\n      infoWindow.open(map, anchor);\n    } else if (infoWindow.getPosition()) {\n      infoWindow.open(map);\n    } else {\n      invariant(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n    }\n    if (onLoad) {\n      onLoad(infoWindow);\n    }\n    return () => {\n      if (closeclickListener) {\n        google.maps.event.removeListener(closeclickListener);\n      }\n      if (contentchangedclickListener) {\n        google.maps.event.removeListener(contentchangedclickListener);\n      }\n      if (domreadyclickListener) {\n        google.maps.event.removeListener(domreadyclickListener);\n      }\n      if (positionchangedclickListener) {\n        google.maps.event.removeListener(positionchangedclickListener);\n      }\n      if (zindexchangedclickListener) {\n        google.maps.event.removeListener(zindexchangedclickListener);\n      }\n      if (onUnmount) {\n        onUnmount(infoWindow);\n      }\n      infoWindow.close();\n    };\n  }, []);\n  return containerElementRef.current ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children), containerElementRef.current) : null;\n}\nvar InfoWindowF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(InfoWindowFunctional);\nclass InfoWindow extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"containerElement\", null);\n    _defineProperty(this, \"state\", {\n      infoWindow: null\n    });\n    _defineProperty(this, \"open\", (infoWindow, anchor) => {\n      if (anchor) {\n        infoWindow.open(this.context, anchor);\n      } else if (infoWindow.getPosition()) {\n        infoWindow.open(this.context);\n      } else {\n        invariant(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n      }\n    });\n    _defineProperty(this, \"setInfoWindowCallback\", () => {\n      if (this.state.infoWindow !== null && this.containerElement !== null) {\n        this.state.infoWindow.setContent(this.containerElement);\n        this.open(this.state.infoWindow, this.props.anchor);\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.infoWindow);\n        }\n      }\n    });\n  }\n  componentDidMount() {\n    var infoWindow = new google.maps.InfoWindow(this.props.options);\n    this.containerElement = document.createElement('div');\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$c,\n      eventMap: eventMap$c,\n      prevProps: {},\n      nextProps: this.props,\n      instance: infoWindow\n    });\n    this.setState(() => {\n      return {\n        infoWindow\n      };\n    }, this.setInfoWindowCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.infoWindow !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$c,\n        eventMap: eventMap$c,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.infoWindow\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.infoWindow !== null) {\n      unregisterEvents(this.registeredEvents);\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.infoWindow);\n      }\n      this.state.infoWindow.close();\n    }\n  }\n  render() {\n    return this.containerElement ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children), this.containerElement) : null;\n  }\n}\n_defineProperty(InfoWindow, \"contextType\", MapContext);\n\nfunction ownKeys$9(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$9(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$9(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$b = {\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$b = {\n  draggable(instance, draggable) {\n    instance.setDraggable(draggable);\n  },\n  editable(instance, editable) {\n    instance.setEditable(editable);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  path(instance, path) {\n    instance.setPath(path);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  }\n};\nvar defaultOptions$1 = {};\nfunction PolylineFunctional(_ref) {\n  var {\n    options,\n    draggable,\n    editable,\n    visible,\n    path,\n    onDblClick,\n    onDragEnd,\n    onDragStart,\n    onMouseDown,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onRightClick,\n    onClick,\n    onDrag,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof options !== 'undefined' && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof draggable !== 'undefined' && instance !== null) {\n      instance.setDraggable(draggable);\n    }\n  }, [instance, draggable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof editable !== 'undefined' && instance !== null) {\n      instance.setEditable(editable);\n    }\n  }, [instance, editable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && instance !== null) {\n      instance.setVisible(visible);\n    }\n  }, [instance, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof path !== 'undefined' && instance !== null) {\n      instance.setPath(path);\n    }\n  }, [instance, path]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragEnd) {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragStart) {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseMove) {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRightClick) {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDrag) {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var polyline = new google.maps.Polyline(_objectSpread$9(_objectSpread$9({}, options || defaultOptions$1), {}, {\n      map\n    }));\n    if (path) {\n      polyline.setPath(path);\n    }\n    if (typeof visible !== 'undefined') {\n      polyline.setVisible(visible);\n    }\n    if (typeof editable !== 'undefined') {\n      polyline.setEditable(editable);\n    }\n    if (typeof draggable !== 'undefined') {\n      polyline.setDraggable(draggable);\n    }\n    if (onDblClick) {\n      setDblclickListener(google.maps.event.addListener(polyline, 'dblclick', onDblClick));\n    }\n    if (onDragEnd) {\n      setDragendListener(google.maps.event.addListener(polyline, 'dragend', onDragEnd));\n    }\n    if (onDragStart) {\n      setDragstartListener(google.maps.event.addListener(polyline, 'dragstart', onDragStart));\n    }\n    if (onMouseDown) {\n      setMousedownListener(google.maps.event.addListener(polyline, 'mousedown', onMouseDown));\n    }\n    if (onMouseMove) {\n      setMousemoveListener(google.maps.event.addListener(polyline, 'mousemove', onMouseMove));\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(polyline, 'mouseout', onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(polyline, 'mouseover', onMouseOver));\n    }\n    if (onMouseUp) {\n      setMouseupListener(google.maps.event.addListener(polyline, 'mouseup', onMouseUp));\n    }\n    if (onRightClick) {\n      setRightclickListener(google.maps.event.addListener(polyline, 'rightclick', onRightClick));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(polyline, 'click', onClick));\n    }\n    if (onDrag) {\n      setDragListener(google.maps.event.addListener(polyline, 'drag', onDrag));\n    }\n    setInstance(polyline);\n    if (onLoad) {\n      onLoad(polyline);\n    }\n    return () => {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (onUnmount) {\n        onUnmount(polyline);\n      }\n      polyline.setMap(null);\n    };\n  }, []);\n  return null;\n}\nvar PolylineF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PolylineFunctional);\nclass Polyline extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      polyline: null\n    });\n    _defineProperty(this, \"setPolylineCallback\", () => {\n      if (this.state.polyline !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.polyline);\n      }\n    });\n  }\n  componentDidMount() {\n    var polyline = new google.maps.Polyline(_objectSpread$9(_objectSpread$9({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$b,\n      eventMap: eventMap$b,\n      prevProps: {},\n      nextProps: this.props,\n      instance: polyline\n    });\n    this.setState(function setPolyline() {\n      return {\n        polyline\n      };\n    }, this.setPolylineCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.polyline !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$b,\n        eventMap: eventMap$b,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.polyline\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.polyline === null) {\n      return;\n    }\n    if (this.props.onUnmount) {\n      this.props.onUnmount(this.state.polyline);\n    }\n    unregisterEvents(this.registeredEvents);\n    this.state.polyline.setMap(null);\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(Polyline, \"contextType\", MapContext);\n\nfunction ownKeys$8(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$8(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$8(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$a = {\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$a = {\n  draggable(instance, draggable) {\n    instance.setDraggable(draggable);\n  },\n  editable(instance, editable) {\n    instance.setEditable(editable);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  path(instance, path) {\n    instance.setPath(path);\n  },\n  paths(instance, paths) {\n    instance.setPaths(paths);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  }\n};\nfunction PolygonFunctional(_ref) {\n  var {\n    options,\n    draggable,\n    editable,\n    visible,\n    path,\n    paths,\n    onDblClick,\n    onDragEnd,\n    onDragStart,\n    onMouseDown,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onRightClick,\n    onClick,\n    onDrag,\n    onLoad,\n    onUnmount,\n    onEdit\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof options !== 'undefined' && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof draggable !== 'undefined' && instance !== null) {\n      instance.setDraggable(draggable);\n    }\n  }, [instance, draggable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof editable !== 'undefined' && instance !== null) {\n      instance.setEditable(editable);\n    }\n  }, [instance, editable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && instance !== null) {\n      instance.setVisible(visible);\n    }\n  }, [instance, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof path !== 'undefined' && instance !== null) {\n      instance.setPath(path);\n    }\n  }, [instance, path]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof paths !== 'undefined' && instance !== null) {\n      instance.setPaths(paths);\n    }\n  }, [instance, paths]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onDblClick === 'function') {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!instance) {\n      return;\n    }\n    google.maps.event.addListener(instance.getPath(), 'insert_at', () => {\n      onEdit === null || onEdit === void 0 || onEdit(instance);\n    });\n    google.maps.event.addListener(instance.getPath(), 'set_at', () => {\n      onEdit === null || onEdit === void 0 || onEdit(instance);\n    });\n    google.maps.event.addListener(instance.getPath(), 'remove_at', () => {\n      onEdit === null || onEdit === void 0 || onEdit(instance);\n    });\n  }, [instance, onEdit]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onDragEnd === 'function') {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onDragStart === 'function') {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onMouseDown === 'function') {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onMouseMove === 'function') {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onMouseOut === 'function') {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onMouseOver === 'function') {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onMouseUp === 'function') {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onRightClick === 'function') {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onClick === 'function') {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && typeof onDrag === 'function') {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var polygon = new google.maps.Polygon(_objectSpread$8(_objectSpread$8({}, options), {}, {\n      map\n    }));\n    if (path) {\n      polygon.setPath(path);\n    }\n    if (paths) {\n      polygon.setPaths(paths);\n    }\n    if (typeof visible !== 'undefined') {\n      polygon.setVisible(visible);\n    }\n    if (typeof editable !== 'undefined') {\n      polygon.setEditable(editable);\n    }\n    if (typeof draggable !== 'undefined') {\n      polygon.setDraggable(draggable);\n    }\n    if (onDblClick) {\n      setDblclickListener(google.maps.event.addListener(polygon, 'dblclick', onDblClick));\n    }\n    if (onDragEnd) {\n      setDragendListener(google.maps.event.addListener(polygon, 'dragend', onDragEnd));\n    }\n    if (onDragStart) {\n      setDragstartListener(google.maps.event.addListener(polygon, 'dragstart', onDragStart));\n    }\n    if (onMouseDown) {\n      setMousedownListener(google.maps.event.addListener(polygon, 'mousedown', onMouseDown));\n    }\n    if (onMouseMove) {\n      setMousemoveListener(google.maps.event.addListener(polygon, 'mousemove', onMouseMove));\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(polygon, 'mouseout', onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(polygon, 'mouseover', onMouseOver));\n    }\n    if (onMouseUp) {\n      setMouseupListener(google.maps.event.addListener(polygon, 'mouseup', onMouseUp));\n    }\n    if (onRightClick) {\n      setRightclickListener(google.maps.event.addListener(polygon, 'rightclick', onRightClick));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(polygon, 'click', onClick));\n    }\n    if (onDrag) {\n      setDragListener(google.maps.event.addListener(polygon, 'drag', onDrag));\n    }\n    setInstance(polygon);\n    if (onLoad) {\n      onLoad(polygon);\n    }\n    return () => {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (onUnmount) {\n        onUnmount(polygon);\n      }\n      polygon.setMap(null);\n    };\n  }, []);\n  return null;\n}\nvar PolygonF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PolygonFunctional);\nclass Polygon extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n  }\n  componentDidMount() {\n    var polygonOptions = this.props.options || {};\n    this.polygon = new google.maps.Polygon(polygonOptions);\n    this.polygon.setMap(this.context);\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$a,\n      eventMap: eventMap$a,\n      prevProps: {},\n      nextProps: this.props,\n      instance: this.polygon\n    });\n    if (this.props.onLoad) {\n      this.props.onLoad(this.polygon);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.polygon) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$a,\n        eventMap: eventMap$a,\n        prevProps,\n        nextProps: this.props,\n        instance: this.polygon\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.polygon) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.polygon);\n      }\n      unregisterEvents(this.registeredEvents);\n      if (this.polygon) {\n        this.polygon.setMap(null);\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(Polygon, \"contextType\", MapContext);\n\nfunction ownKeys$7(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$7(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$7(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$9 = {\n  onBoundsChanged: 'bounds_changed',\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$9 = {\n  bounds(instance, bounds) {\n    instance.setBounds(bounds);\n  },\n  draggable(instance, draggable) {\n    instance.setDraggable(draggable);\n  },\n  editable(instance, editable) {\n    instance.setEditable(editable);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  }\n};\nfunction RectangleFunctional(_ref) {\n  var {\n    options,\n    bounds,\n    draggable,\n    editable,\n    visible,\n    onDblClick,\n    onDragEnd,\n    onDragStart,\n    onMouseDown,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onRightClick,\n    onClick,\n    onDrag,\n    onBoundsChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightClickListener, setRightClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [boundsChangedListener, setBoundsChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof options !== 'undefined' && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof draggable !== 'undefined' && instance !== null) {\n      instance.setDraggable(draggable);\n    }\n  }, [instance, draggable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof editable !== 'undefined' && instance !== null) {\n      instance.setEditable(editable);\n    }\n  }, [instance, editable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && instance !== null) {\n      instance.setVisible(visible);\n    }\n  }, [instance, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof bounds !== 'undefined' && instance !== null) {\n      instance.setBounds(bounds);\n    }\n  }, [instance, bounds]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragEnd) {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragStart) {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseMove) {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRightClick) {\n      if (rightClickListener !== null) {\n        google.maps.event.removeListener(rightClickListener);\n      }\n      setRightClickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDrag) {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onBoundsChanged) {\n      if (boundsChangedListener !== null) {\n        google.maps.event.removeListener(boundsChangedListener);\n      }\n      setBoundsChangedListener(google.maps.event.addListener(instance, 'bounds_changed', onBoundsChanged));\n    }\n  }, [onBoundsChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var rectangle = new google.maps.Rectangle(_objectSpread$7(_objectSpread$7({}, options), {}, {\n      map\n    }));\n    if (typeof visible !== 'undefined') {\n      rectangle.setVisible(visible);\n    }\n    if (typeof editable !== 'undefined') {\n      rectangle.setEditable(editable);\n    }\n    if (typeof draggable !== 'undefined') {\n      rectangle.setDraggable(draggable);\n    }\n    if (typeof bounds !== 'undefined') {\n      rectangle.setBounds(bounds);\n    }\n    if (onDblClick) {\n      setDblclickListener(google.maps.event.addListener(rectangle, 'dblclick', onDblClick));\n    }\n    if (onDragEnd) {\n      setDragendListener(google.maps.event.addListener(rectangle, 'dragend', onDragEnd));\n    }\n    if (onDragStart) {\n      setDragstartListener(google.maps.event.addListener(rectangle, 'dragstart', onDragStart));\n    }\n    if (onMouseDown) {\n      setMousedownListener(google.maps.event.addListener(rectangle, 'mousedown', onMouseDown));\n    }\n    if (onMouseMove) {\n      setMousemoveListener(google.maps.event.addListener(rectangle, 'mousemove', onMouseMove));\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(rectangle, 'mouseout', onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(rectangle, 'mouseover', onMouseOver));\n    }\n    if (onMouseUp) {\n      setMouseupListener(google.maps.event.addListener(rectangle, 'mouseup', onMouseUp));\n    }\n    if (onRightClick) {\n      setRightClickListener(google.maps.event.addListener(rectangle, 'rightclick', onRightClick));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(rectangle, 'click', onClick));\n    }\n    if (onDrag) {\n      setDragListener(google.maps.event.addListener(rectangle, 'drag', onDrag));\n    }\n    if (onBoundsChanged) {\n      setBoundsChangedListener(google.maps.event.addListener(rectangle, 'bounds_changed', onBoundsChanged));\n    }\n    setInstance(rectangle);\n    if (onLoad) {\n      onLoad(rectangle);\n    }\n    return () => {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      if (rightClickListener !== null) {\n        google.maps.event.removeListener(rightClickListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      if (boundsChangedListener !== null) {\n        google.maps.event.removeListener(boundsChangedListener);\n      }\n      if (onUnmount) {\n        onUnmount(rectangle);\n      }\n      rectangle.setMap(null);\n    };\n  }, []);\n  return null;\n}\nvar RectangleF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(RectangleFunctional);\nclass Rectangle extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      rectangle: null\n    });\n    _defineProperty(this, \"setRectangleCallback\", () => {\n      if (this.state.rectangle !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.rectangle);\n      }\n    });\n  }\n  componentDidMount() {\n    var rectangle = new google.maps.Rectangle(_objectSpread$7(_objectSpread$7({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$9,\n      eventMap: eventMap$9,\n      prevProps: {},\n      nextProps: this.props,\n      instance: rectangle\n    });\n    this.setState(function setRectangle() {\n      return {\n        rectangle\n      };\n    }, this.setRectangleCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.rectangle !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$9,\n        eventMap: eventMap$9,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.rectangle\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.rectangle !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.rectangle);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.rectangle.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(Rectangle, \"contextType\", MapContext);\n\nfunction ownKeys$6(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$6(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$6(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$8 = {\n  onCenterChanged: 'center_changed',\n  onRadiusChanged: 'radius_changed',\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onDrag: 'drag',\n  onDragEnd: 'dragend',\n  onDragStart: 'dragstart',\n  onMouseDown: 'mousedown',\n  onMouseMove: 'mousemove',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick'\n};\nvar updaterMap$8 = {\n  center(instance, center) {\n    instance.setCenter(center);\n  },\n  draggable(instance, draggable) {\n    instance.setDraggable(draggable);\n  },\n  editable(instance, editable) {\n    instance.setEditable(editable);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  radius(instance, radius) {\n    instance.setRadius(radius);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  }\n};\nvar defaultOptions = {};\nfunction CircleFunctional(_ref) {\n  var {\n    options,\n    center,\n    radius,\n    draggable,\n    editable,\n    visible,\n    onDblClick,\n    onDragEnd,\n    onDragStart,\n    onMouseDown,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onRightClick,\n    onClick,\n    onDrag,\n    onCenterChanged,\n    onRadiusChanged,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragendListener, setDragendListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragstartListener, setDragstartListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dragListener, setDragListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [centerChangedListener, setCenterChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [radiusChangedListener, setRadiusChangedListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof options !== 'undefined' && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof draggable !== 'undefined' && instance !== null) {\n      instance.setDraggable(draggable);\n    }\n  }, [instance, draggable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof editable !== 'undefined' && instance !== null) {\n      instance.setEditable(editable);\n    }\n  }, [instance, editable]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && instance !== null) {\n      instance.setVisible(visible);\n    }\n  }, [instance, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof radius === 'number' && instance !== null) {\n      instance.setRadius(radius);\n    }\n  }, [instance, radius]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof center !== 'undefined' && instance !== null) {\n      instance.setCenter(center);\n    }\n  }, [instance, center]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragEnd) {\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n    }\n  }, [onDragEnd]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDragStart) {\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n    }\n  }, [onDragStart]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseMove) {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRightClick) {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDrag) {\n      if (dragListener !== null) {\n        google.maps.event.removeListener(dragListener);\n      }\n      setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n    }\n  }, [onDrag]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onCenterChanged) {\n      if (centerChangedListener !== null) {\n        google.maps.event.removeListener(centerChangedListener);\n      }\n      setCenterChangedListener(google.maps.event.addListener(instance, 'center_changed', onCenterChanged));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRadiusChanged) {\n      if (radiusChangedListener !== null) {\n        google.maps.event.removeListener(radiusChangedListener);\n      }\n      setRadiusChangedListener(google.maps.event.addListener(instance, 'radius_changed', onRadiusChanged));\n    }\n  }, [onRadiusChanged]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var circle = new google.maps.Circle(_objectSpread$6(_objectSpread$6({}, options || defaultOptions), {}, {\n      map\n    }));\n    if (typeof radius === 'number') {\n      circle.setRadius(radius);\n    }\n    if (typeof center !== 'undefined') {\n      circle.setCenter(center);\n    }\n    if (typeof radius === 'number') {\n      circle.setRadius(radius);\n    }\n    if (typeof visible !== 'undefined') {\n      circle.setVisible(visible);\n    }\n    if (typeof editable !== 'undefined') {\n      circle.setEditable(editable);\n    }\n    if (typeof draggable !== 'undefined') {\n      circle.setDraggable(draggable);\n    }\n    if (onDblClick) {\n      setDblclickListener(google.maps.event.addListener(circle, 'dblclick', onDblClick));\n    }\n    if (onDragEnd) {\n      setDragendListener(google.maps.event.addListener(circle, 'dragend', onDragEnd));\n    }\n    if (onDragStart) {\n      setDragstartListener(google.maps.event.addListener(circle, 'dragstart', onDragStart));\n    }\n    if (onMouseDown) {\n      setMousedownListener(google.maps.event.addListener(circle, 'mousedown', onMouseDown));\n    }\n    if (onMouseMove) {\n      setMousemoveListener(google.maps.event.addListener(circle, 'mousemove', onMouseMove));\n    }\n    if (onMouseOut) {\n      setMouseoutListener(google.maps.event.addListener(circle, 'mouseout', onMouseOut));\n    }\n    if (onMouseOver) {\n      setMouseoverListener(google.maps.event.addListener(circle, 'mouseover', onMouseOver));\n    }\n    if (onMouseUp) {\n      setMouseupListener(google.maps.event.addListener(circle, 'mouseup', onMouseUp));\n    }\n    if (onRightClick) {\n      setRightclickListener(google.maps.event.addListener(circle, 'rightclick', onRightClick));\n    }\n    if (onClick) {\n      setClickListener(google.maps.event.addListener(circle, 'click', onClick));\n    }\n    if (onDrag) {\n      setDragListener(google.maps.event.addListener(circle, 'drag', onDrag));\n    }\n    if (onCenterChanged) {\n      setCenterChangedListener(google.maps.event.addListener(circle, 'center_changed', onCenterChanged));\n    }\n    if (onRadiusChanged) {\n      setRadiusChangedListener(google.maps.event.addListener(circle, 'radius_changed', onRadiusChanged));\n    }\n    setInstance(circle);\n    if (onLoad) {\n      onLoad(circle);\n    }\n    return () => {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      if (dragendListener !== null) {\n        google.maps.event.removeListener(dragendListener);\n      }\n      if (dragstartListener !== null) {\n        google.maps.event.removeListener(dragstartListener);\n      }\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      if (centerChangedListener !== null) {\n        google.maps.event.removeListener(centerChangedListener);\n      }\n      if (radiusChangedListener !== null) {\n        google.maps.event.removeListener(radiusChangedListener);\n      }\n      if (onUnmount) {\n        onUnmount(circle);\n      }\n      circle.setMap(null);\n    };\n  }, []);\n  return null;\n}\nvar CircleF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(CircleFunctional);\nclass Circle extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      circle: null\n    });\n    _defineProperty(this, \"setCircleCallback\", () => {\n      if (this.state.circle !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.circle);\n      }\n    });\n  }\n  componentDidMount() {\n    var circle = new google.maps.Circle(_objectSpread$6(_objectSpread$6({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$8,\n      eventMap: eventMap$8,\n      prevProps: {},\n      nextProps: this.props,\n      instance: circle\n    });\n    this.setState(function setCircle() {\n      return {\n        circle\n      };\n    }, this.setCircleCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.circle !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$8,\n        eventMap: eventMap$8,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.circle\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.circle !== null) {\n      var _this$state$circle;\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.circle);\n      }\n      unregisterEvents(this.registeredEvents);\n      (_this$state$circle = this.state.circle) === null || _this$state$circle === void 0 || _this$state$circle.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(Circle, \"contextType\", MapContext);\n\nfunction ownKeys$5(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$5(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$5(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$7 = {\n  onClick: 'click',\n  onDblClick: 'dblclick',\n  onMouseDown: 'mousedown',\n  onMouseOut: 'mouseout',\n  onMouseOver: 'mouseover',\n  onMouseUp: 'mouseup',\n  onRightClick: 'rightclick',\n  onAddFeature: 'addfeature',\n  onRemoveFeature: 'removefeature',\n  onRemoveProperty: 'removeproperty',\n  onSetGeometry: 'setgeometry',\n  onSetProperty: 'setproperty'\n};\nvar updaterMap$7 = {\n  add(instance, feature) {\n    instance.add(feature);\n  },\n  addgeojson(instance, geojson, options) {\n    instance.addGeoJson(geojson, options);\n  },\n  contains(instance, feature) {\n    instance.contains(feature);\n  },\n  foreach(instance, callback) {\n    instance.forEach(callback);\n  },\n  loadgeojson(instance, url, options, callback) {\n    instance.loadGeoJson(url, options, callback);\n  },\n  overridestyle(instance, feature, style) {\n    instance.overrideStyle(feature, style);\n  },\n  remove(instance, feature) {\n    instance.remove(feature);\n  },\n  revertstyle(instance, feature) {\n    instance.revertStyle(feature);\n  },\n  controlposition(instance, controlPosition) {\n    instance.setControlPosition(controlPosition);\n  },\n  controls(instance, controls) {\n    instance.setControls(controls);\n  },\n  drawingmode(instance, mode) {\n    instance.setDrawingMode(mode);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  style(instance, style) {\n    instance.setStyle(style);\n  },\n  togeojson(instance, callback) {\n    instance.toGeoJson(callback);\n  }\n};\nfunction DataFunctional(_ref) {\n  var {\n    options,\n    onClick,\n    onDblClick,\n    onMouseDown,\n    onMouseMove,\n    onMouseOut,\n    onMouseOver,\n    onMouseUp,\n    onRightClick,\n    onAddFeature,\n    onRemoveFeature,\n    onRemoveProperty,\n    onSetGeometry,\n    onSetProperty,\n    onLoad,\n    onUnmount\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [dblclickListener, setDblclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousedownListener, setMousedownListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mousemoveListener, setMousemoveListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoutListener, setMouseoutListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseoverListener, setMouseoverListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [mouseupListener, setMouseupListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [rightclickListener, setRightclickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [clickListener, setClickListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [addFeatureListener, setAddFeatureListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [removeFeatureListener, setRemoveFeatureListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [removePropertyListener, setRemovePropertyListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [setGeometryListener, setSetGeometryListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  var [setPropertyListener, setSetPropertyListener] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onDblClick) {\n      if (dblclickListener !== null) {\n        google.maps.event.removeListener(dblclickListener);\n      }\n      setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n    }\n  }, [onDblClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseDown) {\n      if (mousedownListener !== null) {\n        google.maps.event.removeListener(mousedownListener);\n      }\n      setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n    }\n  }, [onMouseDown]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseMove) {\n      if (mousemoveListener !== null) {\n        google.maps.event.removeListener(mousemoveListener);\n      }\n      setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n    }\n  }, [onMouseMove]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOut) {\n      if (mouseoutListener !== null) {\n        google.maps.event.removeListener(mouseoutListener);\n      }\n      setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n    }\n  }, [onMouseOut]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseOver) {\n      if (mouseoverListener !== null) {\n        google.maps.event.removeListener(mouseoverListener);\n      }\n      setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n    }\n  }, [onMouseOver]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onMouseUp) {\n      if (mouseupListener !== null) {\n        google.maps.event.removeListener(mouseupListener);\n      }\n      setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n    }\n  }, [onMouseUp]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRightClick) {\n      if (rightclickListener !== null) {\n        google.maps.event.removeListener(rightclickListener);\n      }\n      setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n    }\n  }, [onRightClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onClick) {\n      if (clickListener !== null) {\n        google.maps.event.removeListener(clickListener);\n      }\n      setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n    }\n  }, [onClick]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onAddFeature) {\n      if (addFeatureListener !== null) {\n        google.maps.event.removeListener(addFeatureListener);\n      }\n      setAddFeatureListener(google.maps.event.addListener(instance, 'addfeature', onAddFeature));\n    }\n  }, [onAddFeature]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRemoveFeature) {\n      if (removeFeatureListener !== null) {\n        google.maps.event.removeListener(removeFeatureListener);\n      }\n      setRemoveFeatureListener(google.maps.event.addListener(instance, 'removefeature', onRemoveFeature));\n    }\n  }, [onRemoveFeature]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onRemoveProperty) {\n      if (removePropertyListener !== null) {\n        google.maps.event.removeListener(removePropertyListener);\n      }\n      setRemovePropertyListener(google.maps.event.addListener(instance, 'removeproperty', onRemoveProperty));\n    }\n  }, [onRemoveProperty]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onSetGeometry) {\n      if (setGeometryListener !== null) {\n        google.maps.event.removeListener(setGeometryListener);\n      }\n      setSetGeometryListener(google.maps.event.addListener(instance, 'setgeometry', onSetGeometry));\n    }\n  }, [onSetGeometry]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance && onSetProperty) {\n      if (setPropertyListener !== null) {\n        google.maps.event.removeListener(setPropertyListener);\n      }\n      setSetPropertyListener(google.maps.event.addListener(instance, 'setproperty', onSetProperty));\n    }\n  }, [onSetProperty]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (map !== null) {\n      var data = new google.maps.Data(_objectSpread$5(_objectSpread$5({}, options), {}, {\n        map\n      }));\n      if (onDblClick) {\n        setDblclickListener(google.maps.event.addListener(data, 'dblclick', onDblClick));\n      }\n      if (onMouseDown) {\n        setMousedownListener(google.maps.event.addListener(data, 'mousedown', onMouseDown));\n      }\n      if (onMouseMove) {\n        setMousemoveListener(google.maps.event.addListener(data, 'mousemove', onMouseMove));\n      }\n      if (onMouseOut) {\n        setMouseoutListener(google.maps.event.addListener(data, 'mouseout', onMouseOut));\n      }\n      if (onMouseOver) {\n        setMouseoverListener(google.maps.event.addListener(data, 'mouseover', onMouseOver));\n      }\n      if (onMouseUp) {\n        setMouseupListener(google.maps.event.addListener(data, 'mouseup', onMouseUp));\n      }\n      if (onRightClick) {\n        setRightclickListener(google.maps.event.addListener(data, 'rightclick', onRightClick));\n      }\n      if (onClick) {\n        setClickListener(google.maps.event.addListener(data, 'click', onClick));\n      }\n      if (onAddFeature) {\n        setAddFeatureListener(google.maps.event.addListener(data, 'addfeature', onAddFeature));\n      }\n      if (onRemoveFeature) {\n        setRemoveFeatureListener(google.maps.event.addListener(data, 'removefeature', onRemoveFeature));\n      }\n      if (onRemoveProperty) {\n        setRemovePropertyListener(google.maps.event.addListener(data, 'removeproperty', onRemoveProperty));\n      }\n      if (onSetGeometry) {\n        setSetGeometryListener(google.maps.event.addListener(data, 'setgeometry', onSetGeometry));\n      }\n      if (onSetProperty) {\n        setSetPropertyListener(google.maps.event.addListener(data, 'setproperty', onSetProperty));\n      }\n      setInstance(data);\n      if (onLoad) {\n        onLoad(data);\n      }\n    }\n    return () => {\n      if (instance) {\n        if (dblclickListener !== null) {\n          google.maps.event.removeListener(dblclickListener);\n        }\n        if (mousedownListener !== null) {\n          google.maps.event.removeListener(mousedownListener);\n        }\n        if (mousemoveListener !== null) {\n          google.maps.event.removeListener(mousemoveListener);\n        }\n        if (mouseoutListener !== null) {\n          google.maps.event.removeListener(mouseoutListener);\n        }\n        if (mouseoverListener !== null) {\n          google.maps.event.removeListener(mouseoverListener);\n        }\n        if (mouseupListener !== null) {\n          google.maps.event.removeListener(mouseupListener);\n        }\n        if (rightclickListener !== null) {\n          google.maps.event.removeListener(rightclickListener);\n        }\n        if (clickListener !== null) {\n          google.maps.event.removeListener(clickListener);\n        }\n        if (addFeatureListener !== null) {\n          google.maps.event.removeListener(addFeatureListener);\n        }\n        if (removeFeatureListener !== null) {\n          google.maps.event.removeListener(removeFeatureListener);\n        }\n        if (removePropertyListener !== null) {\n          google.maps.event.removeListener(removePropertyListener);\n        }\n        if (setGeometryListener !== null) {\n          google.maps.event.removeListener(setGeometryListener);\n        }\n        if (setPropertyListener !== null) {\n          google.maps.event.removeListener(setPropertyListener);\n        }\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar DataF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(DataFunctional);\nclass Data extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      data: null\n    });\n    _defineProperty(this, \"setDataCallback\", () => {\n      if (this.state.data !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.data);\n      }\n    });\n  }\n  componentDidMount() {\n    if (this.context !== null) {\n      var data = new google.maps.Data(_objectSpread$5(_objectSpread$5({}, this.props.options), {}, {\n        map: this.context\n      }));\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$7,\n        eventMap: eventMap$7,\n        prevProps: {},\n        nextProps: this.props,\n        instance: data\n      });\n      this.setState(() => {\n        return {\n          data\n        };\n      }, this.setDataCallback);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.data !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$7,\n        eventMap: eventMap$7,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.data\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.data !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.data);\n      }\n      unregisterEvents(this.registeredEvents);\n      if (this.state.data) {\n        this.state.data.setMap(null);\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(Data, \"contextType\", MapContext);\n\nfunction ownKeys$4(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$4(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$4(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$6 = {\n  onClick: 'click',\n  onDefaultViewportChanged: 'defaultviewport_changed',\n  onStatusChanged: 'status_changed'\n};\nvar updaterMap$6 = {\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  url(instance, url) {\n    instance.setUrl(url);\n  },\n  zIndex(instance, zIndex) {\n    instance.setZIndex(zIndex);\n  }\n};\nclass KmlLayer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      kmlLayer: null\n    });\n    _defineProperty(this, \"setKmlLayerCallback\", () => {\n      if (this.state.kmlLayer !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.kmlLayer);\n      }\n    });\n  }\n  componentDidMount() {\n    var kmlLayer = new google.maps.KmlLayer(_objectSpread$4(_objectSpread$4({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$6,\n      eventMap: eventMap$6,\n      prevProps: {},\n      nextProps: this.props,\n      instance: kmlLayer\n    });\n    this.setState(function setLmlLayer() {\n      return {\n        kmlLayer\n      };\n    }, this.setKmlLayerCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.kmlLayer !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$6,\n        eventMap: eventMap$6,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.kmlLayer\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.kmlLayer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.kmlLayer);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.kmlLayer.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(KmlLayer, \"contextType\", MapContext);\n\nfunction getOffsetOverride(containerElement, getPixelPositionOffset) {\n  return typeof getPixelPositionOffset === 'function' ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight) : {\n    x: 0,\n    y: 0\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLng(inst, Type) {\n  return new Type(inst.lat, inst.lng);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLngBounds(inst, Type) {\n  return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ensureOfType(inst,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  return inst instanceof type ? inst : factory(inst, type);\n}\nfunction ensureOfTypeBounds(inst,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype,\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n  return inst instanceof type ? inst : factory(inst, type);\n}\nfunction getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {\n  var ne = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n  var sw = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n  if (ne && sw) {\n    return {\n      left: \"\".concat(sw.x + offset.x, \"px\"),\n      top: \"\".concat(ne.y + offset.y, \"px\"),\n      width: \"\".concat(ne.x - sw.x - offset.x, \"px\"),\n      height: \"\".concat(sw.y - ne.y - offset.y, \"px\")\n    };\n  }\n  return {\n    left: '-9999px',\n    top: '-9999px'\n  };\n}\nfunction getLayoutStylesByPosition(mapCanvasProjection, offset, position) {\n  var point = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(position);\n  if (point) {\n    var {\n      x,\n      y\n    } = point;\n    return {\n      left: \"\".concat(x + offset.x, \"px\"),\n      top: \"\".concat(y + offset.y, \"px\")\n    };\n  }\n  return {\n    left: '-9999px',\n    top: '-9999px'\n  };\n}\nfunction getLayoutStyles(mapCanvasProjection, offset, bounds, position) {\n  return bounds !== undefined ? getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfTypeBounds(bounds, google.maps.LatLngBounds, createLatLngBounds)) : getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));\n}\nfunction arePositionsEqual(currentPosition, previousPosition) {\n  return currentPosition.left === previousPosition.left && currentPosition.top === previousPosition.top && currentPosition.width === previousPosition.height && currentPosition.height === previousPosition.height;\n}\n\nfunction ownKeys$3(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$3(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction createOverlay(container, pane, position, bounds, getPixelPositionOffset) {\n  class Overlay extends google.maps.OverlayView {\n    constructor(container, pane, position, bounds) {\n      super();\n      this.container = container;\n      this.pane = pane;\n      this.position = position;\n      this.bounds = bounds;\n    }\n    onAdd() {\n      var _this$getPanes;\n      var pane = (_this$getPanes = this.getPanes()) === null || _this$getPanes === void 0 ? void 0 : _this$getPanes[this.pane];\n      pane === null || pane === void 0 || pane.appendChild(this.container);\n    }\n    draw() {\n      var projection = this.getProjection();\n      var offset = _objectSpread$3({}, this.container ? getOffsetOverride(this.container, getPixelPositionOffset) : {\n        x: 0,\n        y: 0\n      });\n      var layoutStyles = getLayoutStyles(projection, offset, this.bounds, this.position);\n      for (var [key, value] of Object.entries(layoutStyles)) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.container.style[key] = value;\n      }\n    }\n    onRemove() {\n      if (this.container.parentNode !== null) {\n        this.container.parentNode.removeChild(this.container);\n      }\n    }\n  }\n  return new Overlay(container, pane, position, bounds);\n}\n\nfunction ownKeys$2(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$2(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction convertToLatLngString(latLngLike) {\n  if (!latLngLike) {\n    return '';\n  }\n  var latLng = latLngLike instanceof google.maps.LatLng ? latLngLike : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);\n  return latLng + '';\n}\nfunction convertToLatLngBoundsString(latLngBoundsLike) {\n  if (!latLngBoundsLike) {\n    return '';\n  }\n  var latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds ? latLngBoundsLike : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));\n  return latLngBounds + '';\n}\nvar FLOAT_PANE = \"floatPane\";\nvar MAP_PANE = \"mapPane\";\nvar MARKER_LAYER = \"markerLayer\";\nvar OVERLAY_LAYER = \"overlayLayer\";\nvar OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\";\nfunction OverlayViewFunctional(_ref) {\n  var {\n    position,\n    bounds,\n    mapPaneName,\n    zIndex,\n    onLoad,\n    onUnmount,\n    getPixelPositionOffset,\n    children\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    var div = document.createElement('div');\n    div.style.position = 'absolute';\n    return div;\n  }, []);\n  var overlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return createOverlay(container, mapPaneName, position, bounds, getPixelPositionOffset);\n  }, [container, mapPaneName, position, bounds]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    onLoad === null || onLoad === void 0 || onLoad(overlay);\n    overlay === null || overlay === void 0 || overlay.setMap(map);\n    return () => {\n      onUnmount === null || onUnmount === void 0 || onUnmount(overlay);\n      overlay === null || overlay === void 0 || overlay.setMap(null);\n    };\n  }, [map, overlay]);\n  // to move the container to the foreground and background\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    container.style.zIndex = \"\".concat(zIndex);\n  }, [zIndex, container]);\n  return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(children, container);\n}\nvar OverlayViewF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(OverlayViewFunctional);\nclass OverlayView extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor(props) {\n    super(props);\n    _defineProperty(this, \"state\", {\n      paneEl: null,\n      containerStyle: {\n        // set initial position\n        position: 'absolute'\n      }\n    });\n    _defineProperty(this, \"updatePane\", () => {\n      var mapPaneName = this.props.mapPaneName;\n      // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes\n      var mapPanes = this.overlayView.getPanes();\n      invariant(!!mapPaneName, \"OverlayView requires props.mapPaneName but got %s\", mapPaneName);\n      if (mapPanes) {\n        this.setState({\n          paneEl: mapPanes[mapPaneName]\n        });\n      } else {\n        this.setState({\n          paneEl: null\n        });\n      }\n    });\n    _defineProperty(this, \"onAdd\", () => {\n      var _this$props$onLoad, _this$props;\n      this.updatePane();\n      (_this$props$onLoad = (_this$props = this.props).onLoad) === null || _this$props$onLoad === void 0 || _this$props$onLoad.call(_this$props, this.overlayView);\n    });\n    _defineProperty(this, \"onPositionElement\", () => {\n      var mapCanvasProjection = this.overlayView.getProjection();\n      var offset = _objectSpread$2({\n        x: 0,\n        y: 0\n      }, this.containerRef.current ? getOffsetOverride(this.containerRef.current, this.props.getPixelPositionOffset) : {});\n      var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, this.props.bounds, this.props.position);\n      if (!arePositionsEqual(layoutStyles, {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        left: this.state.containerStyle.left,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        top: this.state.containerStyle.top,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        width: this.state.containerStyle.width,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        height: this.state.containerStyle.height\n      })) {\n        var _layoutStyles$top, _layoutStyles$left, _layoutStyles$width, _layoutStyles$height;\n        this.setState({\n          containerStyle: {\n            top: (_layoutStyles$top = layoutStyles.top) !== null && _layoutStyles$top !== void 0 ? _layoutStyles$top : 0,\n            left: (_layoutStyles$left = layoutStyles.left) !== null && _layoutStyles$left !== void 0 ? _layoutStyles$left : 0,\n            width: (_layoutStyles$width = layoutStyles.width) !== null && _layoutStyles$width !== void 0 ? _layoutStyles$width : 0,\n            height: (_layoutStyles$height = layoutStyles.height) !== null && _layoutStyles$height !== void 0 ? _layoutStyles$height : 0,\n            position: 'absolute'\n          }\n        });\n      }\n    });\n    _defineProperty(this, \"draw\", () => {\n      this.onPositionElement();\n    });\n    _defineProperty(this, \"onRemove\", () => {\n      var _this$props$onUnmount, _this$props2;\n      this.setState(() => ({\n        paneEl: null\n      }));\n      (_this$props$onUnmount = (_this$props2 = this.props).onUnmount) === null || _this$props$onUnmount === void 0 || _this$props$onUnmount.call(_this$props2, this.overlayView);\n    });\n    this.containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n    // You must implement three methods: onAdd(), draw(), and onRemove().\n    var overlayView = new google.maps.OverlayView();\n    overlayView.onAdd = this.onAdd;\n    overlayView.draw = this.draw;\n    overlayView.onRemove = this.onRemove;\n    this.overlayView = overlayView;\n  }\n  componentDidMount() {\n    this.overlayView.setMap(this.context);\n  }\n  componentDidUpdate(prevProps) {\n    var prevPositionString = convertToLatLngString(prevProps.position);\n    var positionString = convertToLatLngString(this.props.position);\n    var prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);\n    var boundsString = convertToLatLngBoundsString(this.props.bounds);\n    if (prevPositionString !== positionString || prevBoundsString !== boundsString) {\n      this.overlayView.draw();\n    }\n    if (prevProps.mapPaneName !== this.props.mapPaneName) {\n      this.updatePane();\n    }\n  }\n  componentWillUnmount() {\n    this.overlayView.setMap(null);\n  }\n  render() {\n    var paneEl = this.state.paneEl;\n    if (paneEl) {\n      return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        ref: this.containerRef,\n        style: this.state.containerStyle,\n        children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children)\n      }), paneEl);\n    } else {\n      return null;\n    }\n  }\n}\n_defineProperty(OverlayView, \"FLOAT_PANE\", \"floatPane\");\n_defineProperty(OverlayView, \"MAP_PANE\", \"mapPane\");\n_defineProperty(OverlayView, \"MARKER_LAYER\", \"markerLayer\");\n_defineProperty(OverlayView, \"OVERLAY_LAYER\", \"overlayLayer\");\n_defineProperty(OverlayView, \"OVERLAY_MOUSE_TARGET\", \"overlayMouseTarget\");\n_defineProperty(OverlayView, \"contextType\", MapContext);\n\nfunction noop() {\n  return;\n}\n\nfunction ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$5 = {\n  onDblClick: 'dblclick',\n  onClick: 'click'\n};\nvar updaterMap$5 = {\n  opacity(instance, opacity) {\n    instance.setOpacity(opacity);\n  }\n};\nfunction GroundOverlayFunctional(_ref) {\n  var {\n    url,\n    bounds,\n    options,\n    visible\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var imageBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n  var groundOverlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    return new google.maps.GroundOverlay(url, imageBounds, options);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (groundOverlay !== null) {\n      groundOverlay.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof url !== 'undefined' && groundOverlay !== null) {\n      groundOverlay.set('url', url);\n      groundOverlay.setMap(map);\n    }\n  }, [groundOverlay, url]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (typeof visible !== 'undefined' && groundOverlay !== null) {\n      groundOverlay.setOpacity(visible ? 1 : 0);\n    }\n  }, [groundOverlay, visible]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var newBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n    if (typeof bounds !== 'undefined' && groundOverlay !== null) {\n      groundOverlay.set('bounds', newBounds);\n      groundOverlay.setMap(map);\n    }\n  }, [groundOverlay, bounds]);\n  return null;\n}\nvar GroundOverlayF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GroundOverlayFunctional);\nclass GroundOverlay extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      groundOverlay: null\n    });\n    _defineProperty(this, \"setGroundOverlayCallback\", () => {\n      if (this.state.groundOverlay !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.groundOverlay);\n      }\n    });\n  }\n  componentDidMount() {\n    invariant(!!this.props.url || !!this.props.bounds, \"For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655\");\n    var groundOverlay = new google.maps.GroundOverlay(this.props.url, this.props.bounds, _objectSpread$1(_objectSpread$1({}, this.props.options), {}, {\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$5,\n      eventMap: eventMap$5,\n      prevProps: {},\n      nextProps: this.props,\n      instance: groundOverlay\n    });\n    this.setState(function setGroundOverlay() {\n      return {\n        groundOverlay\n      };\n    }, this.setGroundOverlayCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.groundOverlay !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$5,\n        eventMap: eventMap$5,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.groundOverlay\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.groundOverlay) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.groundOverlay);\n      }\n      this.state.groundOverlay.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(GroundOverlay, \"defaultProps\", {\n  onLoad: noop\n});\n_defineProperty(GroundOverlay, \"contextType\", MapContext);\n\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nvar eventMap$4 = {};\nvar updaterMap$4 = {\n  data(instance, data) {\n    instance.setData(data);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  }\n};\nfunction HeatmapLayerFunctional(_ref) {\n  var {\n    data,\n    onLoad,\n    onUnmount,\n    options\n  } = _ref;\n  var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n  var [instance, setInstance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!google.maps.visualization) {\n      invariant(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} in useJsApiScript? %s', google.maps.visualization);\n    }\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    invariant(!!data, 'data property is required in HeatmapLayer %s', data);\n  }, [data]);\n  // Order does matter\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (instance !== null) {\n      instance.setMap(map);\n    }\n  }, [map]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (options && instance !== null) {\n      instance.setOptions(options);\n    }\n  }, [instance, options]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var heatmapLayer = new google.maps.visualization.HeatmapLayer(_objectSpread(_objectSpread({}, options), {}, {\n      data,\n      map\n    }));\n    setInstance(heatmapLayer);\n    if (onLoad) {\n      onLoad(heatmapLayer);\n    }\n    return () => {\n      if (instance !== null) {\n        if (onUnmount) {\n          onUnmount(instance);\n        }\n        instance.setMap(null);\n      }\n    };\n  }, []);\n  return null;\n}\nvar HeatmapLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(HeatmapLayerFunctional);\nclass HeatmapLayer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      heatmapLayer: null\n    });\n    _defineProperty(this, \"setHeatmapLayerCallback\", () => {\n      if (this.state.heatmapLayer !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.heatmapLayer);\n      }\n    });\n  }\n  componentDidMount() {\n    invariant(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} to <LoadScript />? %s', google.maps.visualization);\n    invariant(!!this.props.data, 'data property is required in HeatmapLayer %s', this.props.data);\n    var heatmapLayer = new google.maps.visualization.HeatmapLayer(_objectSpread(_objectSpread({}, this.props.options), {}, {\n      data: this.props.data,\n      map: this.context\n    }));\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$4,\n      eventMap: eventMap$4,\n      prevProps: {},\n      nextProps: this.props,\n      instance: heatmapLayer\n    });\n    this.setState(function setHeatmapLayer() {\n      return {\n        heatmapLayer\n      };\n    }, this.setHeatmapLayerCallback);\n  }\n  componentDidUpdate(prevProps) {\n    unregisterEvents(this.registeredEvents);\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$4,\n      eventMap: eventMap$4,\n      prevProps,\n      nextProps: this.props,\n      instance: this.state.heatmapLayer\n    });\n  }\n  componentWillUnmount() {\n    if (this.state.heatmapLayer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.heatmapLayer);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.heatmapLayer.setMap(null);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(HeatmapLayer, \"contextType\", MapContext);\n\nvar eventMap$3 = {\n  onCloseClick: 'closeclick',\n  onPanoChanged: 'pano_changed',\n  onPositionChanged: 'position_changed',\n  onPovChanged: 'pov_changed',\n  onResize: 'resize',\n  onStatusChanged: 'status_changed',\n  onVisibleChanged: 'visible_changed',\n  onZoomChanged: 'zoom_changed'\n};\nvar updaterMap$3 = {\n  register(instance, provider, options) {\n    instance.registerPanoProvider(provider, options);\n  },\n  links(instance, links) {\n    instance.setLinks(links);\n  },\n  motionTracking(instance, motionTracking) {\n    instance.setMotionTracking(motionTracking);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  pano(instance, pano) {\n    instance.setPano(pano);\n  },\n  position(instance, position) {\n    instance.setPosition(position);\n  },\n  pov(instance, pov) {\n    instance.setPov(pov);\n  },\n  visible(instance, visible) {\n    instance.setVisible(visible);\n  },\n  zoom(instance, zoom) {\n    instance.setZoom(zoom);\n  }\n};\nclass StreetViewPanorama extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      streetViewPanorama: null\n    });\n    _defineProperty(this, \"setStreetViewPanoramaCallback\", () => {\n      if (this.state.streetViewPanorama !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.streetViewPanorama);\n      }\n    });\n  }\n  componentDidMount() {\n    var _this$context$getStre, _this$context;\n    var streetViewPanorama = (_this$context$getStre = (_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.getStreetView()) !== null && _this$context$getStre !== void 0 ? _this$context$getStre : null;\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$3,\n      eventMap: eventMap$3,\n      prevProps: {},\n      nextProps: this.props,\n      instance: streetViewPanorama\n    });\n    this.setState(() => {\n      return {\n        streetViewPanorama\n      };\n    }, this.setStreetViewPanoramaCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.streetViewPanorama !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$3,\n        eventMap: eventMap$3,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.streetViewPanorama\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.streetViewPanorama !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.streetViewPanorama);\n      }\n      unregisterEvents(this.registeredEvents);\n      this.state.streetViewPanorama.setVisible(false);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(StreetViewPanorama, \"contextType\", MapContext);\n\nclass StreetViewService extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      streetViewService: null\n    });\n    _defineProperty(this, \"setStreetViewServiceCallback\", () => {\n      if (this.state.streetViewService !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.streetViewService);\n      }\n    });\n  }\n  componentDidMount() {\n    var streetViewService = new google.maps.StreetViewService();\n    this.setState(function setStreetViewService() {\n      return {\n        streetViewService\n      };\n    }, this.setStreetViewServiceCallback);\n  }\n  componentWillUnmount() {\n    if (this.state.streetViewService !== null && this.props.onUnmount) {\n      this.props.onUnmount(this.state.streetViewService);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(StreetViewService, \"contextType\", MapContext);\n\nclass DirectionsService extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      directionsService: null\n    });\n    _defineProperty(this, \"setDirectionsServiceCallback\", () => {\n      if (this.state.directionsService !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.directionsService);\n      }\n    });\n  }\n  componentDidMount() {\n    invariant(!!this.props.options, 'DirectionsService expected options object as parameter, but got %s', this.props.options);\n    var directionsService = new google.maps.DirectionsService();\n    this.setState(function setDirectionsService() {\n      return {\n        directionsService\n      };\n    }, this.setDirectionsServiceCallback);\n  }\n  componentDidUpdate() {\n    if (this.state.directionsService !== null) {\n      this.state.directionsService.route(this.props.options, this.props.callback);\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.directionsService !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.directionsService);\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\n\nvar eventMap$2 = {\n  onDirectionsChanged: 'directions_changed'\n};\nvar updaterMap$2 = {\n  directions(instance, directions) {\n    instance.setDirections(directions);\n  },\n  map(instance, map) {\n    instance.setMap(map);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  panel(instance, panel) {\n    instance.setPanel(panel);\n  },\n  routeIndex(instance, routeIndex) {\n    instance.setRouteIndex(routeIndex);\n  }\n};\nclass DirectionsRenderer extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"state\", {\n      directionsRenderer: null\n    });\n    _defineProperty(this, \"setDirectionsRendererCallback\", () => {\n      if (this.state.directionsRenderer !== null) {\n        this.state.directionsRenderer.setMap(this.context);\n        if (this.props.onLoad) {\n          this.props.onLoad(this.state.directionsRenderer);\n        }\n      }\n    });\n  }\n  componentDidMount() {\n    var directionsRenderer = new google.maps.DirectionsRenderer(this.props.options);\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap: updaterMap$2,\n      eventMap: eventMap$2,\n      prevProps: {},\n      nextProps: this.props,\n      instance: directionsRenderer\n    });\n    this.setState(function setDirectionsRenderer() {\n      return {\n        directionsRenderer\n      };\n    }, this.setDirectionsRendererCallback);\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.directionsRenderer !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$2,\n        eventMap: eventMap$2,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.directionsRenderer\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.directionsRenderer !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.directionsRenderer);\n      }\n      unregisterEvents(this.registeredEvents);\n      if (this.state.directionsRenderer) {\n        this.state.directionsRenderer.setMap(null);\n      }\n    }\n  }\n  render() {\n    return null;\n  }\n}\n_defineProperty(DirectionsRenderer, \"contextType\", MapContext);\n\nclass DistanceMatrixService extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"state\", {\n      distanceMatrixService: null\n    });\n    _defineProperty(this, \"setDistanceMatrixServiceCallback\", () => {\n      if (this.state.distanceMatrixService !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.distanceMatrixService);\n      }\n    });\n  }\n  componentDidMount() {\n    invariant(!!this.props.options, 'DistanceMatrixService expected options object as parameter, but go %s', this.props.options);\n    var distanceMatrixService = new google.maps.DistanceMatrixService();\n    this.setState(function setDistanceMatrixService() {\n      return {\n        distanceMatrixService\n      };\n    }, this.setDistanceMatrixServiceCallback);\n  }\n  componentDidUpdate() {\n    if (this.state.distanceMatrixService !== null) {\n      this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.distanceMatrixService !== null && this.props.onUnmount) {\n      this.props.onUnmount(this.state.distanceMatrixService);\n    }\n  }\n  render() {\n    return null;\n  }\n}\n\nvar eventMap$1 = {\n  onPlacesChanged: 'places_changed'\n};\nvar updaterMap$1 = {\n  bounds(instance, bounds) {\n    instance.setBounds(bounds);\n  }\n};\nclass StandaloneSearchBox extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"containerElement\", (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)());\n    _defineProperty(this, \"state\", {\n      searchBox: null\n    });\n    _defineProperty(this, \"setSearchBoxCallback\", () => {\n      if (this.state.searchBox !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.searchBox);\n      }\n    });\n  }\n  componentDidMount() {\n    invariant(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n    if (this.containerElement !== null && this.containerElement.current !== null) {\n      var input = this.containerElement.current.querySelector('input');\n      if (input !== null) {\n        var searchBox = new google.maps.places.SearchBox(input, this.props.options);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n          updaterMap: updaterMap$1,\n          eventMap: eventMap$1,\n          prevProps: {},\n          nextProps: this.props,\n          instance: searchBox\n        });\n        this.setState(function setSearchBox() {\n          return {\n            searchBox\n          };\n        }, this.setSearchBoxCallback);\n      }\n    }\n  }\n  componentDidUpdate(prevProps) {\n    if (this.state.searchBox !== null) {\n      unregisterEvents(this.registeredEvents);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap: updaterMap$1,\n        eventMap: eventMap$1,\n        prevProps,\n        nextProps: this.props,\n        instance: this.state.searchBox\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this.state.searchBox !== null) {\n      if (this.props.onUnmount) {\n        this.props.onUnmount(this.state.searchBox);\n      }\n      unregisterEvents(this.registeredEvents);\n    }\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      ref: this.containerElement,\n      children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children)\n    });\n  }\n}\n_defineProperty(StandaloneSearchBox, \"contextType\", MapContext);\n\nvar eventMap = {\n  onPlaceChanged: 'place_changed'\n};\nvar updaterMap = {\n  bounds(instance, bounds) {\n    instance.setBounds(bounds);\n  },\n  restrictions(instance, restrictions) {\n    instance.setComponentRestrictions(restrictions);\n  },\n  fields(instance, fields) {\n    instance.setFields(fields);\n  },\n  options(instance, options) {\n    instance.setOptions(options);\n  },\n  types(instance, types) {\n    instance.setTypes(types);\n  }\n};\nclass Autocomplete extends react__WEBPACK_IMPORTED_MODULE_1__.PureComponent {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"registeredEvents\", []);\n    _defineProperty(this, \"containerElement\", (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)());\n    _defineProperty(this, \"state\", {\n      autocomplete: null\n    });\n    _defineProperty(this, \"setAutocompleteCallback\", () => {\n      if (this.state.autocomplete !== null && this.props.onLoad) {\n        this.props.onLoad(this.state.autocomplete);\n      }\n    });\n  }\n  componentDidMount() {\n    var _this$containerElemen;\n    invariant(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n    // TODO: why current could be equal null?\n    var input = (_this$containerElemen = this.containerElement.current) === null || _this$containerElemen === void 0 ? void 0 : _this$containerElemen.querySelector('input');\n    if (input) {\n      var autocomplete = new google.maps.places.Autocomplete(input, this.props.options);\n      this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n        updaterMap,\n        eventMap,\n        prevProps: {},\n        nextProps: this.props,\n        instance: autocomplete\n      });\n      this.setState(() => {\n        return {\n          autocomplete\n        };\n      }, this.setAutocompleteCallback);\n    }\n  }\n  componentDidUpdate(prevProps) {\n    unregisterEvents(this.registeredEvents);\n    this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n      updaterMap,\n      eventMap,\n      prevProps,\n      nextProps: this.props,\n      instance: this.state.autocomplete\n    });\n  }\n  componentWillUnmount() {\n    if (this.state.autocomplete !== null) {\n      unregisterEvents(this.registeredEvents);\n    }\n  }\n  render() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n      ref: this.containerElement,\n      className: this.props.className,\n      children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children)\n    });\n  }\n}\n_defineProperty(Autocomplete, \"defaultProps\", {\n  className: ''\n});\n_defineProperty(Autocomplete, \"contextType\", MapContext);\n\n\n//# sourceMappingURL=esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtZ29vZ2xlLW1hcHMvYXBpL2Rpc3QvZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDd0c7QUFDMUg7QUFDRzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBb0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixvREFBYTtBQUM5QjtBQUNBLGNBQWMsNkNBQVU7QUFDeEIsWUFBWSxpREFBVTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLHNEQUFHO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtB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LEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQUk7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVU7QUFDL0IscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFpRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1gsMEVBQTBFO0FBQzFFO0FBQ0EsS0FBSyxLQUFLO0FBQ1Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw4Q0FBTztBQUNuQixzQkFBc0IsMkNBQVE7QUFDOUIsV0FBVyxxREFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFZO0FBQ3pCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsU0FBUyxzREFBRyxDQUFDLHVEQUFRO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYywyQ0FBSTtBQUNsQixxQkFBcUIsZ0RBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQSxPQUFPLEtBQUs7QUFDWjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJDQUFRO0FBQ2pELFdBQVcscURBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtREFBWTtBQUN6QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9CQUFvQiw4REFBOEQsZ0VBQWdFLGtDQUFrQyxvQ0FBb0M7QUFDL1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsdUNBQXVDLHlDQUF5QyxvQ0FBb0MseUNBQXlDLDJDQUEyQywyQ0FBMkMsd0NBQXdDLG1EQUFtRCxvQkFBb0Isa0NBQWtDO0FBQzdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1QkFBdUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsMkJBQTJCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVELDJCQUEyQix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUN0UCw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCx3REFBd0QsOEJBQThCLHFKQUFxSixxRUFBcUUsS0FBSztBQUNsYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGdDQUFnQywrQ0FBUTtBQUN4QyxZQUFZLGlEQUFVO0FBQ3RCLDBDQUEwQywrQ0FBUTtBQUNsRCw4REFBOEQsK0NBQVE7QUFDdEUsMERBQTBELCtDQUFRO0FBQ2xFLGdEQUFnRCwrQ0FBUTtBQUN4RCxrREFBa0QsK0NBQVE7QUFDMUQsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFp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LHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxjQUFjO0FBQzFJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRCQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHNCQUFzQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYLDhFQUE4RSxrQ0FBa0M7QUFDaEg7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1gsNEVBQTRFLGNBQWM7QUFDMUY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLGdEQUFTO0FBQ1gsMEVBQTBFLGdDQUFnQztBQUMxRztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywyQ0FBSTtBQUNsQixxQkFBcUIsZ0RBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsZ0RBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsZ0RBQWE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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YXBpL2Rpc3QvZXNtLmpzPzEyMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIG1lbW8sIHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCwgUHVyZUNvbXBvbmVudCwgY3JlYXRlUmVmLCB1c2VNZW1vLCBDaGlsZHJlbiwgaXNWYWxpZEVsZW1lbnQsIGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMSAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgaW52YXJpYW50XzE7XG52YXIgaGFzUmVxdWlyZWRJbnZhcmlhbnQ7XG5mdW5jdGlvbiByZXF1aXJlSW52YXJpYW50KCkge1xuICBpZiAoaGFzUmVxdWlyZWRJbnZhcmlhbnQpIHJldHVybiBpbnZhcmlhbnRfMTtcbiAgaGFzUmVxdWlyZWRJbnZhcmlhbnQgPSAxO1xuXG4gIC8qKlxuICAgKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gICAqXG4gICAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gICAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICAgKiBleHBlY3RpbmcuXG4gICAqXG4gICAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gICAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAgICovXG5cbiAgdmFyIE5PREVfRU5WID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlY7XG4gIHZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpZiAoTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pKTtcbiAgICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgIH1cbiAgICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgaW52YXJpYW50XzEgPSBpbnZhcmlhbnQ7XG4gIHJldHVybiBpbnZhcmlhbnRfMTtcbn1cblxudmFyIGludmFyaWFudEV4cG9ydHMgPSByZXF1aXJlSW52YXJpYW50KCk7XG52YXIgaW52YXJpYW50ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoaW52YXJpYW50RXhwb3J0cyk7XG5cbnZhciBNYXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIHVzZUdvb2dsZU1hcCgpIHtcbiAgaW52YXJpYW50KCEhdXNlQ29udGV4dCwgJ3VzZUdvb2dsZU1hcCBpcyBSZWFjdCBob29rIGFuZCByZXF1aXJlcyBSZWFjdCB2ZXJzaW9uIDE2LjgrJyk7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICBpbnZhcmlhbnQoISFtYXAsICd1c2VHb29nbGVNYXAgbmVlZHMgYSBHb29nbGVNYXAgYXZhaWxhYmxlIHVwIGluIHRoZSB0cmVlJyk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBmbiwgYWNjKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiByZWR1Y2VyKG5ld0FjYywga2V5KSB7XG4gICAgcmV0dXJuIGZuKG5ld0FjYywgb2JqW2tleV0sIGtleSk7XG4gIH0sIGFjYyk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpO1xuICB9KTtcbn1cblxuLyogZ2xvYmFsIGdvb2dsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgZmlsZW5hbWVzL21hdGNoLXJlZ2V4ICovXG5mdW5jdGlvbiBhcHBseVVwZGF0ZXJUb05leHRQcm9wcyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG51cGRhdGVyTWFwLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByZXZQcm9wcyxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5uZXh0UHJvcHMsXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuaW5zdGFuY2Vcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgdmFyIG1hcCA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICB2YXIgaXRlciA9IChmbiwga2V5KSA9PiB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IG5leHRQcm9wc1trZXldO1xuICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZQcm9wc1trZXldKSB7XG4gICAgICBtYXBba2V5XSA9IG5leHRWYWx1ZTtcbiAgICAgIGZuKGluc3RhbmNlLCBuZXh0VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZm9yRWFjaCh1cGRhdGVyTWFwLCBpdGVyKTtcbiAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByb3BzLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmluc3RhbmNlLCBldmVudE1hcCkge1xuICB2YXIgcmVnaXN0ZXJlZExpc3QgPSByZWR1Y2UoZXZlbnRNYXAsIGZ1bmN0aW9uIHJlZHVjZXIoYWNjLCBnb29nbGVFdmVudE5hbWUsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIG9uRXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wc1tvbkV2ZW50TmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjYy5wdXNoKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBnb29nbGVFdmVudE5hbWUsIHByb3BzW29uRXZlbnROYW1lXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiByZWdpc3RlcmVkTGlzdDtcbn1cbmZ1bmN0aW9uIHVucmVnaXN0ZXJFdmVudChyZWdpc3RlcmVkKSB7XG4gIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlZ2lzdGVyZWQpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50cygpIHtcbiAgdmFyIGV2ZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG4gIGV2ZW50cy5mb3JFYWNoKHVucmVnaXN0ZXJFdmVudCk7XG59XG5mdW5jdGlvbiBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKF9yZWYpIHtcbiAgdmFyIHtcbiAgICB1cGRhdGVyTWFwLFxuICAgIGV2ZW50TWFwLFxuICAgIHByZXZQcm9wcyxcbiAgICBuZXh0UHJvcHMsXG4gICAgaW5zdGFuY2VcbiAgfSA9IF9yZWY7XG4gIHZhciByZWdpc3RlcmVkRXZlbnRzID0gcmVnaXN0ZXJFdmVudHMobmV4dFByb3BzLCBpbnN0YW5jZSwgZXZlbnRNYXApO1xuICBhcHBseVVwZGF0ZXJUb05leHRQcm9wcyh1cGRhdGVyTWFwLCBwcmV2UHJvcHMsIG5leHRQcm9wcywgaW5zdGFuY2UpO1xuICByZXR1cm4gcmVnaXN0ZXJlZEV2ZW50cztcbn1cblxudmFyIGV2ZW50TWFwJGkgPSB7XG4gIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICBvbkRyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIG9uTWFwVHlwZUlkQ2hhbmdlZDogJ21hcHR5cGVpZF9jaGFuZ2VkJyxcbiAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxuICBvblRpbGVzTG9hZGVkOiAndGlsZXNsb2FkZWQnLFxuICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgb25DbGljazogJ2NsaWNrJyxcbiAgb25EcmFnOiAnZHJhZycsXG4gIG9uSGVhZGluZ0NoYW5nZWQ6ICdoZWFkaW5nX2NoYW5nZWQnLFxuICBvbklkbGU6ICdpZGxlJyxcbiAgb25Qcm9qZWN0aW9uQ2hhbmdlZDogJ3Byb2plY3Rpb25fY2hhbmdlZCcsXG4gIG9uUmVzaXplOiAncmVzaXplJyxcbiAgb25UaWx0Q2hhbmdlZDogJ3RpbHRfY2hhbmdlZCcsXG4gIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnXG59O1xudmFyIHVwZGF0ZXJNYXAkaSA9IHtcbiAgZXh0cmFNYXBUeXBlcyhtYXAsIGV4dHJhKSB7XG4gICAgZXh0cmEuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoRXh0cmEoaXQsIGkpIHtcbiAgICAgIG1hcC5tYXBUeXBlcy5zZXQoU3RyaW5nKGkpLCBpdCk7XG4gICAgfSk7XG4gIH0sXG4gIGNlbnRlcihtYXAsIGNlbnRlcikge1xuICAgIG1hcC5zZXRDZW50ZXIoY2VudGVyKTtcbiAgfSxcbiAgY2xpY2thYmxlSWNvbnMobWFwLCBjbGlja2FibGUpIHtcbiAgICBtYXAuc2V0Q2xpY2thYmxlSWNvbnMoY2xpY2thYmxlKTtcbiAgfSxcbiAgaGVhZGluZyhtYXAsIGhlYWRpbmcpIHtcbiAgICBtYXAuc2V0SGVhZGluZyhoZWFkaW5nKTtcbiAgfSxcbiAgbWFwVHlwZUlkKG1hcCwgbWFwVHlwZUlkKSB7XG4gICAgbWFwLnNldE1hcFR5cGVJZChtYXBUeXBlSWQpO1xuICB9LFxuICBvcHRpb25zKG1hcCwgb3B0aW9ucykge1xuICAgIG1hcC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBzdHJlZXRWaWV3KG1hcCwgc3RyZWV0Vmlldykge1xuICAgIG1hcC5zZXRTdHJlZXRWaWV3KHN0cmVldFZpZXcpO1xuICB9LFxuICB0aWx0KG1hcCwgdGlsdCkge1xuICAgIG1hcC5zZXRUaWx0KHRpbHQpO1xuICB9LFxuICB6b29tKG1hcCwgem9vbSkge1xuICAgIG1hcC5zZXRab29tKHpvb20pO1xuICB9XG59O1xuLy8gVE9ETzogdW5maW5pc2hlZCFcbmZ1bmN0aW9uIEdvb2dsZU1hcEZ1bmN0aW9uYWwoX3JlZikge1xuICB2YXIge1xuICAgIGNoaWxkcmVuLFxuICAgIG9wdGlvbnMsXG4gICAgaWQsXG4gICAgbWFwQ29udGFpbmVyU3R5bGUsXG4gICAgbWFwQ29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIGNlbnRlcixcbiAgICAvLyBjbGlja2FibGVJY29ucyxcbiAgICAvLyBleHRyYU1hcFR5cGVzLFxuICAgIC8vIGhlYWRpbmcsXG4gICAgLy8gbWFwVHlwZUlkLFxuICAgIG9uQ2xpY2ssXG4gICAgb25EYmxDbGljayxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uTW91c2VNb3ZlLFxuICAgIG9uTW91c2VPdXQsXG4gICAgb25Nb3VzZU92ZXIsXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Nb3VzZVVwLFxuICAgIG9uUmlnaHRDbGljayxcbiAgICAvLyBvbk1hcFR5cGVJZENoYW5nZWQsXG4gICAgLy8gb25UaWxlc0xvYWRlZCxcbiAgICAvLyBvbkJvdW5kc0NoYW5nZWQsXG4gICAgb25DZW50ZXJDaGFuZ2VkLFxuICAgIC8vIG9uSGVhZGluZ0NoYW5nZWQsXG4gICAgLy8gb25JZGxlLFxuICAgIC8vIG9uUHJvamVjdGlvbkNoYW5nZWQsXG4gICAgLy8gb25SZXNpemUsXG4gICAgLy8gb25UaWx0Q2hhbmdlZCxcbiAgICAvLyBvblpvb21DaGFuZ2VkLFxuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBbbWFwLCBzZXRNYXBdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIC8vIGNvbnN0IFtleHRyYU1hcFR5cGVzTGlzdGVuZXIsIHNldEV4dHJhTWFwVHlwZXNMaXN0ZW5lcl0gPSB1c2VTdGF0ZTxnb29nbGUubWFwcy5NYXBzRXZlbnRMaXN0ZW5lciB8IG51bGw+KG51bGwpXG4gIHZhciBbY2VudGVyQ2hhbmdlZExpc3RlbmVyLCBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZGJsY2xpY2tMaXN0ZW5lciwgc2V0RGJsY2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnZW5kTGlzdGVuZXIsIHNldERyYWdlbmRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnc3RhcnRMaXN0ZW5lciwgc2V0RHJhZ3N0YXJ0TGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2Vkb3duTGlzdGVuZXIsIHNldE1vdXNlZG93bkxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlbW92ZUxpc3RlbmVyLCBzZXRNb3VzZW1vdmVMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW91dExpc3RlbmVyLCBzZXRNb3VzZW91dExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlb3Zlckxpc3RlbmVyLCBzZXRNb3VzZW92ZXJMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZXVwTGlzdGVuZXIsIHNldE1vdXNldXBMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtyaWdodGNsaWNrTGlzdGVuZXIsIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjbGlja0xpc3RlbmVyLCBzZXRDbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RyYWdMaXN0ZW5lciwgc2V0RHJhZ0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvcHRpb25zICYmIG1hcCAhPT0gbnVsbCkge1xuICAgICAgbWFwLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbbWFwLCBvcHRpb25zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCAhPT0gbnVsbCAmJiB0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbWFwLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH1cbiAgfSwgW21hcCwgY2VudGVyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCAmJiBvbkRibENsaWNrKSB7XG4gICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25EYmxDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25EcmFnRW5kKSB7XG4gICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgIH1cbiAgfSwgW29uRHJhZ0VuZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgIH1cbiAgfSwgW29uRHJhZ1N0YXJ0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCAmJiBvbk1vdXNlRG93bikge1xuICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZURvd25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlTW92ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25Nb3VzZU91dCkge1xuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VPdXRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25Nb3VzZVVwKSB7XG4gICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNldXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VVcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgIH1cbiAgfSwgW29uUmlnaHRDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb25DbGljaykge1xuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwICYmIG9uRHJhZykge1xuICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwICYmIG9uQ2VudGVyQ2hhbmdlZCkge1xuICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjZW50ZXJDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2VudGVyQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2NlbnRlcl9jaGFuZ2VkJywgb25DZW50ZXJDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25DbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBtYXAgPSByZWYuY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBuZXcgZ29vZ2xlLm1hcHMuTWFwKHJlZi5jdXJyZW50LCBvcHRpb25zKTtcbiAgICBzZXRNYXAobWFwKTtcbiAgICBpZiAobWFwICE9PSBudWxsICYmIG9uTG9hZCkge1xuICAgICAgb25Mb2FkKG1hcCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICBvblVubW91bnQobWFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgaWQ6IGlkLFxuICAgIHJlZjogcmVmLFxuICAgIHN0eWxlOiBtYXBDb250YWluZXJTdHlsZSxcbiAgICBjbGFzc05hbWU6IG1hcENvbnRhaW5lckNsYXNzTmFtZSxcbiAgICBjaGlsZHJlbjoganN4KE1hcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBtYXAsXG4gICAgICBjaGlsZHJlbjogbWFwICE9PSBudWxsID8gY2hpbGRyZW4gOiBudWxsXG4gICAgfSlcbiAgfSk7XG59XG5tZW1vKEdvb2dsZU1hcEZ1bmN0aW9uYWwpO1xuY2xhc3MgR29vZ2xlTWFwIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgbWFwOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwUmVmXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEluc3RhbmNlXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm1hcFJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTWFwKHRoaXMubWFwUmVmLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBhblRvXCIsIGxhdExuZyA9PiB7XG4gICAgICB2YXIgbWFwID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgaWYgKG1hcCkge1xuICAgICAgICBtYXAucGFuVG8obGF0TG5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRNYXBDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5tYXAgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5tYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0UmVmXCIsIHJlZiA9PiB7XG4gICAgICB0aGlzLm1hcFJlZiA9IHJlZjtcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRpLFxuICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGksXG4gICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgaW5zdGFuY2U6IG1hcFxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TWFwKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWFwXG4gICAgICB9O1xuICAgIH0sIHRoaXMuc2V0TWFwQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5tYXAgIT09IG51bGwpIHtcbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGksXG4gICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRpLFxuICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUubWFwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubWFwICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5tYXApO1xuICAgICAgfVxuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgICBpZDogdGhpcy5wcm9wcy5pZCxcbiAgICAgIHJlZjogdGhpcy5nZXRSZWYsXG4gICAgICBzdHlsZTogdGhpcy5wcm9wcy5tYXBDb250YWluZXJTdHlsZSxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5tYXBDb250YWluZXJDbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbjoganN4KE1hcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuc3RhdGUubWFwLFxuICAgICAgICBjaGlsZHJlbjogdGhpcy5zdGF0ZS5tYXAgIT09IG51bGwgPyB0aGlzLnByb3BzLmNoaWxkcmVuIDogbnVsbFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAobiwgdCwgZSwgciwgbywgYSwgYykge1xuICB0cnkge1xuICAgIHZhciBpID0gblthXShjKSxcbiAgICAgIHUgPSBpLnZhbHVlO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuIHZvaWQgZShuKTtcbiAgfVxuICBpLmRvbmUgPyB0KHUpIDogUHJvbWlzZS5yZXNvbHZlKHUpLnRoZW4ociwgbyk7XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgZSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHIsIG8pIHtcbiAgICAgIHZhciBhID0gbi5hcHBseSh0LCBlKTtcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KG4pIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGEsIHIsIG8sIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCBuKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhuKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIG4pO1xuICAgICAgfVxuICAgICAgX25leHQodm9pZCAwKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUxvYWRTY3JpcHRVcmwoX3JlZikge1xuICB2YXIge1xuICAgIGdvb2dsZU1hcHNBcGlLZXksXG4gICAgZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgIHZlcnNpb24gPSAnd2Vla2x5JyxcbiAgICBsYW5ndWFnZSxcbiAgICByZWdpb24sXG4gICAgbGlicmFyaWVzLFxuICAgIGNoYW5uZWwsXG4gICAgbWFwSWRzLFxuICAgIGF1dGhSZWZlcnJlclBvbGljeVxuICB9ID0gX3JlZjtcbiAgdmFyIHBhcmFtcyA9IFtdO1xuICBpbnZhcmlhbnQoZ29vZ2xlTWFwc0FwaUtleSAmJiBnb29nbGVNYXBzQ2xpZW50SWQgfHwgIShnb29nbGVNYXBzQXBpS2V5ICYmIGdvb2dsZU1hcHNDbGllbnRJZCksICdZb3UgbmVlZCB0byBzcGVjaWZ5IGVpdGhlciBnb29nbGVNYXBzQXBpS2V5IG9yIGdvb2dsZU1hcHNDbGllbnRJZCBmb3IgQHJlYWN0LWdvb2dsZS1tYXBzL2FwaSBsb2FkIHNjcmlwdCB0byB3b3JrLiBZb3UgY2Fubm90IHVzZSBib3RoIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gIGlmIChnb29nbGVNYXBzQXBpS2V5KSB7XG4gICAgcGFyYW1zLnB1c2goXCJrZXk9XCIuY29uY2F0KGdvb2dsZU1hcHNBcGlLZXkpKTtcbiAgfSBlbHNlIGlmIChnb29nbGVNYXBzQ2xpZW50SWQpIHtcbiAgICBwYXJhbXMucHVzaChcImNsaWVudD1cIi5jb25jYXQoZ29vZ2xlTWFwc0NsaWVudElkKSk7XG4gIH1cbiAgaWYgKHZlcnNpb24pIHtcbiAgICBwYXJhbXMucHVzaChcInY9XCIuY29uY2F0KHZlcnNpb24pKTtcbiAgfVxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICBwYXJhbXMucHVzaChcImxhbmd1YWdlPVwiLmNvbmNhdChsYW5ndWFnZSkpO1xuICB9XG4gIGlmIChyZWdpb24pIHtcbiAgICBwYXJhbXMucHVzaChcInJlZ2lvbj1cIi5jb25jYXQocmVnaW9uKSk7XG4gIH1cbiAgaWYgKGxpYnJhcmllcyAmJiBsaWJyYXJpZXMubGVuZ3RoKSB7XG4gICAgcGFyYW1zLnB1c2goXCJsaWJyYXJpZXM9XCIuY29uY2F0KGxpYnJhcmllcy5zb3J0KCkuam9pbignLCcpKSk7XG4gIH1cbiAgaWYgKGNoYW5uZWwpIHtcbiAgICBwYXJhbXMucHVzaChcImNoYW5uZWw9XCIuY29uY2F0KGNoYW5uZWwpKTtcbiAgfVxuICBpZiAobWFwSWRzICYmIG1hcElkcy5sZW5ndGgpIHtcbiAgICBwYXJhbXMucHVzaChcIm1hcF9pZHM9XCIuY29uY2F0KG1hcElkcy5qb2luKCcsJykpKTtcbiAgfVxuICBpZiAoYXV0aFJlZmVycmVyUG9saWN5KSB7XG4gICAgcGFyYW1zLnB1c2goXCJhdXRoX3JlZmVycmVyX3BvbGljeT1cIi5jb25jYXQoYXV0aFJlZmVycmVyUG9saWN5KSk7XG4gIH1cbiAgcGFyYW1zLnB1c2goJ2xvYWRpbmc9YXN5bmMnKTtcbiAgcGFyYW1zLnB1c2goJ2NhbGxiYWNrPWluaXRNYXAnKTtcbiAgcmV0dXJuIFwiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP1wiLmNvbmNhdChwYXJhbXMuam9pbignJicpKTtcbn1cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmZ1bmN0aW9uIGluamVjdFNjcmlwdChfcmVmKSB7XG4gIHZhciB7XG4gICAgdXJsLFxuICAgIGlkLFxuICAgIG5vbmNlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgfSA9IF9yZWY7XG4gIGlmICghaXNCcm93c2VyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignZG9jdW1lbnQgaXMgdW5kZWZpbmVkJykpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBpbmplY3RTY3JpcHRDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgZXhpc3RpbmdTY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgdmFyIHdpbmRvd1dpdGhHb29nbGVNYXAgPSB3aW5kb3c7XG4gICAgaWYgKGV4aXN0aW5nU2NyaXB0KSB7XG4gICAgICAvLyBTYW1lIHNjcmlwdCBpZC91cmw6IGtlZXAgc2FtZSBzY3JpcHRcbiAgICAgIHZhciBkYXRhU3RhdGVBdHRyaWJ1dGUgPSBleGlzdGluZ1NjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhdGUnKTtcbiAgICAgIGlmIChleGlzdGluZ1NjcmlwdC5zcmMgPT09IHVybCAmJiBkYXRhU3RhdGVBdHRyaWJ1dGUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgaWYgKGRhdGFTdGF0ZUF0dHJpYnV0ZSA9PT0gJ3JlYWR5Jykge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxJbml0TWFwID0gd2luZG93V2l0aEdvb2dsZU1hcC5pbml0TWFwO1xuICAgICAgICAgIHZhciBvcmlnaW5hbEVycm9yQ2FsbGJhY2sgPSBleGlzdGluZ1NjcmlwdC5vbmVycm9yO1xuICAgICAgICAgIHdpbmRvd1dpdGhHb29nbGVNYXAuaW5pdE1hcCA9IGZ1bmN0aW9uIGluaXRNYXAoKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxJbml0TWFwKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsSW5pdE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShpZCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBleGlzdGluZ1NjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTYW1lIHNjcmlwdCBpZCwgYnV0IGVpdGhlclxuICAgICAgLy8gMS4gcmVxdWVzdGVkIFVSTCBpcyBkaWZmZXJlbnRcbiAgICAgIC8vIDIuIHNjcmlwdCBmYWlsZWQgdG8gbG9hZFxuICAgICAgZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nU2NyaXB0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgIHNjcmlwdC5pZCA9IGlkO1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgc2NyaXB0Lm5vbmNlID0gbm9uY2UgfHwgJyc7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdlcnJvcicpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfTtcbiAgICB3aW5kb3dXaXRoR29vZ2xlTWFwLmluaXRNYXAgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ3JlYWR5Jyk7XG4gICAgICByZXNvbHZlKGlkKTtcbiAgICB9O1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBjb25zb2xlLmVycm9yKCdpbmplY3RTY3JpcHQgZXJyb3I6ICcsIGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNHb29nbGVGb250U3R5bGUoZWxlbWVudCkge1xuICAvLyAnUm9ib3RvJyBvciAnR29vZ2xlIFNhbnMgVGV4dCcgZm9udCBkb3dubG9hZFxuICB2YXIgaHJlZiA9IGVsZW1lbnQuaHJlZjtcbiAgaWYgKGhyZWYgJiYgKGhyZWYuaW5kZXhPZignaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bycpID09PSAwIHx8IGhyZWYuaW5kZXhPZignaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PUdvb2dsZStTYW5zK1RleHQnKSA9PT0gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBmb250IHN0eWxlIGVsZW1lbnRzXG4gIGlmIChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBlbGVtZW50LnN0eWxlU2hlZXQgJiZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ICYmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBlbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dC5yZXBsYWNlKCdcXHJcXG4nLCAnJykuaW5kZXhPZignLmdtLXN0eWxlJykgPT09IDApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gJyc7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gZm9udCBzdHlsZSBlbGVtZW50cyBmb3Igb3RoZXIgYnJvd3NlcnNcbiAgaWYgKFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdHlsZScgJiZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGVsZW1lbnQuaW5uZXJIVE1MICYmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKCdcXHJcXG4nLCAnJykuaW5kZXhPZignLmdtLXN0eWxlJykgPT09IDApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gd2hlbiBnb29nbGUgdHJpZXMgdG8gYWRkIGVtcHR5IHN0eWxlXG4gIGlmIChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAhZWxlbWVudC5zdHlsZVNoZWV0ICYmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICAhZWxlbWVudC5pbm5lckhUTUwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyBQcmV2ZW50aW5nIHRoZSBHb29nbGUgTWFwcyBsaWJyYXJ5IGZyb20gZG93bmxvYWRpbmcgYW4gZXh0cmEgZm9udFxuZnVuY3Rpb24gcHJldmVudEdvb2dsZUZvbnRzKCkge1xuICAvLyB3ZSBvdmVycmlkZSB0aGVzZSBtZXRob2RzIG9ubHkgZm9yIG9uZSBwYXJ0aWN1bGFyIGhlYWQgZWxlbWVudFxuICAvLyBkZWZhdWx0IG1ldGhvZHMgZm9yIG90aGVyIGVsZW1lbnRzIGFyZSBub3QgYWZmZWN0ZWRcbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBpZiAoaGVhZCkge1xuICAgIHZhciB0cnVlSW5zZXJ0QmVmb3JlID0gaGVhZC5pbnNlcnRCZWZvcmUuYmluZChoZWFkKTtcbiAgICAvLyBUT0RPOiBhZGRpbmcgcmV0dXJuIGJlZm9yZSByZWZsZWN0IHNvbHZlcyB0aGUgVFMgaXNzdWVcbiAgICBoZWFkLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIGluc2VydEJlZm9yZShuZXdFbGVtZW50LCByZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICBpZiAoIWlzR29vZ2xlRm9udFN0eWxlKG5ld0VsZW1lbnQpKSB7XG4gICAgICAgIFJlZmxlY3QuYXBwbHkodHJ1ZUluc2VydEJlZm9yZSwgaGVhZCwgW25ld0VsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgIH07XG4gICAgdmFyIHRydWVBcHBlbmQgPSBoZWFkLmFwcGVuZENoaWxkLmJpbmQoaGVhZCk7XG4gICAgLy8gVE9ETzogYWRkaW5nIHJldHVybiBiZWZvcmUgcmVmbGVjdCBzb2x2ZXMgdGhlIFRTIGlzc3VlXG4gICAgaGVhZC5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkKHRleHROb2RlKSB7XG4gICAgICBpZiAoIWlzR29vZ2xlRm9udFN0eWxlKHRleHROb2RlKSkge1xuICAgICAgICBSZWZsZWN0LmFwcGx5KHRydWVBcHBlbmQsIGhlYWQsIFt0ZXh0Tm9kZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGNsZWFuaW5nVXAgPSBmYWxzZTtcbmZ1bmN0aW9uIERlZmF1bHRMb2FkaW5nRWxlbWVudCgpIHtcbiAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiTG9hZGluZy4uLlwiXG4gIH0pO1xufVxudmFyIGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMgPSB7XG4gIGlkOiAnc2NyaXB0LWxvYWRlcicsXG4gIHZlcnNpb246ICd3ZWVrbHknXG59O1xuY2xhc3MgTG9hZFNjcmlwdCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoZWNrXCIsIGNyZWF0ZVJlZigpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBsb2FkZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xlYW51cENhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlbGV0ZSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICB0aGlzLmluamVjdFNjcmlwdCgpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzQ2xlYW5pbmdVcFwiLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGZ1bmN0aW9uIHByb21pc2VDYWxsYmFjayhyZXNvbHZlKSB7XG4gICAgICAgIGlmICghY2xlYW5pbmdVcCkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gaW50ZXJ2YWwoKSB7XG4gICAgICAgICAgICAgIGlmICghY2xlYW5pbmdVcCkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocHJvbWlzZUNhbGxiYWNrKTtcbiAgICB9KSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xlYW51cFwiLCAoKSA9PiB7XG4gICAgICBjbGVhbmluZ1VwID0gdHJ1ZTtcbiAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnByb3BzLmlkKTtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgIH1cbiAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSkuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlcihzY3JpcHQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzY3JpcHQuc3JjID09PSAnc3RyaW5nJyAmJiBzY3JpcHQuc3JjLmluY2x1ZGVzKCdtYXBzLmdvb2dsZWFwaXMnKTtcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChzY3JpcHQpIHtcbiAgICAgICAgaWYgKHNjcmlwdC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpKS5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyKGxpbmspIHtcbiAgICAgICAgcmV0dXJuIGxpbmsuaHJlZiA9PT0gJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG86MzAwLDQwMCw1MDAsNzAwfEdvb2dsZStTYW5zJztcbiAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChsaW5rKSB7XG4gICAgICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJykpLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIoc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmlubmVyVGV4dCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlLmlubmVyVGV4dC5sZW5ndGggPiAwICYmIHN0eWxlLmlubmVyVGV4dC5pbmNsdWRlcygnLmdtLScpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoKHN0eWxlKSB7XG4gICAgICAgIGlmIChzdHlsZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluamVjdFNjcmlwdFwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5wcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nKSB7XG4gICAgICAgIHByZXZlbnRHb29nbGVGb250cygpO1xuICAgICAgfVxuICAgICAgaW52YXJpYW50KCEhdGhpcy5wcm9wcy5pZCwgJ0xvYWRTY3JpcHQgcmVxdWlyZXMgXCJpZFwiIHByb3AgdG8gYmUgYSBzdHJpbmc6ICVzJywgdGhpcy5wcm9wcy5pZCk7XG4gICAgICB2YXIgaW5qZWN0U2NyaXB0T3B0aW9ucyA9IHtcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIG5vbmNlOiB0aGlzLnByb3BzLm5vbmNlLFxuICAgICAgICB1cmw6IG1ha2VMb2FkU2NyaXB0VXJsKHRoaXMucHJvcHMpXG4gICAgICB9O1xuICAgICAgaW5qZWN0U2NyaXB0KGluamVjdFNjcmlwdE9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG9hZGVkKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2FkZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgICAgIHRoaXMucHJvcHMub25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcXG4gICAgICAgICAgVGhlcmUgaGFzIGJlZW4gYW4gRXJyb3Igd2l0aCBsb2FkaW5nIEdvb2dsZSBNYXBzIEFQSSBzY3JpcHQsIHBsZWFzZSBjaGVjayB0aGF0IHlvdSBwcm92aWRlZCBjb3JyZWN0IGdvb2dsZSBBUEkga2V5IChcIi5jb25jYXQodGhpcy5wcm9wcy5nb29nbGVNYXBzQXBpS2V5IHx8ICctJywgXCIpIG9yIENsaWVudCBJRCAoXCIpLmNvbmNhdCh0aGlzLnByb3BzLmdvb2dsZU1hcHNDbGllbnRJZCB8fCAnLScsIFwiKSB0byA8TG9hZFNjcmlwdCAvPlxcbiAgICAgICAgICBPdGhlcndpc2UgaXQgaXMgYSBOZXR3b3JrIGlzc3VlLlxcbiAgICAgICAgXCIpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcyAmJiAhY2xlYW5pbmdVcCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdnb29nbGUgYXBpIGlzIGFscmVhZHkgcHJlc2VudGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNDbGVhbmluZ1VwKCkudGhlbih0aGlzLmluamVjdFNjcmlwdCkuY2F0Y2goZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF0IGluamVjdGluZyBzY3JpcHQgYWZ0ZXIgY2xlYW5pbmcgdXA6ICcsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnByb3BzLmxpYnJhcmllcyAhPT0gcHJldlByb3BzLmxpYnJhcmllcykge1xuICAgICAgY29uc29sZS53YXJuKCdQZXJmb3JtYW5jZSB3YXJuaW5nISBMb2FkU2NyaXB0IGhhcyBiZWVuIHJlbG9hZGVkIHVuaW50ZW50aW9uYWxseSEgWW91IHNob3VsZCBub3QgcGFzcyBgbGlicmFyaWVzYCBwcm9wIGFzIG5ldyBhcnJheS4gUGxlYXNlIGtlZXAgYW4gYXJyYXkgb2YgbGlicmFyaWVzIGFzIHN0YXRpYyBjbGFzcyBwcm9wZXJ0eSBmb3IgQ29tcG9uZW50cyBhbmQgUHVyZUNvbXBvbmVudHMsIG9yIGp1c3QgYSBjb25zdCB2YXJpYWJsZSBvdXRzaWRlIG9mIGNvbXBvbmVudCwgb3Igc29tZXdoZXJlIGluIGNvbmZpZyBmaWxlcyBvciBFTlYgdmFyaWFibGVzJyk7XG4gICAgfVxuICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldlByb3BzLmxhbmd1YWdlICE9PSB0aGlzLnByb3BzLmxhbmd1YWdlKSB7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHVzZSBnRFNGUCBtYXliZS4uLiB3YWl0IGZvciBob29rcyByZWZhY3RvcmluZy5cbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG9hZGVkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvYWRlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMuY2xlYW51cENhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB2YXIgdGltZW91dENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2suY3VycmVudCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgZGVsZXRlIHdpbmRvdy5nb29nbGU7XG4gICAgICAgICAgY2xlYW5pbmdVcCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LnNldFRpbWVvdXQodGltZW91dENhbGxiYWNrLCAxKTtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGpzeHMoRnJhZ21lbnQsIHtcbiAgICAgIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiB0aGlzLmNoZWNrXG4gICAgICB9KSwgdGhpcy5zdGF0ZS5sb2FkZWQgPyB0aGlzLnByb3BzLmNoaWxkcmVuIDogdGhpcy5wcm9wcy5sb2FkaW5nRWxlbWVudCB8fCBqc3goRGVmYXVsdExvYWRpbmdFbGVtZW50LCB7fSldXG4gICAgfSk7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShMb2FkU2NyaXB0LCBcImRlZmF1bHRQcm9wc1wiLCBkZWZhdWx0TG9hZFNjcmlwdFByb3BzKTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoZS5pbmNsdWRlcyhuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBzLmxlbmd0aDsgcisrKSBvID0gc1tyXSwgdC5pbmNsdWRlcyhvKSB8fCB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIGZpbGVuYW1lcy9tYXRjaC1yZWdleCAqL1xudmFyIHByZXZpb3VzbHlMb2FkZWRVcmw7XG5mdW5jdGlvbiB1c2VMb2FkU2NyaXB0KF9yZWYpIHtcbiAgdmFyIHtcbiAgICBpZCA9IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMuaWQsXG4gICAgdmVyc2lvbiA9IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMudmVyc2lvbixcbiAgICBub25jZSxcbiAgICBnb29nbGVNYXBzQXBpS2V5LFxuICAgIGdvb2dsZU1hcHNDbGllbnRJZCxcbiAgICBsYW5ndWFnZSxcbiAgICByZWdpb24sXG4gICAgbGlicmFyaWVzLFxuICAgIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcsXG4gICAgY2hhbm5lbCxcbiAgICBtYXBJZHMsXG4gICAgYXV0aFJlZmVycmVyUG9saWN5XG4gIH0gPSBfcmVmO1xuICB2YXIgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIFtpc0xvYWRlZCwgc2V0TG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIFtsb2FkRXJyb3IsIHNldExvYWRFcnJvcl0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gdHJhY2tNb3VudGVkU3RhdGUoKSB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIGFwcGx5UHJldmVudEdvb2dsZUZvbnRzKCkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgfVxuICB9LCBbcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZ10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gdmFsaWRhdGVMb2FkZWRTdGF0ZSgpIHtcbiAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgIGludmFyaWFudCghIXdpbmRvdy5nb29nbGUsICd1c2VMb2FkU2NyaXB0IHdhcyBtYXJrZWQgYXMgbG9hZGVkLCBidXQgd2luZG93Lmdvb2dsZSBpcyBub3QgcHJlc2VudC4gU29tZXRoaW5nIHdlbnQgd3JvbmcuJyk7XG4gICAgfVxuICB9LCBbaXNMb2FkZWRdKTtcbiAgdmFyIHVybCA9IG1ha2VMb2FkU2NyaXB0VXJsKHtcbiAgICB2ZXJzaW9uLFxuICAgIGdvb2dsZU1hcHNBcGlLZXksXG4gICAgZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgIGxhbmd1YWdlLFxuICAgIHJlZ2lvbixcbiAgICBsaWJyYXJpZXMsXG4gICAgY2hhbm5lbCxcbiAgICBtYXBJZHMsXG4gICAgYXV0aFJlZmVycmVyUG9saWN5XG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gbG9hZFNjcmlwdEFuZE1vZGlmeUxvYWRlZFN0YXRlKCkge1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldExvYWRlZElmTW91bnRlZCgpIHtcbiAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgIHByZXZpb3VzbHlMb2FkZWRVcmwgPSB1cmw7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcyAmJiBwcmV2aW91c2x5TG9hZGVkVXJsID09PSB1cmwpIHtcbiAgICAgIHNldExvYWRlZElmTW91bnRlZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmplY3RTY3JpcHQoe1xuICAgICAgaWQsXG4gICAgICB1cmwsXG4gICAgICBub25jZVxuICAgIH0pLnRoZW4oc2V0TG9hZGVkSWZNb3VudGVkKS5jYXRjaChmdW5jdGlvbiBoYW5kbGVJbmplY3RFcnJvcihlcnIpIHtcbiAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICBzZXRMb2FkRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUud2FybihcIlxcbiAgICAgICAgVGhlcmUgaGFzIGJlZW4gYW4gRXJyb3Igd2l0aCBsb2FkaW5nIEdvb2dsZSBNYXBzIEFQSSBzY3JpcHQsIHBsZWFzZSBjaGVjayB0aGF0IHlvdSBwcm92aWRlZCBjb3JyZWN0IGdvb2dsZSBBUEkga2V5IChcIi5jb25jYXQoZ29vZ2xlTWFwc0FwaUtleSB8fCAnLScsIFwiKSBvciBDbGllbnQgSUQgKFwiKS5jb25jYXQoZ29vZ2xlTWFwc0NsaWVudElkIHx8ICctJywgXCIpXFxuICAgICAgICBPdGhlcndpc2UgaXQgaXMgYSBOZXR3b3JrIGlzc3VlLlxcbiAgICAgIFwiKSk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSk7XG4gIH0sIFtpZCwgdXJsLCBub25jZV0pO1xuICB2YXIgcHJldkxpYnJhcmllcyA9IHVzZVJlZigpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gY2hlY2tQZXJmb3JtYW5jZSgpIHtcbiAgICBpZiAocHJldkxpYnJhcmllcy5jdXJyZW50ICYmIGxpYnJhcmllcyAhPT0gcHJldkxpYnJhcmllcy5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIHdhcm5pbmchIExvYWRTY3JpcHQgaGFzIGJlZW4gcmVsb2FkZWQgdW5pbnRlbnRpb25hbGx5ISBZb3Ugc2hvdWxkIG5vdCBwYXNzIGBsaWJyYXJpZXNgIHByb3AgYXMgbmV3IGFycmF5LiBQbGVhc2Uga2VlcCBhbiBhcnJheSBvZiBsaWJyYXJpZXMgYXMgc3RhdGljIGNsYXNzIHByb3BlcnR5IGZvciBDb21wb25lbnRzIGFuZCBQdXJlQ29tcG9uZW50cywgb3IganVzdCBhIGNvbnN0IHZhcmlhYmxlIG91dHNpZGUgb2YgY29tcG9uZW50LCBvciBzb21ld2hlcmUgaW4gY29uZmlnIGZpbGVzIG9yIEVOViB2YXJpYWJsZXMnKTtcbiAgICB9XG4gICAgcHJldkxpYnJhcmllcy5jdXJyZW50ID0gbGlicmFyaWVzO1xuICB9LCBbbGlicmFyaWVzXSk7XG4gIHJldHVybiB7XG4gICAgaXNMb2FkZWQsXG4gICAgbG9hZEVycm9yLFxuICAgIHVybFxuICB9O1xufVxuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJsb2FkaW5nRWxlbWVudFwiLCBcIm9uTG9hZFwiLCBcIm9uRXJyb3JcIiwgXCJvblVubW91bnRcIiwgXCJjaGlsZHJlblwiXTtcbnZhciBkZWZhdWx0TG9hZGluZ0VsZW1lbnQgPSBqc3goRGVmYXVsdExvYWRpbmdFbGVtZW50LCB7fSk7XG5mdW5jdGlvbiBMb2FkU2NyaXB0TmV4dChfcmVmKSB7XG4gIHZhciB7XG4gICAgICBsb2FkaW5nRWxlbWVudCxcbiAgICAgIG9uTG9hZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBvblVubW91bnQsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBfcmVmLFxuICAgIGhvb2tPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCQxKTtcbiAgdmFyIHtcbiAgICBpc0xvYWRlZCxcbiAgICBsb2FkRXJyb3JcbiAgfSA9IHVzZUxvYWRTY3JpcHQoaG9va09wdGlvbnMpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gaGFuZGxlT25Mb2FkKCkge1xuICAgIGlmIChpc0xvYWRlZCAmJiB0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkxvYWQoKTtcbiAgICB9XG4gIH0sIFtpc0xvYWRlZCwgb25Mb2FkXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiBoYW5kbGVPbkVycm9yKCkge1xuICAgIGlmIChsb2FkRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uRXJyb3IobG9hZEVycm9yKTtcbiAgICB9XG4gIH0sIFtsb2FkRXJyb3IsIG9uRXJyb3JdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uIGhhbmRsZU9uVW5tb3VudCgpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICBvblVubW91bnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbb25Vbm1vdW50XSk7XG4gIHJldHVybiBpc0xvYWRlZCA/IGNoaWxkcmVuIDogbG9hZGluZ0VsZW1lbnQgfHwgZGVmYXVsdExvYWRpbmdFbGVtZW50O1xufVxudmFyIExvYWRTY3JpcHROZXh0JDEgPSBtZW1vKExvYWRTY3JpcHROZXh0KTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cblxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoeCkge1xuICByZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxudmFyIGZhc3REZWVwRXF1YWwkMSA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufTtcbnZhciBpc0VxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhc3REZWVwRXF1YWwkMSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0LlxuICpcbiAqICAgICAgSHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wLlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBERUZBVUxUX0lEID0gXCJfX2dvb2dsZU1hcHNTY3JpcHRJZFwiO1xuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSBbW0xvYWRlcl1dLlxuICovXG52YXIgTG9hZGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChMb2FkZXJTdGF0dXMpIHtcbiAgTG9hZGVyU3RhdHVzW0xvYWRlclN0YXR1c1tcIklOSVRJQUxJWkVEXCJdID0gMF0gPSBcIklOSVRJQUxJWkVEXCI7XG4gIExvYWRlclN0YXR1c1tMb2FkZXJTdGF0dXNbXCJMT0FESU5HXCJdID0gMV0gPSBcIkxPQURJTkdcIjtcbiAgTG9hZGVyU3RhdHVzW0xvYWRlclN0YXR1c1tcIlNVQ0NFU1NcIl0gPSAyXSA9IFwiU1VDQ0VTU1wiO1xuICBMb2FkZXJTdGF0dXNbTG9hZGVyU3RhdHVzW1wiRkFJTFVSRVwiXSA9IDNdID0gXCJGQUlMVVJFXCI7XG59KShMb2FkZXJTdGF0dXMgfHwgKExvYWRlclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFtbTG9hZGVyXV0gbWFrZXMgaXQgZWFzaWVyIHRvIGFkZCBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSB0byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBkeW5hbWljYWxseSB1c2luZ1xuICogW1Byb21pc2VzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm9taXNlKS5cbiAqIEl0IHdvcmtzIGJ5IGR5bmFtaWNhbGx5IGNyZWF0aW5nIGFuZCBhcHBlbmRpbmcgYSBzY3JpcHQgbm9kZSB0byB0aGUgdGhlXG4gKiBkb2N1bWVudCBoZWFkIGFuZCB3cmFwcGluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gc28gYXMgdG8gcmV0dXJuIGEgcHJvbWlzZS5cbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGxvYWRlciA9IG5ldyBMb2FkZXIoe1xuICogICBhcGlLZXk6IFwiXCIsXG4gKiAgIHZlcnNpb246IFwid2Vla2x5XCIsXG4gKiAgIGxpYnJhcmllczogW1wicGxhY2VzXCJdXG4gKiB9KTtcbiAqXG4gKiBsb2FkZXIubG9hZCgpLnRoZW4oKGdvb2dsZSkgPT4ge1xuICogICBjb25zdCBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKC4uLilcbiAqIH0pXG4gKiBgYGBcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTG9hZGVyIHVzaW5nIFtbTG9hZGVyT3B0aW9uc11dLiBObyBkZWZhdWx0cyBhcmUgc2V0XG4gICAqIHVzaW5nIHRoaXMgbGlicmFyeSwgaW5zdGVhZCB0aGUgZGVmYXVsdHMgYXJlIHNldCBieSB0aGUgR29vZ2xlIE1hcHNcbiAgICogSmF2YVNjcmlwdCBBUEkgc2VydmVyLlxuICAgKlxuICAgKiBgYGBcbiAgICogY29uc3QgbG9hZGVyID0gTG9hZGVyKHthcGlLZXksIHZlcnNpb246ICd3ZWVrbHknLCBsaWJyYXJpZXM6IFsncGxhY2VzJ119KTtcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgdmFyIHtcbiAgICAgIGFwaUtleSxcbiAgICAgIGF1dGhSZWZlcnJlclBvbGljeSxcbiAgICAgIGNoYW5uZWwsXG4gICAgICBjbGllbnQsXG4gICAgICBpZCA9IERFRkFVTFRfSUQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGxpYnJhcmllcyA9IFtdLFxuICAgICAgbWFwSWRzLFxuICAgICAgbm9uY2UsXG4gICAgICByZWdpb24sXG4gICAgICByZXRyaWVzID0gMyxcbiAgICAgIHVybCA9IFwiaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzXCIsXG4gICAgICB2ZXJzaW9uXG4gICAgfSA9IF9yZWY7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIHRoaXMuYXV0aFJlZmVycmVyUG9saWN5ID0gYXV0aFJlZmVycmVyUG9saWN5O1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5pZCA9IGlkIHx8IERFRkFVTFRfSUQ7IC8vIERvIG5vdCBhbGxvdyBlbXB0eSBzdHJpbmdcbiAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgdGhpcy5saWJyYXJpZXMgPSBsaWJyYXJpZXM7XG4gICAgdGhpcy5tYXBJZHMgPSBtYXBJZHM7XG4gICAgdGhpcy5ub25jZSA9IG5vbmNlO1xuICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBpZiAoTG9hZGVyLmluc3RhbmNlKSB7XG4gICAgICBpZiAoIWlzRXF1YWwodGhpcy5vcHRpb25zLCBMb2FkZXIuaW5zdGFuY2Uub3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGVyIG11c3Qgbm90IGJlIGNhbGxlZCBhZ2FpbiB3aXRoIGRpZmZlcmVudCBvcHRpb25zLiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRpb25zKSwgXCIgIT09IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoTG9hZGVyLmluc3RhbmNlLm9wdGlvbnMpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTG9hZGVyLmluc3RhbmNlO1xuICAgIH1cbiAgICBMb2FkZXIuaW5zdGFuY2UgPSB0aGlzO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLFxuICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgbGlicmFyaWVzOiB0aGlzLmxpYnJhcmllcyxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgcmVnaW9uOiB0aGlzLnJlZ2lvbixcbiAgICAgIG1hcElkczogdGhpcy5tYXBJZHMsXG4gICAgICBub25jZTogdGhpcy5ub25jZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBhdXRoUmVmZXJyZXJQb2xpY3k6IHRoaXMuYXV0aFJlZmVycmVyUG9saWN5XG4gICAgfTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBMb2FkZXJTdGF0dXMuRkFJTFVSRTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgcmV0dXJuIExvYWRlclN0YXR1cy5TVUNDRVNTO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICByZXR1cm4gTG9hZGVyU3RhdHVzLkxPQURJTkc7XG4gICAgfVxuICAgIHJldHVybiBMb2FkZXJTdGF0dXMuSU5JVElBTElaRUQ7XG4gIH1cbiAgZ2V0IGZhaWxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb25lICYmICF0aGlzLmxvYWRpbmcgJiYgdGhpcy5lcnJvcnMubGVuZ3RoID49IHRoaXMucmV0cmllcyArIDE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZVVybCByZXR1cm5zIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgdXJsIGdpdmVuIHRoZSBbW0xvYWRlck9wdGlvbnNdXS5cbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgY3JlYXRlVXJsKCkge1xuICAgIHZhciB1cmwgPSB0aGlzLnVybDtcbiAgICB1cmwgKz0gXCI/Y2FsbGJhY2s9X19nb29nbGVNYXBzQ2FsbGJhY2smbG9hZGluZz1hc3luY1wiO1xuICAgIGlmICh0aGlzLmFwaUtleSkge1xuICAgICAgdXJsICs9IFwiJmtleT1cIi5jb25jYXQodGhpcy5hcGlLZXkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGFubmVsKSB7XG4gICAgICB1cmwgKz0gXCImY2hhbm5lbD1cIi5jb25jYXQodGhpcy5jaGFubmVsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICB1cmwgKz0gXCImY2xpZW50PVwiLmNvbmNhdCh0aGlzLmNsaWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpYnJhcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICB1cmwgKz0gXCImbGlicmFyaWVzPVwiLmNvbmNhdCh0aGlzLmxpYnJhcmllcy5qb2luKFwiLFwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxhbmd1YWdlKSB7XG4gICAgICB1cmwgKz0gXCImbGFuZ3VhZ2U9XCIuY29uY2F0KHRoaXMubGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWdpb24pIHtcbiAgICAgIHVybCArPSBcIiZyZWdpb249XCIuY29uY2F0KHRoaXMucmVnaW9uKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyc2lvbikge1xuICAgICAgdXJsICs9IFwiJnY9XCIuY29uY2F0KHRoaXMudmVyc2lvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcElkcykge1xuICAgICAgdXJsICs9IFwiJm1hcF9pZHM9XCIuY29uY2F0KHRoaXMubWFwSWRzLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0aFJlZmVycmVyUG9saWN5KSB7XG4gICAgICB1cmwgKz0gXCImYXV0aF9yZWZlcnJlcl9wb2xpY3k9XCIuY29uY2F0KHRoaXMuYXV0aFJlZmVycmVyUG9saWN5KTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBkZWxldGVTY3JpcHQoKSB7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO1xuICAgIGlmIChzY3JpcHQpIHtcbiAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHNjcmlwdCBhbmQgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICogQGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRMaWJyYXJ5KCkgaW5zdGVhZC5cbiAgICovXG4gIGxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZFByb21pc2UoKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgc2NyaXB0IGFuZCByZXR1cm4gYSBQcm9taXNlLlxuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBkZXByZWNhdGVkLCB1c2UgaW1wb3J0TGlicmFyeSgpIGluc3RlYWQuXG4gICAqL1xuICBsb2FkUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5sb2FkQ2FsbGJhY2soZXJyID0+IHtcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICByZXNvbHZlKHdpbmRvdy5nb29nbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChlcnIuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBpbXBvcnRMaWJyYXJ5KG5hbWUpIHtcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICByZXR1cm4gZ29vZ2xlLm1hcHMuaW1wb3J0TGlicmFyeShuYW1lKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgc2NyaXB0IHdpdGggYSBjYWxsYmFjay5cbiAgICogQGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRMaWJyYXJ5KCkgaW5zdGVhZC5cbiAgICovXG4gIGxvYWRDYWxsYmFjayhmbikge1xuICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goZm4pO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHNjcmlwdCBvbiBkb2N1bWVudC5cbiAgICovXG4gIHNldFNjcmlwdCgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKSkge1xuICAgICAgLy8gVE9ETyB3cmFwIG9uZXJyb3IgY2FsbGJhY2sgZm9yIGNhc2VzIHdoZXJlIHRoZSBzY3JpcHQgd2FzIGxvYWRlZCBlbHNld2hlcmVcbiAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIGtleTogdGhpcy5hcGlLZXksXG4gICAgICBjaGFubmVsOiB0aGlzLmNoYW5uZWwsXG4gICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgbGlicmFyaWVzOiB0aGlzLmxpYnJhcmllcy5sZW5ndGggJiYgdGhpcy5saWJyYXJpZXMsXG4gICAgICB2OiB0aGlzLnZlcnNpb24sXG4gICAgICBtYXBJZHM6IHRoaXMubWFwSWRzLFxuICAgICAgbGFuZ3VhZ2U6IHRoaXMubGFuZ3VhZ2UsXG4gICAgICByZWdpb246IHRoaXMucmVnaW9uLFxuICAgICAgYXV0aFJlZmVycmVyUG9saWN5OiB0aGlzLmF1dGhSZWZlcnJlclBvbGljeVxuICAgIH07XG4gICAgLy8ga2VlcCB0aGUgVVJMIG1pbmltYWw6XG4gICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAga2V5ID0+ICFwYXJhbXNba2V5XSAmJiBkZWxldGUgcGFyYW1zW2tleV0pO1xuICAgIGlmICghKChfYiA9IChfYSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5nb29nbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXBzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW1wb3J0TGlicmFyeSkpIHtcbiAgICAgIC8vIHR3ZWFrZWQgY29weSBvZiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9sb2FkLW1hcHMtanMtYXBpI2R5bmFtaWMtbGlicmFyeS1pbXBvcnRcbiAgICAgIC8vIHdoaWNoIGFsc28gc2V0cyB0aGUgYmFzZSB1cmwsIHRoZSBpZCwgYW5kIHRoZSBub25jZVxuICAgICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICAgIChnID0+IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgaCxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGssXG4gICAgICAgICAgcCA9IFwiVGhlIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJXCIsXG4gICAgICAgICAgYyA9IFwiZ29vZ2xlXCIsXG4gICAgICAgICAgbCA9IFwiaW1wb3J0TGlicmFyeVwiLFxuICAgICAgICAgIHEgPSBcIl9faWJfX1wiLFxuICAgICAgICAgIG0gPSBkb2N1bWVudCxcbiAgICAgICAgICBiID0gd2luZG93O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGIgPSBiW2NdIHx8IChiW2NdID0ge30pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciBkID0gYi5tYXBzIHx8IChiLm1hcHMgPSB7fSksXG4gICAgICAgICAgciA9IG5ldyBTZXQoKSxcbiAgICAgICAgICBlID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLFxuICAgICAgICAgIHUgPSAoKSA9PlxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBoIHx8IChoID0gbmV3IFByb21pc2UoKGYsIG4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHlpZWxkIGEgPSBtLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBhLmlkID0gdGhpcy5pZDtcbiAgICAgICAgICAgIGUuc2V0KFwibGlicmFyaWVzXCIsIFsuLi5yXSArIFwiXCIpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChrIGluIGcpIGUuc2V0KGsucmVwbGFjZSgvW0EtWl0vZywgdCA9PiBcIl9cIiArIHRbMF0udG9Mb3dlckNhc2UoKSksIGdba10pO1xuICAgICAgICAgICAgZS5zZXQoXCJjYWxsYmFja1wiLCBjICsgXCIubWFwcy5cIiArIHEpO1xuICAgICAgICAgICAgYS5zcmMgPSB0aGlzLnVybCArIFwiP1wiICsgZTtcbiAgICAgICAgICAgIGRbcV0gPSBmO1xuICAgICAgICAgICAgYS5vbmVycm9yID0gKCkgPT4gaCA9IG4oRXJyb3IocCArIFwiIGNvdWxkIG5vdCBsb2FkLlwiKSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBhLm5vbmNlID0gdGhpcy5ub25jZSB8fCAoKF9hID0gbS5xdWVyeVNlbGVjdG9yKFwic2NyaXB0W25vbmNlXVwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vbmNlKSB8fCBcIlwiO1xuICAgICAgICAgICAgbS5oZWFkLmFwcGVuZChhKTtcbiAgICAgICAgICB9KSkpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRbbF0gPyBjb25zb2xlLndhcm4ocCArIFwiIG9ubHkgbG9hZHMgb25jZS4gSWdub3Jpbmc6XCIsIGcpIDogZFtsXSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG4gPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgICAgbltfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByLmFkZChmKSAmJiB1KCkudGhlbigoKSA9PiBkW2xdKGYsIC4uLm4pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHBhcmFtcyk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgfVxuICAgIC8vIFdoaWxlIG1vc3QgbGlicmFyaWVzIHBvcHVsYXRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlIHdoZW4gbG9hZGVkIHZpYSBib290c3RyYXAgcGFyYW1zLFxuICAgIC8vIHRoaXMgaXMgbm90IHRoZSBjYXNlIGZvciBcIm1hcmtlclwiIHdoZW4gdXNlZCB3aXRoIHRoZSBpbmxpbmUgYm9vdHN0cmFwIGxvYWRlclxuICAgIC8vIChhbmQgbWF5YmUgb3RoZXJzIGluIHRoZSBmdXR1cmUpLiBTbyBlbnN1cmUgdGhlcmUgaXMgYW4gaW1wb3J0TGlicmFyeSBmb3IgZWFjaDpcbiAgICB2YXIgbGlicmFyeVByb21pc2VzID0gdGhpcy5saWJyYXJpZXMubWFwKGxpYnJhcnkgPT4gdGhpcy5pbXBvcnRMaWJyYXJ5KGxpYnJhcnkpKTtcbiAgICAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxpYnJhcnksIHRvIGtpY2sgb2ZmIGxvYWRpbmcuLi5cbiAgICBpZiAoIWxpYnJhcnlQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIGxpYnJhcnlQcm9taXNlcy5wdXNoKHRoaXMuaW1wb3J0TGlicmFyeShcImNvcmVcIikpO1xuICAgIH1cbiAgICBQcm9taXNlLmFsbChsaWJyYXJ5UHJvbWlzZXMpLnRoZW4oKCkgPT4gdGhpcy5jYWxsYmFjaygpLCBlcnJvciA9PiB7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgZXJyb3JcbiAgICAgIH0pOyAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgICAgdGhpcy5sb2FkRXJyb3JDYWxsYmFjayhldmVudCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBsb2FkZXIgc3RhdGUuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLmRlbGV0ZVNjcmlwdCgpO1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5vbmVycm9yRXZlbnQgPSBudWxsO1xuICB9XG4gIHJlc2V0SWZSZXRyeWluZ0ZhaWxlZCgpIHtcbiAgICBpZiAodGhpcy5mYWlsZWQpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgbG9hZEVycm9yQ2FsbGJhY2soZSkge1xuICAgIHRoaXMuZXJyb3JzLnB1c2goZSk7XG4gICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA8PSB0aGlzLnJldHJpZXMpIHtcbiAgICAgIHZhciBkZWxheSA9IHRoaXMuZXJyb3JzLmxlbmd0aCAqIE1hdGgucG93KDIsIHRoaXMuZXJyb3JzLmxlbmd0aCk7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgR29vZ2xlIE1hcHMgc2NyaXB0LCByZXRyeWluZyBpbiBcIi5jb25jYXQoZGVsYXksIFwiIG1zLlwiKSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kZWxldGVTY3JpcHQoKTtcbiAgICAgICAgdGhpcy5zZXRTY3JpcHQoKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbmVycm9yRXZlbnQgPSBlO1xuICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuICBjYWxsYmFjaygpIHtcbiAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgY2IodGhpcy5vbmVycm9yRXZlbnQpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gIH1cbiAgZXhlY3V0ZSgpIHtcbiAgICB0aGlzLnJlc2V0SWZSZXRyeWluZ0ZhaWxlZCgpO1xuICAgIGlmICh0aGlzLmxvYWRpbmcpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgYnV0IHdhaXRcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaG9ydCBjaXJjdWl0IGFuZCB3YXJuIGlmIGdvb2dsZS5tYXBzIGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgd2luZG93Lmdvb2dsZS5tYXBzLnZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiR29vZ2xlIE1hcHMgYWxyZWFkeSBsb2FkZWQgb3V0c2lkZSBAZ29vZ2xlbWFwcy9qcy1hcGktbG9hZGVyLiBcIiArIFwiVGhpcyBtYXkgcmVzdWx0IGluIHVuZGVzaXJhYmxlIGJlaGF2aW9yIGFzIG9wdGlvbnMgYW5kIHNjcmlwdCBwYXJhbWV0ZXJzIG1heSBub3QgbWF0Y2guXCIpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICB0aGlzLnNldFNjcmlwdCgpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGVmYXVsdExpYnJhcmllcyA9IFsnbWFwcyddO1xuZnVuY3Rpb24gdXNlSnNBcGlMb2FkZXIoX3JlZikge1xuICB2YXIge1xuICAgIGlkID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy5pZCxcbiAgICB2ZXJzaW9uID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcy52ZXJzaW9uLFxuICAgIG5vbmNlLFxuICAgIGdvb2dsZU1hcHNBcGlLZXksXG4gICAgLy8gZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgIGxhbmd1YWdlLFxuICAgIHJlZ2lvbixcbiAgICBsaWJyYXJpZXMgPSBkZWZhdWx0TGlicmFyaWVzLFxuICAgIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcsXG4gICAgLy8gY2hhbm5lbCxcbiAgICBtYXBJZHMsXG4gICAgYXV0aFJlZmVycmVyUG9saWN5XG4gIH0gPSBfcmVmO1xuICB2YXIgaXNNb3VudGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIFtpc0xvYWRlZCwgc2V0TG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIFtsb2FkRXJyb3IsIHNldExvYWRFcnJvcl0gPSB1c2VTdGF0ZSh1bmRlZmluZWQpO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gdHJhY2tNb3VudGVkU3RhdGUoKSB7XG4gICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdmFyIGxvYWRlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBuZXcgTG9hZGVyKHtcbiAgICAgIGlkLFxuICAgICAgYXBpS2V5OiBnb29nbGVNYXBzQXBpS2V5LFxuICAgICAgdmVyc2lvbixcbiAgICAgIGxpYnJhcmllcyxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSB8fCAnZW4nLFxuICAgICAgcmVnaW9uOiByZWdpb24gfHwgJ1VTJyxcbiAgICAgIG1hcElkczogbWFwSWRzIHx8IFtdLFxuICAgICAgbm9uY2U6IG5vbmNlIHx8ICcnLFxuICAgICAgYXV0aFJlZmVycmVyUG9saWN5OiBhdXRoUmVmZXJyZXJQb2xpY3kgfHwgJ29yaWdpbidcbiAgICB9KTtcbiAgfSwgW2lkLCBnb29nbGVNYXBzQXBpS2V5LCB2ZXJzaW9uLCBsaWJyYXJpZXMsIGxhbmd1YWdlLCByZWdpb24sIG1hcElkcywgbm9uY2UsIGF1dGhSZWZlcnJlclBvbGljeV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gZWZmZWN0KCkge1xuICAgIGlmIChpc0xvYWRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkZXIubG9hZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBzZXRMb2FkRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nKSB7XG4gICAgICBwcmV2ZW50R29vZ2xlRm9udHMoKTtcbiAgICB9XG4gIH0sIFtwcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nXSk7XG4gIHZhciBwcmV2TGlicmFyaWVzID0gdXNlUmVmKCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZXZMaWJyYXJpZXMuY3VycmVudCAmJiBsaWJyYXJpZXMgIT09IHByZXZMaWJyYXJpZXMuY3VycmVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdQZXJmb3JtYW5jZSB3YXJuaW5nISBMb2FkU2NyaXB0IGhhcyBiZWVuIHJlbG9hZGVkIHVuaW50ZW50aW9uYWxseSEgWW91IHNob3VsZCBub3QgcGFzcyBgbGlicmFyaWVzYCBwcm9wIGFzIG5ldyBhcnJheS4gUGxlYXNlIGtlZXAgYW4gYXJyYXkgb2YgbGlicmFyaWVzIGFzIHN0YXRpYyBjbGFzcyBwcm9wZXJ0eSBmb3IgQ29tcG9uZW50cyBhbmQgUHVyZUNvbXBvbmVudHMsIG9yIGp1c3QgYSBjb25zdCB2YXJpYWJsZSBvdXRzaWRlIG9mIGNvbXBvbmVudCwgb3Igc29tZXdoZXJlIGluIGNvbmZpZyBmaWxlcyBvciBFTlYgdmFyaWFibGVzJyk7XG4gICAgfVxuICAgIHByZXZMaWJyYXJpZXMuY3VycmVudCA9IGxpYnJhcmllcztcbiAgfSwgW2xpYnJhcmllc10pO1xuICByZXR1cm4ge1xuICAgIGlzTG9hZGVkLFxuICAgIGxvYWRFcnJvclxuICB9O1xufVxuXG5mdW5jdGlvbiBvd25LZXlzJGYoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCRmKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkZihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkZihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGV2ZW50TWFwJGggPSB7fTtcbnZhciB1cGRhdGVyTWFwJGggPSB7XG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG59O1xuZnVuY3Rpb24gVHJhZmZpY0xheWVyRnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgb3B0aW9ucyxcbiAgICBvbkxvYWQsXG4gICAgb25Vbm1vdW50XG4gIH0gPSBfcmVmO1xuICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIFtpbnN0YW5jZSwgc2V0SW5zdGFuY2VdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciB0cmFmZmljTGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhZmZpY0xheWVyKF9vYmplY3RTcHJlYWQkZihfb2JqZWN0U3ByZWFkJGYoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWFwXG4gICAgfSkpO1xuICAgIHNldEluc3RhbmNlKHRyYWZmaWNMYXllcik7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKHRyYWZmaWNMYXllcik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgVHJhZmZpY0xheWVyRiA9IG1lbW8oVHJhZmZpY0xheWVyRnVuY3Rpb25hbCk7XG5jbGFzcyBUcmFmZmljTGF5ZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICB0cmFmZmljTGF5ZXI6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRUcmFmZmljTGF5ZXJDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lzdGVyZWRFdmVudHNcIiwgW10pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciB0cmFmZmljTGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhZmZpY0xheWVyKF9vYmplY3RTcHJlYWQkZihfb2JqZWN0U3ByZWFkJGYoe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXA6IHRoaXMuY29udGV4dFxuICAgIH0pKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkaCxcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRoLFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiB0cmFmZmljTGF5ZXJcbiAgICB9KTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFRyYWZmaWNMYXllcigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWZmaWNMYXllclxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldFRyYWZmaWNMYXllckNhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHJhZmZpY0xheWVyICE9PSBudWxsKSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRoLFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkaCxcbiAgICAgICAgcHJldlByb3BzLFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnRyYWZmaWNMYXllclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnRyYWZmaWNMYXllciAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUudHJhZmZpY0xheWVyKTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIHRoaXMuc3RhdGUudHJhZmZpY0xheWVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoVHJhZmZpY0xheWVyLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG5mdW5jdGlvbiBCaWN5Y2xpbmdMYXllckZ1bmN0aW9uYWwoX3JlZikge1xuICB2YXIge1xuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBiaWN5Y2xpbmdMYXllciA9IG5ldyBnb29nbGUubWFwcy5CaWN5Y2xpbmdMYXllcigpO1xuICAgIHNldEluc3RhbmNlKGJpY3ljbGluZ0xheWVyKTtcbiAgICBiaWN5Y2xpbmdMYXllci5zZXRNYXAobWFwKTtcbiAgICBpZiAob25Mb2FkKSB7XG4gICAgICBvbkxvYWQoYmljeWNsaW5nTGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGJpY3ljbGluZ0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICBvblVubW91bnQoYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJpY3ljbGluZ0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufVxudmFyIEJpY3ljbGluZ0xheWVyRiA9IG1lbW8oQmljeWNsaW5nTGF5ZXJGdW5jdGlvbmFsKTtcbmNsYXNzIEJpY3ljbGluZ0xheWVyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgYmljeWNsaW5nTGF5ZXI6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRCaWN5Y2xpbmdMYXllckNhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIGJpY3ljbGluZ0xheWVyID0gbmV3IGdvb2dsZS5tYXBzLkJpY3ljbGluZ0xheWVyKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiaWN5Y2xpbmdMYXllclxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldEJpY3ljbGluZ0xheWVyQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllcik7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmJpY3ljbGluZ0xheWVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoQmljeWNsaW5nTGF5ZXIsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIFRyYW5zaXRMYXllckZ1bmN0aW9uYWwoX3JlZikge1xuICB2YXIge1xuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciB0cmFuc2l0TGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhbnNpdExheWVyKCk7XG4gICAgc2V0SW5zdGFuY2UodHJhbnNpdExheWVyKTtcbiAgICB0cmFuc2l0TGF5ZXIuc2V0TWFwKG1hcCk7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKHRyYW5zaXRMYXllcik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgVHJhbnNpdExheWVyRiA9IG1lbW8oVHJhbnNpdExheWVyRnVuY3Rpb25hbCk7XG5jbGFzcyBUcmFuc2l0TGF5ZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICB0cmFuc2l0TGF5ZXI6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRUcmFuc2l0TGF5ZXJDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUudHJhbnNpdExheWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciB0cmFuc2l0TGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhbnNpdExheWVyKCk7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRUcmFuc2l0TGF5ZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2l0TGF5ZXJcbiAgICAgIH07XG4gICAgfSwgdGhpcy5zZXRUcmFuc2l0TGF5ZXJDYWxsYmFjayk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHJhbnNpdExheWVyICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShUcmFuc2l0TGF5ZXIsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIG93bktleXMkZShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRlKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRlKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZXZlbnRNYXAkZyA9IHtcbiAgb25DaXJjbGVDb21wbGV0ZTogJ2NpcmNsZWNvbXBsZXRlJyxcbiAgb25NYXJrZXJDb21wbGV0ZTogJ21hcmtlcmNvbXBsZXRlJyxcbiAgb25PdmVybGF5Q29tcGxldGU6ICdvdmVybGF5Y29tcGxldGUnLFxuICBvblBvbHlnb25Db21wbGV0ZTogJ3BvbHlnb25jb21wbGV0ZScsXG4gIG9uUG9seWxpbmVDb21wbGV0ZTogJ3BvbHlsaW5lY29tcGxldGUnLFxuICBvblJlY3RhbmdsZUNvbXBsZXRlOiAncmVjdGFuZ2xlY29tcGxldGUnXG59O1xudmFyIHVwZGF0ZXJNYXAkZyA9IHtcbiAgZHJhd2luZ01vZGUoaW5zdGFuY2UsIGRyYXdpbmdNb2RlKSB7XG4gICAgaW5zdGFuY2Uuc2V0RHJhd2luZ01vZGUoZHJhd2luZ01vZGUpO1xuICB9LFxuICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxufTtcbmZ1bmN0aW9uIERyYXdpbmdNYW5hZ2VyRnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgb3B0aW9ucyxcbiAgICBkcmF3aW5nTW9kZSxcbiAgICBvbkNpcmNsZUNvbXBsZXRlLFxuICAgIG9uTWFya2VyQ29tcGxldGUsXG4gICAgb25PdmVybGF5Q29tcGxldGUsXG4gICAgb25Qb2x5Z29uQ29tcGxldGUsXG4gICAgb25Qb2x5bGluZUNvbXBsZXRlLFxuICAgIG9uUmVjdGFuZ2xlQ29tcGxldGUsXG4gICAgb25Mb2FkLFxuICAgIG9uVW5tb3VudFxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBbaW5zdGFuY2UsIHNldEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2NpcmNsZWNvbXBsZXRlTGlzdGVuZXIsIHNldENpcmNsZUNvbXBsZXRlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbWFya2VyY29tcGxldGVMaXN0ZW5lciwgc2V0TWFya2VyQ29tcGxldGVMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtvdmVybGF5Y29tcGxldGVMaXN0ZW5lciwgc2V0T3ZlcmxheUNvbXBsZXRlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcG9seWdvbmNvbXBsZXRlTGlzdGVuZXIsIHNldFBvbHlnb25Db21wbGV0ZUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3BvbHlsaW5lY29tcGxldGVMaXN0ZW5lciwgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3JlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIsIHNldFJlY3RhbmdsZUNvbXBsZXRlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0RHJhd2luZ01vZGUoZHJhd2luZ01vZGUgIT09IG51bGwgJiYgZHJhd2luZ01vZGUgIT09IHZvaWQgMCA/IGRyYXdpbmdNb2RlIDogbnVsbCk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIGRyYXdpbmdNb2RlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2lyY2xlQ29tcGxldGUpIHtcbiAgICAgIGlmIChjaXJjbGVjb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNpcmNsZWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2lyY2xlQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NpcmNsZWNvbXBsZXRlJywgb25DaXJjbGVDb21wbGV0ZSkpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBvbkNpcmNsZUNvbXBsZXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uTWFya2VyQ29tcGxldGUpIHtcbiAgICAgIGlmIChtYXJrZXJjb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TWFya2VyQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21hcmtlcmNvbXBsZXRlJywgb25NYXJrZXJDb21wbGV0ZSkpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBvbk1hcmtlckNvbXBsZXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uT3ZlcmxheUNvbXBsZXRlKSB7XG4gICAgICBpZiAob3ZlcmxheWNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIob3ZlcmxheWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0T3ZlcmxheUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdvdmVybGF5Y29tcGxldGUnLCBvbk92ZXJsYXlDb21wbGV0ZSkpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBvbk92ZXJsYXlDb21wbGV0ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblBvbHlnb25Db21wbGV0ZSkge1xuICAgICAgaWYgKHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFBvbHlnb25Db21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9seWdvbmNvbXBsZXRlJywgb25Qb2x5Z29uQ29tcGxldGUpKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgb25Qb2x5Z29uQ29tcGxldGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Qb2x5bGluZUNvbXBsZXRlKSB7XG4gICAgICBpZiAocG9seWxpbmVjb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvbHlsaW5lY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRQb2x5bGluZUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb2x5bGluZWNvbXBsZXRlJywgb25Qb2x5bGluZUNvbXBsZXRlKSk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9uUG9seWxpbmVDb21wbGV0ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblJlY3RhbmdsZUNvbXBsZXRlKSB7XG4gICAgICBpZiAocmVjdGFuZ2xlY29tcGxldGVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZWN0YW5nbGVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFJlY3RhbmdsZUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZWN0YW5nbGVjb21wbGV0ZScsIG9uUmVjdGFuZ2xlQ29tcGxldGUpKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgb25SZWN0YW5nbGVDb21wbGV0ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGludmFyaWFudCghIWdvb2dsZS5tYXBzLmRyYXdpbmcsIFwiRGlkIHlvdSBpbmNsdWRlIHByb3AgbGlicmFyaWVzPXtbJ2RyYXdpbmcnXX0gaW4gdGhlIFVSTD8gJXNcIiwgZ29vZ2xlLm1hcHMuZHJhd2luZyk7XG4gICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoX29iamVjdFNwcmVhZCRlKF9vYmplY3RTcHJlYWQkZSh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXBcbiAgICB9KSk7XG4gICAgaWYgKGRyYXdpbmdNb2RlKSB7XG4gICAgICBkcmF3aW5nTWFuYWdlci5zZXREcmF3aW5nTW9kZShkcmF3aW5nTW9kZSk7XG4gICAgfVxuICAgIGlmIChvbkNpcmNsZUNvbXBsZXRlKSB7XG4gICAgICBzZXRDaXJjbGVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAnY2lyY2xlY29tcGxldGUnLCBvbkNpcmNsZUNvbXBsZXRlKSk7XG4gICAgfVxuICAgIGlmIChvbk1hcmtlckNvbXBsZXRlKSB7XG4gICAgICBzZXRNYXJrZXJDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAnbWFya2VyY29tcGxldGUnLCBvbk1hcmtlckNvbXBsZXRlKSk7XG4gICAgfVxuICAgIGlmIChvbk92ZXJsYXlDb21wbGV0ZSkge1xuICAgICAgc2V0T3ZlcmxheUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZHJhd2luZ01hbmFnZXIsICdvdmVybGF5Y29tcGxldGUnLCBvbk92ZXJsYXlDb21wbGV0ZSkpO1xuICAgIH1cbiAgICBpZiAob25Qb2x5Z29uQ29tcGxldGUpIHtcbiAgICAgIHNldFBvbHlnb25Db21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncG9seWdvbmNvbXBsZXRlJywgb25Qb2x5Z29uQ29tcGxldGUpKTtcbiAgICB9XG4gICAgaWYgKG9uUG9seWxpbmVDb21wbGV0ZSkge1xuICAgICAgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncG9seWxpbmVjb21wbGV0ZScsIG9uUG9seWxpbmVDb21wbGV0ZSkpO1xuICAgIH1cbiAgICBpZiAob25SZWN0YW5nbGVDb21wbGV0ZSkge1xuICAgICAgc2V0UmVjdGFuZ2xlQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ3JlY3RhbmdsZWNvbXBsZXRlJywgb25SZWN0YW5nbGVDb21wbGV0ZSkpO1xuICAgIH1cbiAgICBzZXRJbnN0YW5jZShkcmF3aW5nTWFuYWdlcik7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKGRyYXdpbmdNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2lyY2xlY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNpcmNsZWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJjb21wbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobWFya2VyY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG92ZXJsYXljb21wbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIob3ZlcmxheWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2x5Z29uY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWxpbmVjb21wbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9seWxpbmVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVjdGFuZ2xlY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICBvblVubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufVxudmFyIERyYXdpbmdNYW5hZ2VyRiA9IG1lbW8oRHJhd2luZ01hbmFnZXJGdW5jdGlvbmFsKTtcbmNsYXNzIERyYXdpbmdNYW5hZ2VyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lzdGVyZWRFdmVudHNcIiwgW10pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGRyYXdpbmdNYW5hZ2VyOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0RHJhd2luZ01hbmFnZXJDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlciAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbnZhcmlhbnQoISFnb29nbGUubWFwcy5kcmF3aW5nLCBcIkRpZCB5b3UgaW5jbHVkZSBwcm9wIGxpYnJhcmllcz17WydkcmF3aW5nJ119IGluIHRoZSBVUkw/ICVzXCIsIGdvb2dsZS5tYXBzLmRyYXdpbmcpO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBkcmF3aW5nTWFuYWdlciA9IG5ldyBnb29nbGUubWFwcy5kcmF3aW5nLkRyYXdpbmdNYW5hZ2VyKF9vYmplY3RTcHJlYWQkZShfb2JqZWN0U3ByZWFkJGUoe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXA6IHRoaXMuY29udGV4dFxuICAgIH0pKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZyxcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRnLFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiBkcmF3aW5nTWFuYWdlclxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RHJhd2luZ01hbmFnZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3aW5nTWFuYWdlclxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldERyYXdpbmdNYW5hZ2VyQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlciAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZyxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGcsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlcik7XG4gICAgICB9XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoRHJhd2luZ01hbmFnZXIsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIG93bktleXMkZChlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJGQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyRkKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyRkKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZXZlbnRNYXAkZiA9IHtcbiAgb25BbmltYXRpb25DaGFuZ2VkOiAnYW5pbWF0aW9uX2NoYW5nZWQnLFxuICBvbkNsaWNrOiAnY2xpY2snLFxuICBvbkNsaWNrYWJsZUNoYW5nZWQ6ICdjbGlja2FibGVfY2hhbmdlZCcsXG4gIG9uQ3Vyc29yQ2hhbmdlZDogJ2N1cnNvcl9jaGFuZ2VkJyxcbiAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgb25EcmFnOiAnZHJhZycsXG4gIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICBvbkRyYWdnYWJsZUNoYW5nZWQ6ICdkcmFnZ2FibGVfY2hhbmdlZCcsXG4gIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgb25GbGF0Q2hhbmdlZDogJ2ZsYXRfY2hhbmdlZCcsXG4gIG9uSWNvbkNoYW5nZWQ6ICdpY29uX2NoYW5nZWQnLFxuICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gIG9uUG9zaXRpb25DaGFuZ2VkOiAncG9zaXRpb25fY2hhbmdlZCcsXG4gIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxuICBvblNoYXBlQ2hhbmdlZDogJ3NoYXBlX2NoYW5nZWQnLFxuICBvblRpdGxlQ2hhbmdlZDogJ3RpdGxlX2NoYW5nZWQnLFxuICBvblZpc2libGVDaGFuZ2VkOiAndmlzaWJsZV9jaGFuZ2VkJyxcbiAgb25aaW5kZXhDaGFuZ2VkOiAnemluZGV4X2NoYW5nZWQnXG59O1xudmFyIHVwZGF0ZXJNYXAkZiA9IHtcbiAgYW5pbWF0aW9uKGluc3RhbmNlLCBhbmltYXRpb24pIHtcbiAgICBpbnN0YW5jZS5zZXRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgfSxcbiAgY2xpY2thYmxlKGluc3RhbmNlLCBjbGlja2FibGUpIHtcbiAgICBpbnN0YW5jZS5zZXRDbGlja2FibGUoY2xpY2thYmxlKTtcbiAgfSxcbiAgY3Vyc29yKGluc3RhbmNlLCBjdXJzb3IpIHtcbiAgICBpbnN0YW5jZS5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgfSxcbiAgZHJhZ2dhYmxlKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgfSxcbiAgaWNvbihpbnN0YW5jZSwgaWNvbikge1xuICAgIGluc3RhbmNlLnNldEljb24oaWNvbik7XG4gIH0sXG4gIGxhYmVsKGluc3RhbmNlLCBsYWJlbCkge1xuICAgIGluc3RhbmNlLnNldExhYmVsKGxhYmVsKTtcbiAgfSxcbiAgbWFwKGluc3RhbmNlLCBtYXApIHtcbiAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgfSxcbiAgb3BhY2l0eShpbnN0YW5jZSwgb3BhY2l0eSkge1xuICAgIGluc3RhbmNlLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBwb3NpdGlvbihpbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH0sXG4gIHNoYXBlKGluc3RhbmNlLCBzaGFwZSkge1xuICAgIGluc3RhbmNlLnNldFNoYXBlKHNoYXBlKTtcbiAgfSxcbiAgdGl0bGUoaW5zdGFuY2UsIHRpdGxlKSB7XG4gICAgaW5zdGFuY2Uuc2V0VGl0bGUodGl0bGUpO1xuICB9LFxuICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgfSxcbiAgekluZGV4KGluc3RhbmNlLCB6SW5kZXgpIHtcbiAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgfVxufTtcbnZhciBkZWZhdWx0T3B0aW9ucyQ1ID0ge307XG5mdW5jdGlvbiBNYXJrZXJGdW5jdGlvbmFsKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBwb3NpdGlvbixcbiAgICBvcHRpb25zLFxuICAgIGNsdXN0ZXJlcixcbiAgICBub0NsdXN0ZXJlclJlZHJhdyxcbiAgICBjaGlsZHJlbixcbiAgICBkcmFnZ2FibGUsXG4gICAgdmlzaWJsZSxcbiAgICBhbmltYXRpb24sXG4gICAgY2xpY2thYmxlLFxuICAgIGN1cnNvcixcbiAgICBpY29uLFxuICAgIGxhYmVsLFxuICAgIG9wYWNpdHksXG4gICAgc2hhcGUsXG4gICAgdGl0bGUsXG4gICAgekluZGV4LFxuICAgIG9uQ2xpY2ssXG4gICAgb25EYmxDbGljayxcbiAgICBvbkRyYWcsXG4gICAgb25EcmFnRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uTW91c2VPdXQsXG4gICAgb25Nb3VzZU92ZXIsXG4gICAgb25Nb3VzZVVwLFxuICAgIG9uTW91c2VEb3duLFxuICAgIG9uUmlnaHRDbGljayxcbiAgICBvbkNsaWNrYWJsZUNoYW5nZWQsXG4gICAgb25DdXJzb3JDaGFuZ2VkLFxuICAgIG9uQW5pbWF0aW9uQ2hhbmdlZCxcbiAgICBvbkRyYWdnYWJsZUNoYW5nZWQsXG4gICAgb25GbGF0Q2hhbmdlZCxcbiAgICBvbkljb25DaGFuZ2VkLFxuICAgIG9uUG9zaXRpb25DaGFuZ2VkLFxuICAgIG9uU2hhcGVDaGFuZ2VkLFxuICAgIG9uVGl0bGVDaGFuZ2VkLFxuICAgIG9uVmlzaWJsZUNoYW5nZWQsXG4gICAgb25aaW5kZXhDaGFuZ2VkLFxuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkYmxjbGlja0xpc3RlbmVyLCBzZXREYmxjbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RyYWdlbmRMaXN0ZW5lciwgc2V0RHJhZ2VuZExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RyYWdzdGFydExpc3RlbmVyLCBzZXREcmFnc3RhcnRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZWRvd25MaXN0ZW5lciwgc2V0TW91c2Vkb3duTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdXRMaXN0ZW5lciwgc2V0TW91c2VvdXRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW92ZXJMaXN0ZW5lciwgc2V0TW91c2VvdmVyTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2V1cExpc3RlbmVyLCBzZXRNb3VzZXVwTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcmlnaHRjbGlja0xpc3RlbmVyLCBzZXRSaWdodGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2xpY2tMaXN0ZW5lciwgc2V0Q2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnTGlzdGVuZXIsIHNldERyYWdMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIsIHNldENsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjdXJzb3JDaGFuZ2VkTGlzdGVuZXIsIHNldEN1cnNvckNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFthbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIsIHNldEFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIsIHNldERyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtmbGF0Q2hhbmdlZExpc3RlbmVyLCBzZXRGbGF0Q2hhbmdlZExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2ljb25DaGFuZ2VkTGlzdGVuZXIsIHNldEljb25DaGFuZ2VkTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIsIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3NoYXBlQ2hhbmdlZExpc3RlbmVyLCBzZXRTaGFwZUNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFt0aXRsZUNoYW5nZWRMaXN0ZW5lciwgc2V0VGl0bGVDaGFuZ2VkTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbdmlzaWJsZUNoYW5nZWRMaXN0ZW5lciwgc2V0VmlzaWJsZUNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFt6SW5kZXhDaGFuZ2VkTGlzdGVuZXIsIHNldFppbmRleENoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgcG9zaXRpb25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCB8fCBpbnN0YW5jZS5zZXRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgfSwgW2luc3RhbmNlLCBhbmltYXRpb25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgY2xpY2thYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3RhbmNlLnNldENsaWNrYWJsZShjbGlja2FibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBjbGlja2FibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3RhbmNlLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBjdXJzb3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaWNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0YW5jZS5zZXRJY29uKGljb24pO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBpY29uXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIGxhYmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3RhbmNlLnNldExhYmVsKGxhYmVsKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgbGFiZWxdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbnN0YW5jZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBvcGFjaXR5XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIHNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3RhbmNlLnNldFNoYXBlKHNoYXBlKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgc2hhcGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgdGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdGFuY2Uuc2V0VGl0bGUodGl0bGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCB0aXRsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiB6SW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIHpJbmRleF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICB9XG4gIH0sIFtvbkRibENsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ0VuZCkge1xuICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgIH1cbiAgfSwgW29uRHJhZ0VuZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWdTdGFydF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlRG93bl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3V0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikpO1xuICAgIH1cbiAgfSwgW29uTW91c2VPdmVyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VVcCkge1xuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VVcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICB9XG4gIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgfVxuICB9LCBbb25DbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWcpIHtcbiAgICAgIGlmIChkcmFnTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGlja2FibGVDaGFuZ2VkKSB7XG4gICAgICBpZiAoY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRDbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGlja2FibGVfY2hhbmdlZCcsIG9uQ2xpY2thYmxlQ2hhbmdlZCkpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2thYmxlQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkN1cnNvckNoYW5nZWQpIHtcbiAgICAgIGlmIChjdXJzb3JDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY3Vyc29yQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldEN1cnNvckNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2N1cnNvcl9jaGFuZ2VkJywgb25DdXJzb3JDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25DdXJzb3JDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQW5pbWF0aW9uQ2hhbmdlZCkge1xuICAgICAgaWYgKGFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihhbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0QW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnYW5pbWF0aW9uX2NoYW5nZWQnLCBvbkFuaW1hdGlvbkNoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvbkFuaW1hdGlvbkNoYW5nZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnZ2FibGVDaGFuZ2VkKSB7XG4gICAgICBpZiAoZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnZ2FibGVfY2hhbmdlZCcsIG9uRHJhZ2dhYmxlQ2hhbmdlZCkpO1xuICAgIH1cbiAgfSwgW29uRHJhZ2dhYmxlQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkZsYXRDaGFuZ2VkKSB7XG4gICAgICBpZiAoZmxhdENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihmbGF0Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldEZsYXRDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdmbGF0X2NoYW5nZWQnLCBvbkZsYXRDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25GbGF0Q2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkljb25DaGFuZ2VkKSB7XG4gICAgICBpZiAoaWNvbkNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihpY29uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldEljb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdpY29uX2NoYW5nZWQnLCBvbkljb25DaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25JY29uQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25Qb3NpdGlvbkNoYW5nZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25TaGFwZUNoYW5nZWQpIHtcbiAgICAgIGlmIChzaGFwZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihzaGFwZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRTaGFwZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3NoYXBlX2NoYW5nZWQnLCBvblNoYXBlQ2hhbmdlZCkpO1xuICAgIH1cbiAgfSwgW29uU2hhcGVDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uVGl0bGVDaGFuZ2VkKSB7XG4gICAgICBpZiAodGl0bGVDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGl0bGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0VGl0bGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd0aXRsZV9jaGFuZ2VkJywgb25UaXRsZUNoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvblRpdGxlQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblZpc2libGVDaGFuZ2VkKSB7XG4gICAgICBpZiAodmlzaWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih2aXNpYmxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFZpc2libGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd2aXNpYmxlX2NoYW5nZWQnLCBvblZpc2libGVDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25WaXNpYmxlQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblppbmRleENoYW5nZWQpIHtcbiAgICAgIGlmICh6SW5kZXhDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoekluZGV4Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFppbmRleENoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25aaW5kZXhDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIG1hcmtlck9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGQoX29iamVjdFNwcmVhZCRkKF9vYmplY3RTcHJlYWQkZCh7fSwgb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQ1KSwgY2x1c3RlcmVyID8gZGVmYXVsdE9wdGlvbnMkNSA6IHtcbiAgICAgIG1hcFxuICAgIH0pLCB7fSwge1xuICAgICAgcG9zaXRpb25cbiAgICB9KTtcbiAgICB2YXIgbWFya2VyID0gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihtYXJrZXJPcHRpb25zKTtcbiAgICBpZiAoY2x1c3RlcmVyKSB7XG4gICAgICBjbHVzdGVyZXIuYWRkTWFya2VyKG1hcmtlciwgISFub0NsdXN0ZXJlclJlZHJhdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlci5zZXRNYXAobWFwKTtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBtYXJrZXIuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtYXJrZXIuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtYXJrZXIuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xpY2thYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbWFya2VyLnNldENsaWNrYWJsZShjbGlja2FibGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnNvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcmtlci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gICAgaWYgKGljb24pIHtcbiAgICAgIG1hcmtlci5zZXRJY29uKGljb24pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbWFya2VyLnNldExhYmVsKGxhYmVsKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbWFya2VyLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgfVxuICAgIGlmIChzaGFwZSkge1xuICAgICAgbWFya2VyLnNldFNoYXBlKHNoYXBlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcmtlci5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgbWFya2VyLnNldFpJbmRleCh6SW5kZXgpO1xuICAgIH1cbiAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgfVxuICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgICBpZiAob25EcmFnKSB7XG4gICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZHJhZycsIG9uRHJhZykpO1xuICAgIH1cbiAgICBpZiAob25DbGlja2FibGVDaGFuZ2VkKSB7XG4gICAgICBzZXRDbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY2xpY2thYmxlX2NoYW5nZWQnLCBvbkNsaWNrYWJsZUNoYW5nZWQpKTtcbiAgICB9XG4gICAgaWYgKG9uQ3Vyc29yQ2hhbmdlZCkge1xuICAgICAgc2V0Q3Vyc29yQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2N1cnNvcl9jaGFuZ2VkJywgb25DdXJzb3JDaGFuZ2VkKSk7XG4gICAgfVxuICAgIGlmIChvbkFuaW1hdGlvbkNoYW5nZWQpIHtcbiAgICAgIHNldEFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdhbmltYXRpb25fY2hhbmdlZCcsIG9uQW5pbWF0aW9uQ2hhbmdlZCkpO1xuICAgIH1cbiAgICBpZiAob25EcmFnZ2FibGVDaGFuZ2VkKSB7XG4gICAgICBzZXREcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZHJhZ2dhYmxlX2NoYW5nZWQnLCBvbkRyYWdnYWJsZUNoYW5nZWQpKTtcbiAgICB9XG4gICAgaWYgKG9uRmxhdENoYW5nZWQpIHtcbiAgICAgIHNldEZsYXRDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZmxhdF9jaGFuZ2VkJywgb25GbGF0Q2hhbmdlZCkpO1xuICAgIH1cbiAgICBpZiAob25JY29uQ2hhbmdlZCkge1xuICAgICAgc2V0SWNvbkNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdpY29uX2NoYW5nZWQnLCBvbkljb25DaGFuZ2VkKSk7XG4gICAgfVxuICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgfVxuICAgIGlmIChvblNoYXBlQ2hhbmdlZCkge1xuICAgICAgc2V0U2hhcGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnc2hhcGVfY2hhbmdlZCcsIG9uU2hhcGVDaGFuZ2VkKSk7XG4gICAgfVxuICAgIGlmIChvblRpdGxlQ2hhbmdlZCkge1xuICAgICAgc2V0VGl0bGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAndGl0bGVfY2hhbmdlZCcsIG9uVGl0bGVDaGFuZ2VkKSk7XG4gICAgfVxuICAgIGlmIChvblZpc2libGVDaGFuZ2VkKSB7XG4gICAgICBzZXRWaXNpYmxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3Zpc2libGVfY2hhbmdlZCcsIG9uVmlzaWJsZUNoYW5nZWQpKTtcbiAgICB9XG4gICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgc2V0WmluZGV4Q2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgfVxuICAgIHNldEluc3RhbmNlKG1hcmtlcik7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKG1hcmtlcik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY3Vyc29yQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGN1cnNvckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoZmxhdENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihmbGF0Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChpY29uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGljb25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aXRsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAodmlzaWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih2aXNpYmxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh6SW5kZXhDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoekluZGV4Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgb25Vbm1vdW50KG1hcmtlcik7XG4gICAgICB9XG4gICAgICBpZiAoY2x1c3RlcmVyKSB7XG4gICAgICAgIGNsdXN0ZXJlci5yZW1vdmVNYXJrZXIobWFya2VyLCAhIW5vQ2x1c3RlcmVyUmVkcmF3KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgY2h4ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNoaWxkcmVuID8gQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudENoaWxkID0gY2hpbGQ7XG4gICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGVsZW1lbnRDaGlsZCwge1xuICAgICAgICBhbmNob3I6IGluc3RhbmNlXG4gICAgICB9KTtcbiAgICB9KSA6IG51bGw7XG4gIH0sIFtjaGlsZHJlbiwgaW5zdGFuY2VdKTtcbiAgcmV0dXJuIGpzeChGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBjaHhcbiAgfSkgfHwgbnVsbDtcbn1cbnZhciBNYXJrZXJGID0gbWVtbyhNYXJrZXJGdW5jdGlvbmFsKTtcbmNsYXNzIE1hcmtlciBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lzdGVyZWRFdmVudHNcIiwgW10pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgbWFya2VyT3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkZChfb2JqZWN0U3ByZWFkJGQoX29iamVjdFNwcmVhZCRkKHt9LCBfdGhpcy5wcm9wcy5vcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zJDUpLCBfdGhpcy5wcm9wcy5jbHVzdGVyZXIgPyBkZWZhdWx0T3B0aW9ucyQ1IDoge1xuICAgICAgICBtYXA6IF90aGlzLmNvbnRleHRcbiAgICAgIH0pLCB7fSwge1xuICAgICAgICBwb3NpdGlvbjogX3RoaXMucHJvcHMucG9zaXRpb25cbiAgICAgIH0pO1xuICAgICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBqdXN0IGRvIHRoaXMgaW4gdGhlIGNvbnRzdHJ1Y3RvciwgYmVjYXVzZSB0aGVcbiAgICAgIC8vIGBNYXBDb250ZXh0YCBtaWdodCBub3QgYmUgZmlsbGVkIGluIHlldC5cbiAgICAgIF90aGlzLm1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobWFya2VyT3B0aW9ucyk7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuY2x1c3RlcmVyKSB7XG4gICAgICAgIF90aGlzLnByb3BzLmNsdXN0ZXJlci5hZGRNYXJrZXIoX3RoaXMubWFya2VyLCAhIV90aGlzLnByb3BzLm5vQ2x1c3RlcmVyUmVkcmF3KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLm1hcmtlci5zZXRNYXAoX3RoaXMuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZixcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGYsXG4gICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgIG5leHRQcm9wczogX3RoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiBfdGhpcy5tYXJrZXJcbiAgICAgIH0pO1xuICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMubWFya2VyKTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGYsXG4gICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRmLFxuICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMubWFya2VyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLm1hcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMubWFya2VyKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgIGlmICh0aGlzLnByb3BzLmNsdXN0ZXJlcikge1xuICAgICAgdGhpcy5wcm9wcy5jbHVzdGVyZXIucmVtb3ZlTWFya2VyKHRoaXMubWFya2VyLCAhIXRoaXMucHJvcHMubm9DbHVzdGVyZXJSZWRyYXcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgIHRoaXMubWFya2VyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW4gPyBDaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnRDaGlsZCA9IGNoaWxkO1xuICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChlbGVtZW50Q2hpbGQsIHtcbiAgICAgICAgYW5jaG9yOiB0aGlzLm1hcmtlclxuICAgICAgfSk7XG4gICAgfSkgOiBudWxsO1xuICAgIHJldHVybiBjaGlsZHJlbiB8fCBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoTWFya2VyLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG52YXIgQ2x1c3Rlckljb24gPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDbHVzdGVySWNvbihjbHVzdGVyLCBzdHlsZXMpIHtcbiAgICBjbHVzdGVyLmdldENsdXN0ZXJlcigpLmV4dGVuZChDbHVzdGVySWNvbiwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICAgIHRoaXMuY2x1c3RlciA9IGNsdXN0ZXI7XG4gICAgdGhpcy5jbHVzdGVyQ2xhc3NOYW1lID0gdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmdldENsdXN0ZXJDbGFzcygpO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbHVzdGVyQ2xhc3NOYW1lO1xuICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLnN1bXMgPSBudWxsO1xuICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLnVybCA9ICcnO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLmFuY2hvclRleHQgPSBbMCwgMF07XG4gICAgdGhpcy5hbmNob3JJY29uID0gWzAsIDBdO1xuICAgIHRoaXMudGV4dENvbG9yID0gJ2JsYWNrJztcbiAgICB0aGlzLnRleHRTaXplID0gMTE7XG4gICAgdGhpcy50ZXh0RGVjb3JhdGlvbiA9ICdub25lJztcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgdGhpcy5mb250U3R5bGUgPSAnbm9ybWFsJztcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSAnQXJpYWwsc2Fucy1zZXJpZic7XG4gICAgdGhpcy5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnMCAwJztcbiAgICB0aGlzLmNNb3VzZURvd25JbkNsdXN0ZXIgPSBudWxsO1xuICAgIHRoaXMuY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gbnVsbDtcbiAgICB0aGlzLnRpbWVPdXQgPSBudWxsO1xuICAgIHRoaXMuc2V0TWFwKGNsdXN0ZXIuZ2V0TWFwKCkpOyAvLyBOb3RlOiB0aGlzIGNhdXNlcyBvbkFkZCB0byBiZSBjYWxsZWRcbiAgICB0aGlzLm9uQm91bmRzQ2hhbmdlZCA9IHRoaXMub25Cb3VuZHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk1vdXNlRG93biA9IHRoaXMub25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTW91c2VPdmVyID0gdGhpcy5vbk1vdXNlT3Zlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25Nb3VzZU91dCA9IHRoaXMub25Nb3VzZU91dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25BZGQgPSB0aGlzLm9uQWRkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vblJlbW92ZSA9IHRoaXMub25SZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRyYXcgPSB0aGlzLmRyYXcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVzZVN0eWxlID0gdGhpcy51c2VTdHlsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0Q2VudGVyID0gdGhpcy5zZXRDZW50ZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFBvc0Zyb21MYXRMbmcgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmcuYmluZCh0aGlzKTtcbiAgfVxuICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Cb3VuZHNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gdGhpcy5jTW91c2VEb3duSW5DbHVzdGVyO1xuICB9O1xuICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Nb3VzZURvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jTW91c2VEb3duSW5DbHVzdGVyID0gdHJ1ZTtcbiAgICB0aGlzLmNEcmFnZ2luZ01hcEJ5Q2x1c3RlciA9IGZhbHNlO1xuICB9O1xuICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHRoaXMuY01vdXNlRG93bkluQ2x1c3RlciA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5jRHJhZ2dpbmdNYXBCeUNsdXN0ZXIpIHtcbiAgICAgIHZhciBtYXJrZXJDbHVzdGVyZXJfMSA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKTtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgY2x1c3RlciBtYXJrZXIgaXMgY2xpY2tlZC5cbiAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNjbGlja1xuICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICAgKiBAZXZlbnRcbiAgICAgICAqL1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXJrZXJDbHVzdGVyZXJfMSwgJ2NsaWNrJywgdGhpcy5jbHVzdGVyKTtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFya2VyQ2x1c3RlcmVyXzEsICdjbHVzdGVyY2xpY2snLCB0aGlzLmNsdXN0ZXIpOyAvLyBkZXByZWNhdGVkIG5hbWVcbiAgICAgIC8vIFRoZSBkZWZhdWx0IGNsaWNrIGhhbmRsZXIgZm9sbG93cy4gRGlzYWJsZSBpdCBieSBzZXR0aW5nXG4gICAgICAvLyB0aGUgem9vbU9uQ2xpY2sgcHJvcGVydHkgdG8gZmFsc2UuXG4gICAgICBpZiAobWFya2VyQ2x1c3RlcmVyXzEuZ2V0Wm9vbU9uQ2xpY2soKSkge1xuICAgICAgICAvLyBab29tIGludG8gdGhlIGNsdXN0ZXIuXG4gICAgICAgIHZhciBtYXhab29tXzEgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXhab29tKCk7XG4gICAgICAgIHZhciBib3VuZHNfMSA9IHRoaXMuY2x1c3Rlci5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIG1hcCA9IG1hcmtlckNsdXN0ZXJlcl8xLmdldE1hcCgpO1xuICAgICAgICBpZiAobWFwICE9PSBudWxsICYmICdmaXRCb3VuZHMnIGluIG1hcCkge1xuICAgICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzXzEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXJlIGlzIGEgZml4IGZvciBJc3N1ZSAxNzAgaGVyZTpcbiAgICAgICAgdGhpcy50aW1lT3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBtYXAgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXAoKTtcbiAgICAgICAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJ2ZpdEJvdW5kcycgaW4gbWFwKSB7XG4gICAgICAgICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpIHx8IDA7XG4gICAgICAgICAgICAvLyBEb24ndCB6b29tIGJleW9uZCB0aGUgbWF4IHpvb20gbGV2ZWxcbiAgICAgICAgICAgIGlmIChtYXhab29tXzEgIT09IG51bGwgJiYgem9vbSA+IG1heFpvb21fMSkge1xuICAgICAgICAgICAgICBtYXAuc2V0Wm9vbShtYXhab29tXzEgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGV2ZW50IHByb3BhZ2F0aW9uIHRvIHRoZSBtYXA6XG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENsdXN0ZXJJY29uLnByb3RvdHlwZS5vbk1vdXNlT3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG92ZXIgYSBjbHVzdGVyIG1hcmtlci5cbiAgICAgKiBAbmFtZSBNYXJrZXJDbHVzdGVyZXIjbW91c2VvdmVyXG4gICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgdGhlIG1vdXNlIG1vdmVkIG92ZXIuXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCksICdtb3VzZW92ZXInLCB0aGlzLmNsdXN0ZXIpO1xuICB9O1xuICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25Nb3VzZU91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG91dCBvZiBhIGNsdXN0ZXIgbWFya2VyLlxuICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNtb3VzZW91dFxuICAgICAqIEBwYXJhbSB7Q2x1c3Rlcn0gYyBUaGUgY2x1c3RlciB0aGF0IHRoZSBtb3VzZSBtb3ZlZCBvdXQgb2YuXG4gICAgICogQGV2ZW50XG4gICAgICovXG4gICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCksICdtb3VzZW91dCcsIHRoaXMuY2x1c3Rlcik7XG4gIH07XG4gIENsdXN0ZXJJY29uLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5nZXRQYW5lcygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3ZlcmxheU1vdXNlVGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwICE9PSBudWxsKSB7XG4gICAgICAvLyBGaXggZm9yIElzc3VlIDE1N1xuICAgICAgdGhpcy5ib3VuZHNDaGFuZ2VkTGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdib3VuZHNfY2hhbmdlZCcsIHRoaXMub25Cb3VuZHNDaGFuZ2VkKTtcbiAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgfVxuICB9O1xuICBDbHVzdGVySWNvbi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGl2ICYmIHRoaXMuZGl2LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgaWYgKHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgIGlmICh0aGlzLnRpbWVPdXQgIT09IG51bGwpIHtcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXQpO1xuICAgICAgICB0aGlzLnRpbWVPdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJsZSAmJiB0aGlzLmRpdiAhPT0gbnVsbCAmJiB0aGlzLmNlbnRlcikge1xuICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zRnJvbUxhdExuZyh0aGlzLmNlbnRlcik7XG4gICAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSBwb3MgIT09IG51bGwgPyBcIlwiLmNvbmNhdChwb3MueSwgXCJweFwiKSA6ICcwJztcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmxlZnQgPSBwb3MgIT09IG51bGwgPyBcIlwiLmNvbmNhdChwb3MueCwgXCJweFwiKSA6ICcwJztcbiAgICB9XG4gIH07XG4gIENsdXN0ZXJJY29uLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gIH07XG4gIENsdXN0ZXJJY29uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGlmICh0aGlzLmRpdiAmJiB0aGlzLmNlbnRlcikge1xuICAgICAgdmFyIGRpdlRpdGxlID0gdGhpcy5zdW1zID09PSBudWxsIHx8IHR5cGVvZiB0aGlzLnN1bXMudGl0bGUgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc3Vtcy50aXRsZSA9PT0gJycgPyB0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCkuZ2V0VGl0bGUoKSA6IHRoaXMuc3Vtcy50aXRsZTtcbiAgICAgIC8vIE5PVEU6IHZhbHVlcyBtdXN0IGJlIHNwZWNpZmllZCBpbiBweCB1bml0c1xuICAgICAgdmFyIGJwID0gdGhpcy5iYWNrZ3JvdW5kUG9zaXRpb24uc3BsaXQoJyAnKTtcbiAgICAgIHZhciBzcHJpdGVIID0gcGFyc2VJbnQoKChfYSA9IGJwWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpKSB8fCAnMCcsIDEwKTtcbiAgICAgIHZhciBzcHJpdGVWID0gcGFyc2VJbnQoKChfYiA9IGJwWzFdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpKSB8fCAnMCcsIDEwKTtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmdldFBvc0Zyb21MYXRMbmcodGhpcy5jZW50ZXIpO1xuICAgICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJjdXJzb3I6IHBvaW50ZXI7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIi5jb25jYXQocG9zICE9PSBudWxsID8gXCJcIi5jb25jYXQocG9zLnksIFwicHhcIikgOiAnMCcsIFwiOyBsZWZ0OiBcIikuY29uY2F0KHBvcyAhPT0gbnVsbCA/IFwiXCIuY29uY2F0KHBvcy54LCBcInB4XCIpIDogJzAnLCBcIjsgd2lkdGg6IFwiKS5jb25jYXQodGhpcy53aWR0aCwgXCJweDsgaGVpZ2h0OiBcIikuY29uY2F0KHRoaXMuaGVpZ2h0LCBcInB4OyBcIikpO1xuICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgaW1nLmFsdCA9IGRpdlRpdGxlO1xuICAgICAgaW1nLnNyYyA9IHRoaXMudXJsO1xuICAgICAgaW1nLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIGltZy5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIuY29uY2F0KHNwcml0ZVYsIFwicHg7IGxlZnQ6IFwiKS5jb25jYXQoc3ByaXRlSCwgXCJweFwiKSk7XG4gICAgICBpZiAoIXRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5lbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgICBpbWcuc3R5bGUuY2xpcCA9IFwicmVjdCgtXCIuY29uY2F0KHNwcml0ZVYsIFwicHgsIC1cIikuY29uY2F0KHNwcml0ZUggKyB0aGlzLndpZHRoLCBcInB4LCAtXCIpLmNvbmNhdChzcHJpdGVWICsgdGhpcy5oZWlnaHQsIFwiLCAtXCIpLmNvbmNhdChzcHJpdGVILCBcIilcIik7XG4gICAgICB9XG4gICAgICB2YXIgdGV4dEVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGV4dEVsbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogXCIuY29uY2F0KHRoaXMuYW5jaG9yVGV4dFswXSwgXCJweDsgbGVmdDogXCIpLmNvbmNhdCh0aGlzLmFuY2hvclRleHRbMV0sIFwicHg7IGNvbG9yOiBcIikuY29uY2F0KHRoaXMudGV4dENvbG9yLCBcIjsgZm9udC1zaXplOiBcIikuY29uY2F0KHRoaXMudGV4dFNpemUsIFwicHg7IGZvbnQtZmFtaWx5OiBcIikuY29uY2F0KHRoaXMuZm9udEZhbWlseSwgXCI7IGZvbnQtd2VpZ2h0OiBcIikuY29uY2F0KHRoaXMuZm9udFdlaWdodCwgXCI7IGZvbnRTdHlsZTogXCIpLmNvbmNhdCh0aGlzLmZvbnRTdHlsZSwgXCI7IHRleHQtZGVjb3JhdGlvbjogXCIpLmNvbmNhdCh0aGlzLnRleHREZWNvcmF0aW9uLCBcIjsgdGV4dC1hbGlnbjogY2VudGVyOyB3aWR0aDogXCIpLmNvbmNhdCh0aGlzLndpZHRoLCBcInB4OyBsaW5lLWhlaWdodDogXCIpLmNvbmNhdCh0aGlzLmhlaWdodCwgXCJweFwiKSk7XG4gICAgICBpZiAoKF9jID0gdGhpcy5zdW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudGV4dCkgdGV4dEVsbS5pbm5lclRleHQgPSBcIlwiLmNvbmNhdCgoX2QgPSB0aGlzLnN1bXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50ZXh0KTtcbiAgICAgIGlmICgoX2UgPSB0aGlzLnN1bXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5odG1sKSB0ZXh0RWxtLmlubmVySFRNTCA9IFwiXCIuY29uY2F0KChfZiA9IHRoaXMuc3VtcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmh0bWwpO1xuICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gJyc7XG4gICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGV4dEVsbSk7XG4gICAgICB0aGlzLmRpdi50aXRsZSA9IGRpdlRpdGxlO1xuICAgICAgdGhpcy5kaXYuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICB9O1xuICBDbHVzdGVySWNvbi5wcm90b3R5cGUudXNlU3R5bGUgPSBmdW5jdGlvbiAoc3Vtcykge1xuICAgIHRoaXMuc3VtcyA9IHN1bXM7XG4gICAgdmFyIHN0eWxlcyA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5nZXRTdHlsZXMoKTtcbiAgICB2YXIgc3R5bGUgPSBzdHlsZXNbTWF0aC5taW4oc3R5bGVzLmxlbmd0aCAtIDEsIE1hdGgubWF4KDAsIHN1bXMuaW5kZXggLSAxKSldO1xuICAgIGlmIChzdHlsZSkge1xuICAgICAgdGhpcy51cmwgPSBzdHlsZS51cmw7XG4gICAgICB0aGlzLmhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICAgIHRoaXMud2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGlmIChzdHlsZS5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcIlwiLmNvbmNhdCh0aGlzLmNsdXN0ZXJDbGFzc05hbWUsIFwiIFwiKS5jb25jYXQoc3R5bGUuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5jaG9yVGV4dCA9IHN0eWxlLmFuY2hvclRleHQgfHwgWzAsIDBdO1xuICAgICAgdGhpcy5hbmNob3JJY29uID0gc3R5bGUuYW5jaG9ySWNvbiB8fCBbdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoIC8gMl07XG4gICAgICB0aGlzLnRleHRDb2xvciA9IHN0eWxlLnRleHRDb2xvciB8fCAnYmxhY2snO1xuICAgICAgdGhpcy50ZXh0U2l6ZSA9IHN0eWxlLnRleHRTaXplIHx8IDExO1xuICAgICAgdGhpcy50ZXh0RGVjb3JhdGlvbiA9IHN0eWxlLnRleHREZWNvcmF0aW9uIHx8ICdub25lJztcbiAgICAgIHRoaXMuZm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgfHwgJ2JvbGQnO1xuICAgICAgdGhpcy5mb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgfHwgJ25vcm1hbCc7XG4gICAgICB0aGlzLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5IHx8ICdBcmlhbCxzYW5zLXNlcmlmJztcbiAgICAgIHRoaXMuYmFja2dyb3VuZFBvc2l0aW9uID0gc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uIHx8ICcwIDAnO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3Rlckljb24ucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjZW50ZXIpIHtcbiAgICB0aGlzLmNlbnRlciA9IGNlbnRlcjtcbiAgfTtcbiAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmdldFBvc0Zyb21MYXRMbmcgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgdmFyIHBvcyA9IHRoaXMuZ2V0UHJvamVjdGlvbigpLmZyb21MYXRMbmdUb0RpdlBpeGVsKGxhdGxuZyk7XG4gICAgaWYgKHBvcyAhPT0gbnVsbCkge1xuICAgICAgcG9zLnggLT0gdGhpcy5hbmNob3JJY29uWzFdO1xuICAgICAgcG9zLnkgLT0gdGhpcy5hbmNob3JJY29uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xuICB9O1xuICByZXR1cm4gQ2x1c3Rlckljb247XG59KCk7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbnZhciBDbHVzdGVyJDEgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDbHVzdGVyKG1hcmtlckNsdXN0ZXJlcikge1xuICAgIHRoaXMubWFya2VyQ2x1c3RlcmVyID0gbWFya2VyQ2x1c3RlcmVyO1xuICAgIHRoaXMubWFwID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0TWFwKCk7XG4gICAgdGhpcy5ncmlkU2l6ZSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEdyaWRTaXplKCk7XG4gICAgdGhpcy5taW5DbHVzdGVyU2l6ZSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldE1pbmltdW1DbHVzdGVyU2l6ZSgpO1xuICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEF2ZXJhZ2VDZW50ZXIoKTtcbiAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICB0aGlzLmNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgdGhpcy5jbHVzdGVySWNvbiA9IG5ldyBDbHVzdGVySWNvbih0aGlzLCB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRTdHlsZXMoKSk7XG4gICAgdGhpcy5nZXRTaXplID0gdGhpcy5nZXRTaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRNYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRDZW50ZXIgPSB0aGlzLmdldENlbnRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0TWFwID0gdGhpcy5nZXRNYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldENsdXN0ZXJlciA9IHRoaXMuZ2V0Q2x1c3RlcmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRCb3VuZHMgPSB0aGlzLmdldEJvdW5kcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlID0gdGhpcy5yZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1hcmtlciA9IHRoaXMuYWRkTWFya2VyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc01hcmtlckluQ2x1c3RlckJvdW5kcyA9IHRoaXMuaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuY2FsY3VsYXRlQm91bmRzLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVJY29uID0gdGhpcy51cGRhdGVJY29uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc01hcmtlckFscmVhZHlBZGRlZCA9IHRoaXMuaXNNYXJrZXJBbHJlYWR5QWRkZWQuYmluZCh0aGlzKTtcbiAgfVxuICBDbHVzdGVyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICB9O1xuICBDbHVzdGVyLnByb3RvdHlwZS5nZXRNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlcnM7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jZW50ZXI7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmdldE1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXA7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmdldENsdXN0ZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXJDbHVzdGVyZXI7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyh0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIpO1xuICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBtYXJrZXJzXzEgPSBtYXJrZXJzOyBfaSA8IG1hcmtlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzXzFbX2ldO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgYm91bmRzLmV4dGVuZChwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZHM7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsdXN0ZXJJY29uLnNldE1hcChudWxsKTtcbiAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRlbGV0ZSB0aGlzLm1hcmtlcnM7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuaXNNYXJrZXJBbHJlYWR5QWRkZWQobWFya2VyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2VudGVyKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICB0aGlzLmNlbnRlciA9IHBvc2l0aW9uO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5hdmVyYWdlQ2VudGVyKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSB0aGlzLm1hcmtlcnMubGVuZ3RoICsgMTtcbiAgICAgICAgICB0aGlzLmNlbnRlciA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcoKHRoaXMuY2VudGVyLmxhdCgpICogKGxlbmd0aF8xIC0gMSkgKyBwb3NpdGlvbi5sYXQoKSkgLyBsZW5ndGhfMSwgKHRoaXMuY2VudGVyLmxuZygpICogKGxlbmd0aF8xIC0gMSkgKyBwb3NpdGlvbi5sbmcoKSkgLyBsZW5ndGhfMSk7XG4gICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtYXJrZXIuaXNBZGRlZCA9IHRydWU7XG4gICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICB2YXIgbWF4Wm9vbSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldE1heFpvb20oKTtcbiAgICB2YXIgem9vbSA9IChfYSA9IHRoaXMubWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Wm9vbSgpO1xuICAgIGlmIChtYXhab29tICE9PSBudWxsICYmIHR5cGVvZiB6b29tICE9PSAndW5kZWZpbmVkJyAmJiB6b29tID4gbWF4Wm9vbSkge1xuICAgICAgLy8gWm9vbWVkIGluIHBhc3QgbWF4IHpvb20sIHNvIHNob3cgdGhlIG1hcmtlci5cbiAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMubWFwKSB7XG4gICAgICAgIG1hcmtlci5zZXRNYXAodGhpcy5tYXApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobUNvdW50IDwgdGhpcy5taW5DbHVzdGVyU2l6ZSkge1xuICAgICAgLy8gTWluIGNsdXN0ZXIgc2l6ZSBub3QgcmVhY2hlZCBzbyBzaG93IHRoZSBtYXJrZXIuXG4gICAgICBpZiAobWFya2VyLmdldE1hcCgpICE9PSB0aGlzLm1hcCkge1xuICAgICAgICBtYXJrZXIuc2V0TWFwKHRoaXMubWFwKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1Db3VudCA9PT0gdGhpcy5taW5DbHVzdGVyU2l6ZSkge1xuICAgICAgLy8gSGlkZSB0aGUgbWFya2VycyB0aGF0IHdlcmUgc2hvd2luZy5cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSB0aGlzLm1hcmtlcnM7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBtYXJrZXJFbGVtZW50ID0gX2JbX2ldO1xuICAgICAgICBtYXJrZXJFbGVtZW50LnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIENsdXN0ZXIucHJvdG90eXBlLmlzTWFya2VySW5DbHVzdGVyQm91bmRzID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgIGlmICh0aGlzLmJvdW5kcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzLmNvbnRhaW5zKHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBDbHVzdGVyLnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5ib3VuZHMgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRFeHRlbmRlZEJvdW5kcyhuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlcikpO1xuICB9O1xuICBDbHVzdGVyLnByb3RvdHlwZS51cGRhdGVJY29uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICB2YXIgbWF4Wm9vbSA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldE1heFpvb20oKTtcbiAgICB2YXIgem9vbSA9IChfYSA9IHRoaXMubWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0Wm9vbSgpO1xuICAgIGlmIChtYXhab29tICE9PSBudWxsICYmIHR5cGVvZiB6b29tICE9PSAndW5kZWZpbmVkJyAmJiB6b29tID4gbWF4Wm9vbSkge1xuICAgICAgdGhpcy5jbHVzdGVySWNvbi5oaWRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtQ291bnQgPCB0aGlzLm1pbkNsdXN0ZXJTaXplKSB7XG4gICAgICAvLyBNaW4gY2x1c3RlciBzaXplIG5vdCB5ZXQgcmVhY2hlZC5cbiAgICAgIHRoaXMuY2x1c3Rlckljb24uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgIHRoaXMuY2x1c3Rlckljb24uc2V0Q2VudGVyKHRoaXMuY2VudGVyKTtcbiAgICB9XG4gICAgdGhpcy5jbHVzdGVySWNvbi51c2VTdHlsZSh0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRDYWxjdWxhdG9yKCkodGhpcy5tYXJrZXJzLCB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRTdHlsZXMoKS5sZW5ndGgpKTtcbiAgICB0aGlzLmNsdXN0ZXJJY29uLnNob3coKTtcbiAgfTtcbiAgQ2x1c3Rlci5wcm90b3R5cGUuaXNNYXJrZXJBbHJlYWR5QWRkZWQgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgaWYgKHRoaXMubWFya2Vycy5pbmNsdWRlcykge1xuICAgICAgcmV0dXJuIHRoaXMubWFya2Vycy5pbmNsdWRlcyhtYXJrZXIpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG1hcmtlciA9PT0gdGhpcy5tYXJrZXJzW2ldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIHJldHVybiBDbHVzdGVyO1xufSgpO1xuXG4vKiBnbG9iYWwgZ29vZ2xlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtcmVnZXggKi9cbi8qKlxuICogU3VwcG9ydHMgdXAgdG8gOTAwNzE5OTI1NDc0MDk5MSAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIG1hcmtlcnNcbiAqIHdoaWNoIGlzIG5vdCBhIHByb2JsZW0gYXMgbWF4IGFycmF5IGxlbmd0aCBpcyA0Mjk0OTY3Mjk2ICgyKiozMilcbiAqL1xuZnVuY3Rpb24gQ0FMQ1VMQVRPUihtYXJrZXJzLCBudW1TdHlsZXMpIHtcbiAgdmFyIGNvdW50ID0gbWFya2Vycy5sZW5ndGg7XG4gIHZhciBudW1iZXJPZkRpZ2l0cyA9IGNvdW50LnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgaW5kZXggPSBNYXRoLm1pbihudW1iZXJPZkRpZ2l0cywgbnVtU3R5bGVzKTtcbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBjb3VudC50b1N0cmluZygpLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICB0aXRsZTogJydcbiAgfTtcbn1cbnZhciBCQVRDSF9TSVpFID0gMjAwMDtcbnZhciBCQVRDSF9TSVpFX0lFID0gNTAwO1xudmFyIElNQUdFX1BBVEggPSAnaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvZXhhbXBsZXMvbWFya2VyY2x1c3RlcmVyL20nO1xudmFyIElNQUdFX0VYVEVOU0lPTiA9ICdwbmcnO1xudmFyIElNQUdFX1NJWkVTID0gWzUzLCA1NiwgNjYsIDc4LCA5MF07XG52YXIgQ0xVU1RFUkVSX0NMQVNTID0gJ2NsdXN0ZXInO1xudmFyIENsdXN0ZXJlciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsdXN0ZXJlcihtYXAsIG9wdE1hcmtlcnMsIG9wdE9wdGlvbnMpIHtcbiAgICBpZiAob3B0TWFya2VycyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRNYXJrZXJzID0gW107XG4gICAgfVxuICAgIGlmIChvcHRPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdE9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5nZXRNaW5pbXVtQ2x1c3RlclNpemUgPSB0aGlzLmdldE1pbmltdW1DbHVzdGVyU2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0TWluaW11bUNsdXN0ZXJTaXplID0gdGhpcy5zZXRNaW5pbXVtQ2x1c3RlclNpemUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEVuYWJsZVJldGluYUljb25zID0gdGhpcy5nZXRFbmFibGVSZXRpbmFJY29ucy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0RW5hYmxlUmV0aW5hSWNvbnMgPSB0aGlzLnNldEVuYWJsZVJldGluYUljb25zLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyID0gdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRJbWFnZUV4dGVuc2lvbiA9IHRoaXMuZ2V0SW1hZ2VFeHRlbnNpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldEltYWdlRXh0ZW5zaW9uID0gdGhpcy5zZXRJbWFnZUV4dGVuc2lvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0RXh0ZW5kZWRCb3VuZHMgPSB0aGlzLmdldEV4dGVuZGVkQm91bmRzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRBdmVyYWdlQ2VudGVyID0gdGhpcy5nZXRBdmVyYWdlQ2VudGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRBdmVyYWdlQ2VudGVyID0gdGhpcy5zZXRBdmVyYWdlQ2VudGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRUb3RhbENsdXN0ZXJzID0gdGhpcy5nZXRUb3RhbENsdXN0ZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5maXRNYXBUb01hcmtlcnMgPSB0aGlzLmZpdE1hcFRvTWFya2Vycy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SWdub3JlSGlkZGVuID0gdGhpcy5nZXRJZ25vcmVIaWRkZW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldElnbm9yZUhpZGRlbiA9IHRoaXMuc2V0SWdub3JlSGlkZGVuLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRDbHVzdGVyQ2xhc3MgPSB0aGlzLmdldENsdXN0ZXJDbGFzcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0Q2x1c3RlckNsYXNzID0gdGhpcy5zZXRDbHVzdGVyQ2xhc3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFRvdGFsTWFya2VycyA9IHRoaXMuZ2V0VG90YWxNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRab29tT25DbGljayA9IHRoaXMuZ2V0Wm9vbU9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldFpvb21PbkNsaWNrID0gdGhpcy5zZXRab29tT25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0QmF0Y2hTaXplSUUgPSB0aGlzLmdldEJhdGNoU2l6ZUlFLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRCYXRjaFNpemVJRSA9IHRoaXMuc2V0QmF0Y2hTaXplSUUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZUNsdXN0ZXJzID0gdGhpcy5jcmVhdGVDbHVzdGVycy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25ab29tQ2hhbmdlZCA9IHRoaXMub25ab29tQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SW1hZ2VTaXplcyA9IHRoaXMuZ2V0SW1hZ2VTaXplcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0SW1hZ2VTaXplcyA9IHRoaXMuc2V0SW1hZ2VTaXplcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0Q2FsY3VsYXRvciA9IHRoaXMuZ2V0Q2FsY3VsYXRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0Q2FsY3VsYXRvciA9IHRoaXMuc2V0Q2FsY3VsYXRvci5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlTWFya2VycyA9IHRoaXMucmVtb3ZlTWFya2Vycy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVzZXRWaWV3cG9ydCA9IHRoaXMucmVzZXRWaWV3cG9ydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0SW1hZ2VQYXRoID0gdGhpcy5nZXRJbWFnZVBhdGguYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldEltYWdlUGF0aCA9IHRoaXMuc2V0SW1hZ2VQYXRoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wdXNoTWFya2VyVG8gPSB0aGlzLnB1c2hNYXJrZXJUby5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlTWFya2VyID0gdGhpcy5yZW1vdmVNYXJrZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNsZWFyTWFya2VycyA9IHRoaXMuY2xlYXJNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXR1cFN0eWxlcyA9IHRoaXMuc2V0dXBTdHlsZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEdyaWRTaXplID0gdGhpcy5nZXRHcmlkU2l6ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0R3JpZFNpemUgPSB0aGlzLnNldEdyaWRTaXplLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRDbHVzdGVycyA9IHRoaXMuZ2V0Q2x1c3RlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldE1heFpvb20gPSB0aGlzLmdldE1heFpvb20uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldE1heFpvb20gPSB0aGlzLnNldE1heFpvb20uYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldE1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZE1hcmtlcnMgPSB0aGlzLmFkZE1hcmtlcnMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldFN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRTdHlsZXMgPSB0aGlzLnNldFN0eWxlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkTWFya2VyID0gdGhpcy5hZGRNYXJrZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUmVtb3ZlID0gdGhpcy5vblJlbW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0VGl0bGUgPSB0aGlzLmdldFRpdGxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRUaXRsZSA9IHRoaXMuc2V0VGl0bGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlcGFpbnQgPSB0aGlzLnJlcGFpbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uSWRsZSA9IHRoaXMub25JZGxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWRyYXcgPSB0aGlzLnJlZHJhdy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25BZGQgPSB0aGlzLm9uQWRkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcyk7XG4gICAgdGhpcy5leHRlbmQgPSB0aGlzLmV4dGVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZXh0ZW5kKENsdXN0ZXJlciwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuYWN0aXZlTWFwID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5ncmlkU2l6ZSA9IG9wdE9wdGlvbnMuZ3JpZFNpemUgfHwgNjA7XG4gICAgdGhpcy5taW5DbHVzdGVyU2l6ZSA9IG9wdE9wdGlvbnMubWluaW11bUNsdXN0ZXJTaXplIHx8IDI7XG4gICAgdGhpcy5tYXhab29tID0gb3B0T3B0aW9ucy5tYXhab29tIHx8IG51bGw7XG4gICAgdGhpcy5zdHlsZXMgPSBvcHRPcHRpb25zLnN0eWxlcyB8fCBbXTtcbiAgICB0aGlzLnRpdGxlID0gb3B0T3B0aW9ucy50aXRsZSB8fCAnJztcbiAgICB0aGlzLnpvb21PbkNsaWNrID0gdHJ1ZTtcbiAgICBpZiAob3B0T3B0aW9ucy56b29tT25DbGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnpvb21PbkNsaWNrID0gb3B0T3B0aW9ucy56b29tT25DbGljaztcbiAgICB9XG4gICAgdGhpcy5hdmVyYWdlQ2VudGVyID0gZmFsc2U7XG4gICAgaWYgKG9wdE9wdGlvbnMuYXZlcmFnZUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmF2ZXJhZ2VDZW50ZXIgPSBvcHRPcHRpb25zLmF2ZXJhZ2VDZW50ZXI7XG4gICAgfVxuICAgIHRoaXMuaWdub3JlSGlkZGVuID0gZmFsc2U7XG4gICAgaWYgKG9wdE9wdGlvbnMuaWdub3JlSGlkZGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuaWdub3JlSGlkZGVuID0gb3B0T3B0aW9ucy5pZ25vcmVIaWRkZW47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnMgPSBmYWxzZTtcbiAgICBpZiAob3B0T3B0aW9ucy5lbmFibGVSZXRpbmFJY29ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gb3B0T3B0aW9ucy5lbmFibGVSZXRpbmFJY29ucztcbiAgICB9XG4gICAgdGhpcy5pbWFnZVBhdGggPSBvcHRPcHRpb25zLmltYWdlUGF0aCB8fCBJTUFHRV9QQVRIO1xuICAgIHRoaXMuaW1hZ2VFeHRlbnNpb24gPSBvcHRPcHRpb25zLmltYWdlRXh0ZW5zaW9uIHx8IElNQUdFX0VYVEVOU0lPTjtcbiAgICB0aGlzLmltYWdlU2l6ZXMgPSBvcHRPcHRpb25zLmltYWdlU2l6ZXMgfHwgSU1BR0VfU0laRVM7XG4gICAgdGhpcy5jYWxjdWxhdG9yID0gb3B0T3B0aW9ucy5jYWxjdWxhdG9yIHx8IENBTENVTEFUT1I7XG4gICAgdGhpcy5iYXRjaFNpemUgPSBvcHRPcHRpb25zLmJhdGNoU2l6ZSB8fCBCQVRDSF9TSVpFO1xuICAgIHRoaXMuYmF0Y2hTaXplSUUgPSBvcHRPcHRpb25zLmJhdGNoU2l6ZUlFIHx8IEJBVENIX1NJWkVfSUU7XG4gICAgdGhpcy5jbHVzdGVyQ2xhc3MgPSBvcHRPcHRpb25zLmNsdXN0ZXJDbGFzcyB8fCBDTFVTVEVSRVJfQ0xBU1M7XG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdtc2llJykgIT09IC0xKSB7XG4gICAgICAvLyBUcnkgdG8gYXZvaWQgSUUgdGltZW91dCB3aGVuIHByb2Nlc3NpbmcgYSBodWdlIG51bWJlciBvZiBtYXJrZXJzOlxuICAgICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZUlFO1xuICAgIH1cbiAgICB0aGlzLnRpbWVyUmVmU3RhdGljID0gbnVsbDtcbiAgICB0aGlzLnNldHVwU3R5bGVzKCk7XG4gICAgdGhpcy5hZGRNYXJrZXJzKG9wdE1hcmtlcnMsIHRydWUpO1xuICAgIHRoaXMuc2V0TWFwKG1hcCk7IC8vIE5vdGU6IHRoaXMgY2F1c2VzIG9uQWRkIHRvIGJlIGNhbGxlZFxuICB9XG4gIENsdXN0ZXJlci5wcm90b3R5cGUub25ab29tQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMucmVzZXRWaWV3cG9ydChmYWxzZSk7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgdGhpcyBHb29nbGUgYnVnOiB3aGVuIG1hcCBpcyBhdCBsZXZlbCAwIGFuZCBcIi1cIiBvZlxuICAgIC8vIHpvb20gc2xpZGVyIGlzIGNsaWNrZWQsIGEgXCJ6b29tX2NoYW5nZWRcIiBldmVudCBpcyBmaXJlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBtYXAgZG9lc24ndCB6b29tIG91dCBhbnkgZnVydGhlci4gSW4gdGhpcyBzaXR1YXRpb24sIG5vIFwiaWRsZVwiXG4gICAgLy8gZXZlbnQgaXMgdHJpZ2dlcmVkIHNvIHRoZSBjbHVzdGVyIG1hcmtlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgIC8vIGRvIG5vdCBnZXQgcmVkcmF3bi4gU2FtZSBnb2VzIGZvciBhIHpvb20gaW4gYXQgbWF4Wm9vbS5cbiAgICBpZiAoKChfYSA9IHRoaXMuZ2V0TWFwKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRab29tKCkpID09PSAodGhpcy5nZXQoJ21pblpvb20nKSB8fCAwKSB8fCAoKF9iID0gdGhpcy5nZXRNYXAoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFpvb20oKSkgPT09IHRoaXMuZ2V0KCdtYXhab29tJykpIHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2lkbGUnKTtcbiAgICB9XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUub25JZGxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgdGhpcy5hY3RpdmVNYXAgPSBtYXA7XG4gICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgdGhpcy5yZXBhaW50KCk7XG4gICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBtYXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB0aGlzLmxpc3RlbmVycyA9IFtnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICd6b29tX2NoYW5nZWQnLCB0aGlzLm9uWm9vbUNoYW5nZWQpLCBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdpZGxlJywgdGhpcy5vbklkbGUpXTtcbiAgICB9XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUHV0IGFsbCB0aGUgbWFuYWdlZCBtYXJrZXJzIGJhY2sgb24gdGhlIG1hcDpcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5tYXJrZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG1hcmtlciA9IF9hW19pXTtcbiAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMuYWN0aXZlTWFwKSB7XG4gICAgICAgIG1hcmtlci5zZXRNYXAodGhpcy5hY3RpdmVNYXApO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYWxsIGNsdXN0ZXJzOlxuICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSB0aGlzLmNsdXN0ZXJzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgdmFyIGNsdXN0ZXIgPSBfY1tfYl07XG4gICAgICBjbHVzdGVyLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgLy8gUmVtb3ZlIG1hcCBldmVudCBsaXN0ZW5lcnM6XG4gICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHRoaXMubGlzdGVuZXJzOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gX2VbX2RdO1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuYWN0aXZlTWFwID0gbnVsbDtcbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFBhbmVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21Db250YWluZXJQaXhlbFRvTGF0TG5nOiBmdW5jdGlvbiBmcm9tQ29udGFpbmVyUGl4ZWxUb0xhdExuZygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgZnJvbURpdlBpeGVsVG9MYXRMbmc6IGZ1bmN0aW9uIGZyb21EaXZQaXhlbFRvTGF0TG5nKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICBmcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbDogZnVuY3Rpb24gZnJvbUxhdExuZ1RvQ29udGFpbmVyUGl4ZWwoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIGZyb21MYXRMbmdUb0RpdlBpeGVsOiBmdW5jdGlvbiBmcm9tTGF0TG5nVG9EaXZQaXhlbCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0VmlzaWJsZVJlZ2lvbjogZnVuY3Rpb24gZ2V0VmlzaWJsZVJlZ2lvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9LFxuICAgICAgZ2V0V29ybGRXaWR0aDogZnVuY3Rpb24gZ2V0V29ybGRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuYmluZFRvID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybjtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXR1cFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5zdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW1hZ2VTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdHlsZXMucHVzaCh7XG4gICAgICAgIHVybDogXCJcIi5jb25jYXQodGhpcy5pbWFnZVBhdGggKyAoaSArIDEpLCBcIi5cIikuY29uY2F0KHRoaXMuaW1hZ2VFeHRlbnNpb24pLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaW1hZ2VTaXplc1tpXSB8fCAwLFxuICAgICAgICB3aWR0aDogdGhpcy5pbWFnZVNpemVzW2ldIHx8IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5maXRNYXBUb01hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICB2YXIgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcygpO1xuICAgIGZvciAodmFyIF9pID0gMCwgbWFya2Vyc18xID0gbWFya2VyczsgX2kgPCBtYXJrZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc18xW19pXTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGJvdW5kcy5leHRlbmQocG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICBpZiAobWFwICE9PSBudWxsICYmICdmaXRCb3VuZHMnIGluIG1hcCkge1xuICAgICAgbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ncmlkU2l6ZTtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uIChncmlkU2l6ZSkge1xuICAgIHRoaXMuZ3JpZFNpemUgPSBncmlkU2l6ZTtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNaW5pbXVtQ2x1c3RlclNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluQ2x1c3RlclNpemU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWluaW11bUNsdXN0ZXJTaXplID0gZnVuY3Rpb24gKG1pbmltdW1DbHVzdGVyU2l6ZSkge1xuICAgIHRoaXMubWluQ2x1c3RlclNpemUgPSBtaW5pbXVtQ2x1c3RlclNpemU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWF4Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhab29tO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnNldE1heFpvb20gPSBmdW5jdGlvbiAobWF4Wm9vbSkge1xuICAgIHRoaXMubWF4Wm9vbSA9IG1heFpvb207XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0U3R5bGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlcztcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgdGhpcy5zdHlsZXMgPSBzdHlsZXM7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0VGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Wm9vbU9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuem9vbU9uQ2xpY2s7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0Wm9vbU9uQ2xpY2sgPSBmdW5jdGlvbiAoem9vbU9uQ2xpY2spIHtcbiAgICB0aGlzLnpvb21PbkNsaWNrID0gem9vbU9uQ2xpY2s7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0QXZlcmFnZUNlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdmVyYWdlQ2VudGVyO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEF2ZXJhZ2VDZW50ZXIgPSBmdW5jdGlvbiAoYXZlcmFnZUNlbnRlcikge1xuICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IGF2ZXJhZ2VDZW50ZXI7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SWdub3JlSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlnbm9yZUhpZGRlbjtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJZ25vcmVIaWRkZW4gPSBmdW5jdGlvbiAoaWdub3JlSGlkZGVuKSB7XG4gICAgdGhpcy5pZ25vcmVIaWRkZW4gPSBpZ25vcmVIaWRkZW47XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0RW5hYmxlUmV0aW5hSWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlUmV0aW5hSWNvbnM7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0RW5hYmxlUmV0aW5hSWNvbnMgPSBmdW5jdGlvbiAoZW5hYmxlUmV0aW5hSWNvbnMpIHtcbiAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gZW5hYmxlUmV0aW5hSWNvbnM7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VFeHRlbnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VFeHRlbnNpb247XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VFeHRlbnNpb24gPSBmdW5jdGlvbiAoaW1hZ2VFeHRlbnNpb24pIHtcbiAgICB0aGlzLmltYWdlRXh0ZW5zaW9uID0gaW1hZ2VFeHRlbnNpb247XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlUGF0aDtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRJbWFnZVBhdGggPSBmdW5jdGlvbiAoaW1hZ2VQYXRoKSB7XG4gICAgdGhpcy5pbWFnZVBhdGggPSBpbWFnZVBhdGg7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbWFnZVNpemVzO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEltYWdlU2l6ZXMgPSBmdW5jdGlvbiAoaW1hZ2VTaXplcykge1xuICAgIHRoaXMuaW1hZ2VTaXplcyA9IGltYWdlU2l6ZXM7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Q2FsY3VsYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdG9yO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnNldENhbGN1bGF0b3IgPSBmdW5jdGlvbiAoY2FsY3VsYXRvcikge1xuICAgIHRoaXMuY2FsY3VsYXRvciA9IGNhbGN1bGF0b3I7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0QmF0Y2hTaXplSUUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmF0Y2hTaXplSUU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0QmF0Y2hTaXplSUUgPSBmdW5jdGlvbiAoYmF0Y2hTaXplSUUpIHtcbiAgICB0aGlzLmJhdGNoU2l6ZUlFID0gYmF0Y2hTaXplSUU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Q2x1c3RlckNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJDbGFzcztcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRDbHVzdGVyQ2xhc3MgPSBmdW5jdGlvbiAoY2x1c3RlckNsYXNzKSB7XG4gICAgdGhpcy5jbHVzdGVyQ2xhc3MgPSBjbHVzdGVyQ2xhc3M7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXJzO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRDbHVzdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRUb3RhbENsdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzLmxlbmd0aDtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyLCBvcHROb0RyYXcpIHtcbiAgICB0aGlzLnB1c2hNYXJrZXJUbyhtYXJrZXIpO1xuICAgIGlmICghb3B0Tm9EcmF3KSB7XG4gICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMsIG9wdE5vRHJhdykge1xuICAgIGZvciAodmFyIGtleSBpbiBtYXJrZXJzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcmtlcnMsIGtleSkpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNba2V5XTtcbiAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgIHRoaXMucHVzaE1hcmtlclRvKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHROb0RyYXcpIHtcbiAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnB1c2hNYXJrZXJUbyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIElmIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIGFkZCBhIGxpc3RlbmVyIHNvIHdlIGNhbiB1cGRhdGUgdGhlIGNsdXN0ZXJzIG9uIHRoZSBkcmFnZW5kOlxuICAgIGlmIChtYXJrZXIuZ2V0RHJhZ2dhYmxlKCkpIHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZWFkeSkge1xuICAgICAgICAgIG1hcmtlci5pc0FkZGVkID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLnJlbW92ZU1hcmtlcl8gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgaWYgKHRoaXMubWFya2Vycy5pbmRleE9mKSB7XG4gICAgICBpbmRleCA9IHRoaXMubWFya2Vycy5pbmRleE9mKG1hcmtlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IHRoaXMubWFya2Vyc1tpXSkge1xuICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAvLyBNYXJrZXIgaXMgbm90IGluIG91ciBsaXN0IG9mIG1hcmtlcnMsIHNvIGRvIG5vdGhpbmc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgdGhpcy5tYXJrZXJzLnNwbGljZShpbmRleCwgMSk7IC8vIFJlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIGxpc3Qgb2YgbWFuYWdlZCBtYXJrZXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlciwgb3B0Tm9EcmF3KSB7XG4gICAgdmFyIHJlbW92ZWQgPSB0aGlzLnJlbW92ZU1hcmtlcl8obWFya2VyKTtcbiAgICBpZiAoIW9wdE5vRHJhdyAmJiByZW1vdmVkKSB7XG4gICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VycyA9IGZ1bmN0aW9uIChtYXJrZXJzLCBvcHROb0RyYXcpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIF9pID0gMCwgbWFya2Vyc18yID0gbWFya2VyczsgX2kgPCBtYXJrZXJzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc18yW19pXTtcbiAgICAgIHJlbW92ZWQgPSByZW1vdmVkIHx8IHRoaXMucmVtb3ZlTWFya2VyXyhtYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoIW9wdE5vRHJhdyAmJiByZW1vdmVkKSB7XG4gICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuY2xlYXJNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzZXRWaWV3cG9ydCh0cnVlKTtcbiAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvbGRDbHVzdGVycyA9IHRoaXMuY2x1c3RlcnMuc2xpY2UoKTtcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgdGhpcy5yZXNldFZpZXdwb3J0KGZhbHNlKTtcbiAgICB0aGlzLnJlZHJhdygpO1xuICAgIC8vIFJlbW92ZSB0aGUgb2xkIGNsdXN0ZXJzLlxuICAgIC8vIERvIGl0IGluIGEgdGltZW91dCB0byBwcmV2ZW50IGJsaW5raW5nIGVmZmVjdC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uIHRpbWVvdXQoKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIG9sZENsdXN0ZXJzXzEgPSBvbGRDbHVzdGVyczsgX2kgPCBvbGRDbHVzdGVyc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgb2xkQ2x1c3RlciA9IG9sZENsdXN0ZXJzXzFbX2ldO1xuICAgICAgICBvbGRDbHVzdGVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEV4dGVuZGVkQm91bmRzID0gZnVuY3Rpb24gKGJvdW5kcykge1xuICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgLy8gQ29udmVydCB0aGUgcG9pbnRzIHRvIHBpeGVscyBhbmQgdGhlIGV4dGVuZCBvdXQgYnkgdGhlIGdyaWQgc2l6ZS5cbiAgICB2YXIgdHJQaXggPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKFxuICAgIC8vIFR1cm4gdGhlIGJvdW5kcyBpbnRvIGxhdGxuZy5cbiAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sYXQoKSwgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxuZygpKSk7XG4gICAgaWYgKHRyUGl4ICE9PSBudWxsKSB7XG4gICAgICB0clBpeC54ICs9IHRoaXMuZ3JpZFNpemU7XG4gICAgICB0clBpeC55IC09IHRoaXMuZ3JpZFNpemU7XG4gICAgfVxuICAgIHZhciBibFBpeCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoXG4gICAgLy8gVHVybiB0aGUgYm91bmRzIGludG8gbGF0bG5nLlxuICAgIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLmdldFNvdXRoV2VzdCgpLmxhdCgpLCBib3VuZHMuZ2V0U291dGhXZXN0KCkubG5nKCkpKTtcbiAgICBpZiAoYmxQaXggIT09IG51bGwpIHtcbiAgICAgIGJsUGl4LnggLT0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgIGJsUGl4LnkgKz0gdGhpcy5ncmlkU2l6ZTtcbiAgICB9XG4gICAgLy8gRXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgbmV3IGJvdW5kcy5cbiAgICBpZiAodHJQaXggIT09IG51bGwpIHtcbiAgICAgIC8vIENvbnZlcnQgdGhlIHBpeGVsIHBvaW50cyBiYWNrIHRvIExhdExuZyBud1xuICAgICAgdmFyIHBvaW50MSA9IHByb2plY3Rpb24uZnJvbURpdlBpeGVsVG9MYXRMbmcodHJQaXgpO1xuICAgICAgaWYgKHBvaW50MSAhPT0gbnVsbCkge1xuICAgICAgICBib3VuZHMuZXh0ZW5kKHBvaW50MSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChibFBpeCAhPT0gbnVsbCkge1xuICAgICAgLy8gQ29udmVydCB0aGUgcGl4ZWwgcG9pbnRzIGJhY2sgdG8gTGF0TG5nIHN3XG4gICAgICB2YXIgcG9pbnQyID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhibFBpeCk7XG4gICAgICBpZiAocG9pbnQyICE9PSBudWxsKSB7XG4gICAgICAgIGJvdW5kcy5leHRlbmQocG9pbnQyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmVkcmF3cyBhbGwgdGhlIGNsdXN0ZXJzLlxuICAgIHRoaXMuY3JlYXRlQ2x1c3RlcnMoMCk7XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUucmVzZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIChvcHRIaWRlKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCB0aGUgY2x1c3RlcnNcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jbHVzdGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjbHVzdGVyID0gX2FbX2ldO1xuICAgICAgY2x1c3Rlci5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgIC8vIFJlc2V0IHRoZSBtYXJrZXJzIHRvIG5vdCBiZSBhZGRlZCBhbmQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMubWFya2VyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgIHZhciBtYXJrZXIgPSBfY1tfYl07XG4gICAgICBtYXJrZXIuaXNBZGRlZCA9IGZhbHNlO1xuICAgICAgaWYgKG9wdEhpZGUpIHtcbiAgICAgICAgbWFya2VyLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENsdXN0ZXJlci5wcm90b3R5cGUuZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIHZhciBSID0gNjM3MTsgLy8gUmFkaXVzIG9mIHRoZSBFYXJ0aCBpbiBrbVxuICAgIHZhciBkTGF0ID0gKHAyLmxhdCgpIC0gcDEubGF0KCkpICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgZExvbiA9IChwMi5sbmcoKSAtIHAxLmxuZygpKSAqIE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGEgPSBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgKyBNYXRoLmNvcyhwMS5sYXQoKSAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MocDIubGF0KCkgKiBNYXRoLlBJIC8gMTgwKSAqIE1hdGguc2luKGRMb24gLyAyKSAqIE1hdGguc2luKGRMb24gLyAyKTtcbiAgICByZXR1cm4gUiAqICgyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpKTtcbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5pc01hcmtlckluQm91bmRzID0gZnVuY3Rpb24gKG1hcmtlciwgYm91bmRzKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gYm91bmRzLmNvbnRhaW5zKHBvc2l0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZFRvQ2xvc2VzdENsdXN0ZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgdmFyIGNsdXN0ZXI7XG4gICAgdmFyIGRpc3RhbmNlID0gNDAwMDA7IC8vIFNvbWUgbGFyZ2UgbnVtYmVyXG4gICAgdmFyIGNsdXN0ZXJUb0FkZFRvID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jbHVzdGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBjbHVzdGVyRWxlbWVudCA9IF9hW19pXTtcbiAgICAgIGNsdXN0ZXIgPSBjbHVzdGVyRWxlbWVudDtcbiAgICAgIHZhciBjZW50ZXIgPSBjbHVzdGVyLmdldENlbnRlcigpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICBpZiAoY2VudGVyICYmIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZUJldHdlZW5Qb2ludHMoY2VudGVyLCBwb3NpdGlvbik7XG4gICAgICAgIGlmIChkIDwgZGlzdGFuY2UpIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgY2x1c3RlclRvQWRkVG8gPSBjbHVzdGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbHVzdGVyVG9BZGRUbyAmJiBjbHVzdGVyVG9BZGRUby5pc01hcmtlckluQ2x1c3RlckJvdW5kcyhtYXJrZXIpKSB7XG4gICAgICBjbHVzdGVyVG9BZGRUby5hZGRNYXJrZXIobWFya2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2x1c3RlciA9IG5ldyBDbHVzdGVyJDEodGhpcyk7XG4gICAgICBjbHVzdGVyLmFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgIH1cbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5jcmVhdGVDbHVzdGVycyA9IGZ1bmN0aW9uIChpRmlyc3QpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICghdGhpcy5yZWFkeSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDYW5jZWwgcHJldmlvdXMgYmF0Y2ggcHJvY2Vzc2luZyBpZiB3ZSdyZSB3b3JraW5nIG9uIHRoZSBmaXJzdCBiYXRjaDpcbiAgICBpZiAoaUZpcnN0ID09PSAwKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgPGNvZGU+Q2x1c3RlcmVyPC9jb2RlPiBiZWdpbnNcbiAgICAgICAqICBjbHVzdGVyaW5nIG1hcmtlcnMuXG4gICAgICAgKiBAbmFtZSBDbHVzdGVyZXIjY2x1c3RlcmluZ2JlZ2luXG4gICAgICAgKiBAcGFyYW0ge0NsdXN0ZXJlcn0gbWMgVGhlIENsdXN0ZXJlciB3aG9zZSBtYXJrZXJzIGFyZSBiZWluZyBjbHVzdGVyZWQuXG4gICAgICAgKiBAZXZlbnRcbiAgICAgICAqL1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnY2x1c3RlcmluZ2JlZ2luJywgdGhpcyk7XG4gICAgICBpZiAodGhpcy50aW1lclJlZlN0YXRpYyAhPT0gbnVsbCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJSZWZTdGF0aWMpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGVsZXRlIHRoaXMudGltZXJSZWZTdGF0aWM7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHZhciBib3VuZHMgPSBtYXAgIT09IG51bGwgJiYgJ2dldEJvdW5kcycgaW4gbWFwID8gbWFwLmdldEJvdW5kcygpIDogbnVsbDtcbiAgICB2YXIgem9vbSA9IChtYXAgPT09IG51bGwgfHwgbWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXAuZ2V0Wm9vbSgpKSB8fCAwO1xuICAgIC8vIEdldCBvdXIgY3VycmVudCBtYXAgdmlldyBib3VuZHMuXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGJvdW5kcyBvYmplY3Qgc28gd2UgZG9uJ3QgYWZmZWN0IHRoZSBtYXAuXG4gICAgLy9cbiAgICAvLyBTZWUgQ29tbWVudHMgOSAmIDExIG9uIElzc3VlIDM2NTEgcmVsYXRpbmcgdG8gdGhpcyB3b3JrYXJvdW5kIGZvciBhIEdvb2dsZSBNYXBzIGJ1ZzpcbiAgICB2YXIgbWFwQm91bmRzID0gem9vbSA+IDMgPyBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgYm91bmRzID09PSBudWxsIHx8IGJvdW5kcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm91bmRzLmdldE5vcnRoRWFzdCgpKSA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyg4NS4wMjA3MDc3MTc0MzQ3MiwgLTE3OC40ODM4ODQzNDM3NSksIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoLTg1LjA4MTM2NDQ0Mzg0NTQ0LCAxNzguMDAwNDg4NjU2MjUpKTtcbiAgICB2YXIgZXh0ZW5kZWRNYXBCb3VuZHMgPSB0aGlzLmdldEV4dGVuZGVkQm91bmRzKG1hcEJvdW5kcyk7XG4gICAgdmFyIGlMYXN0ID0gTWF0aC5taW4oaUZpcnN0ICsgdGhpcy5iYXRjaFNpemUsIHRoaXMubWFya2Vycy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSBpRmlyc3Q7IGkgPCBpTGFzdDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gdGhpcy5tYXJrZXJzW2ldO1xuICAgICAgaWYgKG1hcmtlciAmJiAhbWFya2VyLmlzQWRkZWQgJiYgdGhpcy5pc01hcmtlckluQm91bmRzKG1hcmtlciwgZXh0ZW5kZWRNYXBCb3VuZHMpICYmICghdGhpcy5pZ25vcmVIaWRkZW4gfHwgdGhpcy5pZ25vcmVIaWRkZW4gJiYgbWFya2VyLmdldFZpc2libGUoKSkpIHtcbiAgICAgICAgdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyKG1hcmtlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpTGFzdCA8IHRoaXMubWFya2Vycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGltZXJSZWZTdGF0aWMgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNyZWF0ZUNsdXN0ZXJzKGlMYXN0KTtcbiAgICAgIH0sIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRpbWVyUmVmU3RhdGljID0gbnVsbDtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSA8Y29kZT5DbHVzdGVyZXI8L2NvZGU+IHN0b3BzXG4gICAgICAgKiAgY2x1c3RlcmluZyBtYXJrZXJzLlxuICAgICAgICogQG5hbWUgQ2x1c3RlcmVyI2NsdXN0ZXJpbmdlbmRcbiAgICAgICAqIEBwYXJhbSB7Q2x1c3RlcmVyfSBtYyBUaGUgQ2x1c3RlcmVyIHdob3NlIG1hcmtlcnMgYXJlIGJlaW5nIGNsdXN0ZXJlZC5cbiAgICAgICAqIEBldmVudFxuICAgICAgICovXG4gICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdjbHVzdGVyaW5nZW5kJywgdGhpcyk7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jbHVzdGVyczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNsdXN0ZXIgPSBfYVtfaV07XG4gICAgICAgIGNsdXN0ZXIudXBkYXRlSWNvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQ2x1c3RlcmVyLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUV4dGVuZChvYmplY3QpIHtcbiAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMucHJvdG90eXBlW3Byb3BdID0gb2JqZWN0LnByb3RvdHlwZVtwcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0uYXBwbHkob2JqMSwgW29iajJdKTtcbiAgfTtcbiAgcmV0dXJuIENsdXN0ZXJlcjtcbn0oKTtcblxuZnVuY3Rpb24gb3duS2V5cyRjKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCRlID0ge1xuICBvbkNsaWNrOiAnY2xpY2snLFxuICBvbkNsdXN0ZXJpbmdCZWdpbjogJ2NsdXN0ZXJpbmdiZWdpbicsXG4gIG9uQ2x1c3RlcmluZ0VuZDogJ2NsdXN0ZXJpbmdlbmQnLFxuICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICBvbk1vdXNlT3ZlcjogJ21vdXNlb3Zlcidcbn07XG52YXIgdXBkYXRlck1hcCRlID0ge1xuICBhdmVyYWdlQ2VudGVyKGluc3RhbmNlLCBhdmVyYWdlQ2VudGVyKSB7XG4gICAgaW5zdGFuY2Uuc2V0QXZlcmFnZUNlbnRlcihhdmVyYWdlQ2VudGVyKTtcbiAgfSxcbiAgYmF0Y2hTaXplSUUoaW5zdGFuY2UsIGJhdGNoU2l6ZUlFKSB7XG4gICAgaW5zdGFuY2Uuc2V0QmF0Y2hTaXplSUUoYmF0Y2hTaXplSUUpO1xuICB9LFxuICBjYWxjdWxhdG9yKGluc3RhbmNlLCBjYWxjdWxhdG9yKSB7XG4gICAgaW5zdGFuY2Uuc2V0Q2FsY3VsYXRvcihjYWxjdWxhdG9yKTtcbiAgfSxcbiAgY2x1c3RlckNsYXNzKGluc3RhbmNlLCBjbHVzdGVyQ2xhc3MpIHtcbiAgICBpbnN0YW5jZS5zZXRDbHVzdGVyQ2xhc3MoY2x1c3RlckNsYXNzKTtcbiAgfSxcbiAgZW5hYmxlUmV0aW5hSWNvbnMoaW5zdGFuY2UsIGVuYWJsZVJldGluYUljb25zKSB7XG4gICAgaW5zdGFuY2Uuc2V0RW5hYmxlUmV0aW5hSWNvbnMoZW5hYmxlUmV0aW5hSWNvbnMpO1xuICB9LFxuICBncmlkU2l6ZShpbnN0YW5jZSwgZ3JpZFNpemUpIHtcbiAgICBpbnN0YW5jZS5zZXRHcmlkU2l6ZShncmlkU2l6ZSk7XG4gIH0sXG4gIGlnbm9yZUhpZGRlbihpbnN0YW5jZSwgaWdub3JlSGlkZGVuKSB7XG4gICAgaW5zdGFuY2Uuc2V0SWdub3JlSGlkZGVuKGlnbm9yZUhpZGRlbik7XG4gIH0sXG4gIGltYWdlRXh0ZW5zaW9uKGluc3RhbmNlLCBpbWFnZUV4dGVuc2lvbikge1xuICAgIGluc3RhbmNlLnNldEltYWdlRXh0ZW5zaW9uKGltYWdlRXh0ZW5zaW9uKTtcbiAgfSxcbiAgaW1hZ2VQYXRoKGluc3RhbmNlLCBpbWFnZVBhdGgpIHtcbiAgICBpbnN0YW5jZS5zZXRJbWFnZVBhdGgoaW1hZ2VQYXRoKTtcbiAgfSxcbiAgaW1hZ2VTaXplcyhpbnN0YW5jZSwgaW1hZ2VTaXplcykge1xuICAgIGluc3RhbmNlLnNldEltYWdlU2l6ZXMoaW1hZ2VTaXplcyk7XG4gIH0sXG4gIG1heFpvb20oaW5zdGFuY2UsIG1heFpvb20pIHtcbiAgICBpbnN0YW5jZS5zZXRNYXhab29tKG1heFpvb20pO1xuICB9LFxuICBtaW5pbXVtQ2x1c3RlclNpemUoaW5zdGFuY2UsIG1pbmltdW1DbHVzdGVyU2l6ZSkge1xuICAgIGluc3RhbmNlLnNldE1pbmltdW1DbHVzdGVyU2l6ZShtaW5pbXVtQ2x1c3RlclNpemUpO1xuICB9LFxuICBzdHlsZXMoaW5zdGFuY2UsIHN0eWxlcykge1xuICAgIGluc3RhbmNlLnNldFN0eWxlcyhzdHlsZXMpO1xuICB9LFxuICB0aXRsZShpbnN0YW5jZSwgdGl0bGUpIHtcbiAgICBpbnN0YW5jZS5zZXRUaXRsZSh0aXRsZSk7XG4gIH0sXG4gIHpvb21PbkNsaWNrKGluc3RhbmNlLCB6b29tT25DbGljaykge1xuICAgIGluc3RhbmNlLnNldFpvb21PbkNsaWNrKHpvb21PbkNsaWNrKTtcbiAgfVxufTtcbnZhciBkZWZhdWx0T3B0aW9ucyQ0ID0ge307XG5mdW5jdGlvbiBNYXJrZXJDbHVzdGVyZXJGdW5jdGlvbmFsKHByb3BzKSB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW4sXG4gICAgb3B0aW9ucyxcbiAgICBhdmVyYWdlQ2VudGVyLFxuICAgIGJhdGNoU2l6ZUlFLFxuICAgIGNhbGN1bGF0b3IsXG4gICAgY2x1c3RlckNsYXNzLFxuICAgIGVuYWJsZVJldGluYUljb25zLFxuICAgIGdyaWRTaXplLFxuICAgIGlnbm9yZUhpZGRlbixcbiAgICBpbWFnZUV4dGVuc2lvbixcbiAgICBpbWFnZVBhdGgsXG4gICAgaW1hZ2VTaXplcyxcbiAgICBtYXhab29tLFxuICAgIG1pbmltdW1DbHVzdGVyU2l6ZSxcbiAgICBzdHlsZXMsXG4gICAgdGl0bGUsXG4gICAgem9vbU9uQ2xpY2ssXG4gICAgb25DbGljayxcbiAgICBvbkNsdXN0ZXJpbmdCZWdpbixcbiAgICBvbkNsdXN0ZXJpbmdFbmQsXG4gICAgb25Nb3VzZU92ZXIsXG4gICAgb25Nb3VzZU91dCxcbiAgICBvbkxvYWQsXG4gICAgb25Vbm1vdW50XG4gIH0gPSBwcm9wcztcbiAgdmFyIFtpbnN0YW5jZSwgc2V0SW5zdGFuY2VdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2NsaWNrTGlzdGVuZXIsIHNldENsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIsIHNldENsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2NsdXN0ZXJpbmdFbmRMaXN0ZW5lciwgc2V0Q2x1c3RlcmluZ0VuZExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlb3V0TGlzdGVuZXIsIHNldE1vdXNlb3V0TGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdmVyTGlzdGVuZXIsIHNldE1vdXNlb3Zlckxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsIGV2ZW50TWFwJGUub25Nb3VzZU91dCwgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VPdXRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZXZlbnRNYXAkZS5vbk1vdXNlT3Zlciwgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsaWNrKSB7XG4gICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsIGV2ZW50TWFwJGUub25DbGljaywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25DbHVzdGVyaW5nQmVnaW4pIHtcbiAgICAgIGlmIChjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRDbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZXZlbnRNYXAkZS5vbkNsdXN0ZXJpbmdCZWdpbiwgb25DbHVzdGVyaW5nQmVnaW4pKTtcbiAgICB9XG4gIH0sIFtvbkNsdXN0ZXJpbmdCZWdpbl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsdXN0ZXJpbmdFbmQpIHtcbiAgICAgIGlmIChjbHVzdGVyaW5nRW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2x1c3RlcmluZ0VuZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldENsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBldmVudE1hcCRlLm9uQ2x1c3RlcmluZ0VuZCwgb25DbHVzdGVyaW5nRW5kKSk7XG4gICAgfVxuICB9LCBbb25DbHVzdGVyaW5nRW5kXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhdmVyYWdlQ2VudGVyICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlck1hcCRlLmF2ZXJhZ2VDZW50ZXIoaW5zdGFuY2UsIGF2ZXJhZ2VDZW50ZXIpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBhdmVyYWdlQ2VudGVyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBiYXRjaFNpemVJRSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5iYXRjaFNpemVJRShpbnN0YW5jZSwgYmF0Y2hTaXplSUUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBiYXRjaFNpemVJRV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY2FsY3VsYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5jYWxjdWxhdG9yKGluc3RhbmNlLCBjYWxjdWxhdG9yKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgY2FsY3VsYXRvcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY2x1c3RlckNsYXNzICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlck1hcCRlLmNsdXN0ZXJDbGFzcyhpbnN0YW5jZSwgY2x1c3RlckNsYXNzKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgY2x1c3RlckNsYXNzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbmFibGVSZXRpbmFJY29ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5lbmFibGVSZXRpbmFJY29ucyhpbnN0YW5jZSwgZW5hYmxlUmV0aW5hSWNvbnMpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBlbmFibGVSZXRpbmFJY29uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ3JpZFNpemUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICB1cGRhdGVyTWFwJGUuZ3JpZFNpemUoaW5zdGFuY2UsIGdyaWRTaXplKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgZ3JpZFNpemVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGlnbm9yZUhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5pZ25vcmVIaWRkZW4oaW5zdGFuY2UsIGlnbm9yZUhpZGRlbik7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIGlnbm9yZUhpZGRlbl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaW1hZ2VFeHRlbnNpb24gIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICB1cGRhdGVyTWFwJGUuaW1hZ2VFeHRlbnNpb24oaW5zdGFuY2UsIGltYWdlRXh0ZW5zaW9uKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgaW1hZ2VFeHRlbnNpb25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGltYWdlUGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVBhdGgoaW5zdGFuY2UsIGltYWdlUGF0aCk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIGltYWdlUGF0aF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgaW1hZ2VTaXplcyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVNpemVzKGluc3RhbmNlLCBpbWFnZVNpemVzKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgaW1hZ2VTaXplc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWF4Wm9vbSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5tYXhab29tKGluc3RhbmNlLCBtYXhab29tKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgbWF4Wm9vbV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgbWluaW11bUNsdXN0ZXJTaXplICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlck1hcCRlLm1pbmltdW1DbHVzdGVyU2l6ZShpbnN0YW5jZSwgbWluaW11bUNsdXN0ZXJTaXplKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgbWluaW11bUNsdXN0ZXJTaXplXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICB1cGRhdGVyTWFwJGUuc3R5bGVzKGluc3RhbmNlLCBzdHlsZXMpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBzdHlsZXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHRpdGxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgdXBkYXRlck1hcCRlLnRpdGxlKGluc3RhbmNlLCB0aXRsZSk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIHRpdGxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB6b29tT25DbGljayAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS56b29tT25DbGljayhpbnN0YW5jZSwgem9vbU9uQ2xpY2spO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCB6b29tT25DbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghbWFwKSByZXR1cm47XG4gICAgdmFyIGNsdXN0ZXJlck9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJGMoe30sIG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnMkNCk7XG4gICAgdmFyIGNsdXN0ZXJlciA9IG5ldyBDbHVzdGVyZXIobWFwLCBbXSwgY2x1c3RlcmVyT3B0aW9ucyk7XG4gICAgaWYgKGF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5hdmVyYWdlQ2VudGVyKGNsdXN0ZXJlciwgYXZlcmFnZUNlbnRlcik7XG4gICAgfVxuICAgIGlmIChiYXRjaFNpemVJRSkge1xuICAgICAgdXBkYXRlck1hcCRlLmJhdGNoU2l6ZUlFKGNsdXN0ZXJlciwgYmF0Y2hTaXplSUUpO1xuICAgIH1cbiAgICBpZiAoY2FsY3VsYXRvcikge1xuICAgICAgdXBkYXRlck1hcCRlLmNhbGN1bGF0b3IoY2x1c3RlcmVyLCBjYWxjdWxhdG9yKTtcbiAgICB9XG4gICAgaWYgKGNsdXN0ZXJDbGFzcykge1xuICAgICAgdXBkYXRlck1hcCRlLmNsdXN0ZXJDbGFzcyhjbHVzdGVyZXIsIGNsdXN0ZXJDbGFzcyk7XG4gICAgfVxuICAgIGlmIChlbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgdXBkYXRlck1hcCRlLmVuYWJsZVJldGluYUljb25zKGNsdXN0ZXJlciwgZW5hYmxlUmV0aW5hSWNvbnMpO1xuICAgIH1cbiAgICBpZiAoZ3JpZFNpemUpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5ncmlkU2l6ZShjbHVzdGVyZXIsIGdyaWRTaXplKTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZUhpZGRlbikge1xuICAgICAgdXBkYXRlck1hcCRlLmlnbm9yZUhpZGRlbihjbHVzdGVyZXIsIGlnbm9yZUhpZGRlbik7XG4gICAgfVxuICAgIGlmIChpbWFnZUV4dGVuc2lvbikge1xuICAgICAgdXBkYXRlck1hcCRlLmltYWdlRXh0ZW5zaW9uKGNsdXN0ZXJlciwgaW1hZ2VFeHRlbnNpb24pO1xuICAgIH1cbiAgICBpZiAoaW1hZ2VQYXRoKSB7XG4gICAgICB1cGRhdGVyTWFwJGUuaW1hZ2VQYXRoKGNsdXN0ZXJlciwgaW1hZ2VQYXRoKTtcbiAgICB9XG4gICAgaWYgKGltYWdlU2l6ZXMpIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVNpemVzKGNsdXN0ZXJlciwgaW1hZ2VTaXplcyk7XG4gICAgfVxuICAgIGlmIChtYXhab29tKSB7XG4gICAgICB1cGRhdGVyTWFwJGUubWF4Wm9vbShjbHVzdGVyZXIsIG1heFpvb20pO1xuICAgIH1cbiAgICBpZiAobWluaW11bUNsdXN0ZXJTaXplKSB7XG4gICAgICB1cGRhdGVyTWFwJGUubWluaW11bUNsdXN0ZXJTaXplKGNsdXN0ZXJlciwgbWluaW11bUNsdXN0ZXJTaXplKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgdXBkYXRlck1hcCRlLnN0eWxlcyhjbHVzdGVyZXIsIHN0eWxlcyk7XG4gICAgfVxuICAgIGlmICh0aXRsZSkge1xuICAgICAgdXBkYXRlck1hcCRlLnRpdGxlKGNsdXN0ZXJlciwgdGl0bGUpO1xuICAgIH1cbiAgICBpZiAoem9vbU9uQ2xpY2spIHtcbiAgICAgIHVwZGF0ZXJNYXAkZS56b29tT25DbGljayhjbHVzdGVyZXIsIHpvb21PbkNsaWNrKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uTW91c2VPdXQsIG9uTW91c2VPdXQpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VPdmVyKSB7XG4gICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjbHVzdGVyZXIsIGV2ZW50TWFwJGUub25Nb3VzZU92ZXIsIG9uTW91c2VPdmVyKSk7XG4gICAgfVxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNsdXN0ZXJlciwgZXZlbnRNYXAkZS5vbkNsaWNrLCBvbkNsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkNsdXN0ZXJpbmdCZWdpbikge1xuICAgICAgc2V0Q2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uQ2x1c3RlcmluZ0JlZ2luLCBvbkNsdXN0ZXJpbmdCZWdpbikpO1xuICAgIH1cbiAgICBpZiAob25DbHVzdGVyaW5nRW5kKSB7XG4gICAgICBzZXRDbHVzdGVyaW5nRW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uQ2x1c3RlcmluZ0VuZCwgb25DbHVzdGVyaW5nRW5kKSk7XG4gICAgfVxuICAgIHNldEluc3RhbmNlKGNsdXN0ZXJlcik7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKGNsdXN0ZXJlcik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY2x1c3RlcmluZ0VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsdXN0ZXJpbmdFbmRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChjbHVzdGVyZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGluc3RhbmNlICE9PSBudWxsID8gY2hpbGRyZW4oaW5zdGFuY2UpIHx8IG51bGwgOiBudWxsO1xufVxudmFyIE1hcmtlckNsdXN0ZXJlckYgPSBtZW1vKE1hcmtlckNsdXN0ZXJlckZ1bmN0aW9uYWwpO1xuY2xhc3MgQ2x1c3RlcmVyQ29tcG9uZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgbWFya2VyQ2x1c3RlcmVyOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0Q2x1c3RlcmVyQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICB2YXIgbWFya2VyQ2x1c3RlcmVyID0gbmV3IENsdXN0ZXJlcih0aGlzLmNvbnRleHQsIFtdLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZSxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGUsXG4gICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgaW5zdGFuY2U6IG1hcmtlckNsdXN0ZXJlclxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXJrZXJDbHVzdGVyZXJcbiAgICAgICAgfTtcbiAgICAgIH0sIHRoaXMuc2V0Q2x1c3RlcmVyQ2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRlLFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZSxcbiAgICAgICAgcHJldlByb3BzLFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlciAhPT0gbnVsbCA/IHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpIDogbnVsbDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KENsdXN0ZXJlckNvbXBvbmVudCwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuLy8gVGhpcyBoYW5kbGVyIHByZXZlbnRzIGFuIGV2ZW50IGluIHRoZSBJbmZvQm94IGZyb20gYmVpbmcgcGFzc2VkIG9uIHRvIHRoZSBtYXAuXG5mdW5jdGlvbiBjYW5jZWxIYW5kbGVyKGV2ZW50KSB7XG4gIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufVxudmFyIEluZm9Cb3ggPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbmZvQm94KG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIHRoaXMuZ2V0Q2xvc2VDbGlja0hhbmRsZXIgPSB0aGlzLmdldENsb3NlQ2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jbG9zZUNsaWNrSGFuZGxlciA9IHRoaXMuY2xvc2VDbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNyZWF0ZUluZm9Cb3hEaXYgPSB0aGlzLmNyZWF0ZUluZm9Cb3hEaXYuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFkZENsaWNrSGFuZGxlciA9IHRoaXMuYWRkQ2xpY2tIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRDbG9zZUJveEltZyA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcuYmluZCh0aGlzKTtcbiAgICB0aGlzLmdldEJveFdpZHRocyA9IHRoaXMuZ2V0Qm94V2lkdGhzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRCb3hTdHlsZSA9IHRoaXMuc2V0Qm94U3R5bGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNldFBvc2l0aW9uID0gdGhpcy5zZXRQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRPcHRpb25zID0gdGhpcy5zZXRPcHRpb25zLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRDb250ZW50ID0gdGhpcy5zZXRDb250ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRWaXNpYmxlID0gdGhpcy5zZXRWaXNpYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRDb250ZW50ID0gdGhpcy5nZXRDb250ZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5nZXRWaXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZXRaSW5kZXggPSB0aGlzLnNldFpJbmRleC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZ2V0WkluZGV4ID0gdGhpcy5nZXRaSW5kZXguYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUmVtb3ZlID0gdGhpcy5vblJlbW92ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGFuQm94ID0gdGhpcy5wYW5Cb3guYmluZCh0aGlzKTtcbiAgICB0aGlzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRyYXcgPSB0aGlzLmRyYXcuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNob3cgPSB0aGlzLnNob3cuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wZW4gPSB0aGlzLm9wZW4uYmluZCh0aGlzKTtcbiAgICB0aGlzLmV4dGVuZChJbmZvQm94LCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gICAgLy8gU3RhbmRhcmQgb3B0aW9ucyAoaW4gY29tbW9uIHdpdGggZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyk6XG4gICAgdGhpcy5jb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgIHRoaXMuZGlzYWJsZUF1dG9QYW4gPSBvcHRpb25zLmRpc2FibGVBdXRvUGFuIHx8IGZhbHNlO1xuICAgIHRoaXMubWF4V2lkdGggPSBvcHRpb25zLm1heFdpZHRoIHx8IDA7XG4gICAgdGhpcy5waXhlbE9mZnNldCA9IG9wdGlvbnMucGl4ZWxPZmZzZXQgfHwgbmV3IGdvb2dsZS5tYXBzLlNpemUoMCwgMCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24gfHwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZygwLCAwKTtcbiAgICB0aGlzLnpJbmRleCA9IG9wdGlvbnMuekluZGV4IHx8IG51bGw7XG4gICAgLy8gQWRkaXRpb25hbCBvcHRpb25zICh1bmlxdWUgdG8gSW5mb0JveCk6XG4gICAgdGhpcy5ib3hDbGFzcyA9IG9wdGlvbnMuYm94Q2xhc3MgfHwgJ2luZm9Cb3gnO1xuICAgIHRoaXMuYm94U3R5bGUgPSBvcHRpb25zLmJveFN0eWxlIHx8IHt9O1xuICAgIHRoaXMuY2xvc2VCb3hNYXJnaW4gPSBvcHRpb25zLmNsb3NlQm94TWFyZ2luIHx8ICcycHgnO1xuICAgIHRoaXMuY2xvc2VCb3hVUkwgPSBvcHRpb25zLmNsb3NlQm94VVJMIHx8ICdodHRwOi8vd3d3Lmdvb2dsZS5jb20vaW50bC9lbl91cy9tYXBmaWxlcy9jbG9zZS5naWYnO1xuICAgIGlmIChvcHRpb25zLmNsb3NlQm94VVJMID09PSAnJykge1xuICAgICAgdGhpcy5jbG9zZUJveFVSTCA9ICcnO1xuICAgIH1cbiAgICB0aGlzLmluZm9Cb3hDbGVhcmFuY2UgPSBvcHRpb25zLmluZm9Cb3hDbGVhcmFuY2UgfHwgbmV3IGdvb2dsZS5tYXBzLlNpemUoMSwgMSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpc2libGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNIaWRkZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnZpc2libGUgPSAhb3B0aW9ucy5pc0hpZGRlbjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pc0hpZGRlbiA9ICFvcHRpb25zLnZpc2libGU7XG4gICAgdGhpcy5hbGlnbkJvdHRvbSA9IG9wdGlvbnMuYWxpZ25Cb3R0b20gfHwgZmFsc2U7XG4gICAgdGhpcy5wYW5lID0gb3B0aW9ucy5wYW5lIHx8ICdmbG9hdFBhbmUnO1xuICAgIHRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiA9IG9wdGlvbnMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgdGhpcy5tYXBMaXN0ZW5lciA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBudWxsO1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIHRoaXMuZml4ZWRXaWR0aFNldCA9IG51bGw7XG4gIH1cbiAgSW5mb0JveC5wcm90b3R5cGUuY3JlYXRlSW5mb0JveERpdiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8vIFRoaXMgaGFuZGxlciBpZ25vcmVzIHRoZSBjdXJyZW50IGV2ZW50IGluIHRoZSBJbmZvQm94IGFuZCBjb25kaXRpb25hbGx5IHByZXZlbnRzXG4gICAgLy8gdGhlIGV2ZW50IGZyb20gYmVpbmcgcGFzc2VkIG9uIHRvIHRoZSBtYXAuIEl0IGlzIHVzZWQgZm9yIHRoZSBjb250ZXh0bWVudSBldmVudC5cbiAgICB2YXIgaWdub3JlSGFuZGxlciA9IGZ1bmN0aW9uIGlnbm9yZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghX3RoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgICBjYW5jZWxIYW5kbGVyKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghdGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLnNldEJveFN0eWxlKCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpICsgdGhpcy5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgdmFyIHBhbmVzID0gdGhpcy5nZXRQYW5lcygpO1xuICAgICAgaWYgKHBhbmVzICE9PSBudWxsKSB7XG4gICAgICAgIHBhbmVzW3RoaXMucGFuZV0uYXBwZW5kQ2hpbGQodGhpcy5kaXYpOyAvLyBBZGQgdGhlIEluZm9Cb3ggZGl2IHRvIHRoZSBET01cbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgICBpZiAodGhpcy5kaXYuc3R5bGUud2lkdGgpIHtcbiAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm1heFdpZHRoICE9PSAwICYmIHRoaXMuZGl2Lm9mZnNldFdpZHRoID4gdGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gdGhpcy5tYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgbmVlZGVkIHRvIG92ZXJjb21lIHByb2JsZW1zIHdpdGggTVNJRVxuICAgICAgICAgIHZhciBidyA9IHRoaXMuZ2V0Qm94V2lkdGhzKCk7XG4gICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSB0aGlzLmRpdi5vZmZzZXRXaWR0aCAtIGJ3LmxlZnQgLSBidy5yaWdodCArICdweCc7XG4gICAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGFuQm94KHRoaXMuZGlzYWJsZUF1dG9QYW4pO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24pIHtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycyA9IFtdO1xuICAgICAgICAvLyBDYW5jZWwgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgIC8vIE5vdGU6IG1vdXNlbW92ZSBub3QgaW5jbHVkZWQgKHRvIHJlc29sdmUgSXNzdWUgMTUyKVxuICAgICAgICB2YXIgZXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnY2xpY2snLCAnZGJsY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCcsICd0b3VjaG1vdmUnXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBldmVudHNfMSA9IGV2ZW50czsgX2kgPCBldmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xW19pXTtcbiAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnB1c2goZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaXYsIGV2ZW50XzEsIGNhbmNlbEhhbmRsZXIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBHb29nbGUgYnVnIHRoYXQgY2F1c2VzIHRoZSBjdXJzb3IgdG8gY2hhbmdlIHRvIGEgcG9pbnRlclxuICAgICAgICAvLyB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIGEgbWFya2VyIHVuZGVybmVhdGggSW5mb0JveC5cbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5kaXYpIHtcbiAgICAgICAgICAgIF90aGlzLmRpdi5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRleHRMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LCAnY29udGV4dG1lbnUnLCBpZ25vcmVIYW5kbGVyKTtcbiAgICAgIC8qKlxuICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBESVYgY29udGFpbmluZyB0aGUgSW5mb0JveCdzIGNvbnRlbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTS5cbiAgICAgICAqIEBuYW1lIEluZm9Cb3gjZG9tcmVhZHlcbiAgICAgICAqIEBldmVudFxuICAgICAgICovXG4gICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdkb21yZWFkeScpO1xuICAgIH1cbiAgfTtcbiAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VCb3hJbWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltZyA9ICcnO1xuICAgIGlmICh0aGlzLmNsb3NlQm94VVJMICE9PSAnJykge1xuICAgICAgaW1nID0gJzxpbWcgYWx0PVwiXCInO1xuICAgICAgaW1nICs9ICcgYXJpYS1oaWRkZW49XCJ0cnVlXCInO1xuICAgICAgaW1nICs9IFwiIHNyYz0nXCIgKyB0aGlzLmNsb3NlQm94VVJMICsgXCInXCI7XG4gICAgICBpbWcgKz0gJyBhbGlnbj1yaWdodCc7IC8vIERvIHRoaXMgYmVjYXVzZSBPcGVyYSBjaG9rZXMgb24gc3R5bGU9J2Zsb2F0OiByaWdodDsnXG4gICAgICBpbWcgKz0gXCIgc3R5bGU9J1wiO1xuICAgICAgaW1nICs9ICcgcG9zaXRpb246IHJlbGF0aXZlOyc7IC8vIFJlcXVpcmVkIGJ5IE1TSUVcbiAgICAgIGltZyArPSAnIGN1cnNvcjogcG9pbnRlcjsnO1xuICAgICAgaW1nICs9ICcgbWFyZ2luOiAnICsgdGhpcy5jbG9zZUJveE1hcmdpbiArICc7JztcbiAgICAgIGltZyArPSBcIic+XCI7XG4gICAgfVxuICAgIHJldHVybiBpbWc7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmFkZENsaWNrSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSB0aGlzLmRpdiAmJiB0aGlzLmRpdi5maXJzdENoaWxkICYmIHRoaXMuY2xvc2VCb3hVUkwgIT09ICcnID8gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIodGhpcy5kaXYuZmlyc3RDaGlsZCwgJ2NsaWNrJywgdGhpcy5nZXRDbG9zZUNsaWNrSGFuZGxlcigpKSA6IG51bGw7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmNsb3NlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gMS4wLjMgZml4OiBBbHdheXMgcHJldmVudCBwcm9wYWdhdGlvbiBvZiBhIGNsb3NlIGJveCBjbGljayB0byB0aGUgbWFwOlxuICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgSW5mb0JveCdzIGNsb3NlIGJveCBpcyBjbGlja2VkLlxuICAgICAqIEBuYW1lIEluZm9Cb3gjY2xvc2VjbGlja1xuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2Nsb3NlY2xpY2snKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmdldENsb3NlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNsb3NlQ2xpY2tIYW5kbGVyO1xuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5wYW5Cb3ggPSBmdW5jdGlvbiAoZGlzYWJsZVBhbikge1xuICAgIGlmICh0aGlzLmRpdiAmJiAhZGlzYWJsZVBhbikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAvLyBPbmx5IHBhbiBpZiBhdHRhY2hlZCB0byBtYXAsIG5vdCBwYW5vcmFtYVxuICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLk1hcCkge1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmNvbnRhaW5zKHRoaXMucG9zaXRpb24pKSB7XG4gICAgICAgICAgLy8gTWFya2VyIG5vdCBpbiB2aXNpYmxlIGFyZWEgb2YgbWFwLCBzbyBzZXQgY2VudGVyXG4gICAgICAgICAgLy8gb2YgbWFwIHRvIHRoZSBtYXJrZXIgcG9zaXRpb24gZmlyc3QuXG4gICAgICAgICAgbWFwLnNldENlbnRlcih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIG1hcFdpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdmFyIG1hcEhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBpd09mZnNldFggPSB0aGlzLnBpeGVsT2Zmc2V0LndpZHRoO1xuICAgICAgICB2YXIgaXdPZmZzZXRZID0gdGhpcy5waXhlbE9mZnNldC5oZWlnaHQ7XG4gICAgICAgIHZhciBpd1dpZHRoID0gdGhpcy5kaXYub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciBpd0hlaWdodCA9IHRoaXMuZGl2Lm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIHBhZFggPSB0aGlzLmluZm9Cb3hDbGVhcmFuY2Uud2lkdGg7XG4gICAgICAgIHZhciBwYWRZID0gdGhpcy5pbmZvQm94Q2xlYXJhbmNlLmhlaWdodDtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgIHZhciBwaXhQb3NpdGlvbiA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvQ29udGFpbmVyUGl4ZWwodGhpcy5wb3NpdGlvbik7XG4gICAgICAgIGlmIChwaXhQb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChwaXhQb3NpdGlvbi54IDwgLWl3T2Zmc2V0WCArIHBhZFgpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSBwaXhQb3NpdGlvbi54ICsgaXdPZmZzZXRYIC0gcGFkWDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBpeFBvc2l0aW9uLnggKyBpd1dpZHRoICsgaXdPZmZzZXRYICsgcGFkWCA+IG1hcFdpZHRoKSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gcGl4UG9zaXRpb24ueCArIGl3V2lkdGggKyBpd09mZnNldFggKyBwYWRYIC0gbWFwV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmFsaWduQm90dG9tKSB7XG4gICAgICAgICAgICBpZiAocGl4UG9zaXRpb24ueSA8IC1pd09mZnNldFkgKyBwYWRZICsgaXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgLSBwYWRZIC0gaXdIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgKyBwYWRZID4gbWFwSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdPZmZzZXRZICsgcGFkWSAtIG1hcEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBpeFBvc2l0aW9uLnkgPCAtaXdPZmZzZXRZICsgcGFkWSkge1xuICAgICAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSAtIHBhZFk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBpeFBvc2l0aW9uLnkgKyBpd0hlaWdodCArIGl3T2Zmc2V0WSArIHBhZFkgPiBtYXBIZWlnaHQpIHtcbiAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd0hlaWdodCArIGl3T2Zmc2V0WSArIHBhZFkgLSBtYXBIZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgICAvLyBNb3ZlIHRoZSBtYXAgdG8gdGhlIHNoaWZ0ZWQgY2VudGVyLlxuICAgICAgICAgIG1hcC5wYW5CeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgSW5mb0JveC5wcm90b3R5cGUuc2V0Qm94U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAvLyBBcHBseSBzdHlsZSB2YWx1ZXMgZnJvbSB0aGUgc3R5bGUgc2hlZXQgZGVmaW5lZCBpbiB0aGUgYm94Q2xhc3MgcGFyYW1ldGVyOlxuICAgICAgdGhpcy5kaXYuY2xhc3NOYW1lID0gdGhpcy5ib3hDbGFzcztcbiAgICAgIC8vIENsZWFyIGV4aXN0aW5nIGlubGluZSBzdHlsZSB2YWx1ZXM6XG4gICAgICB0aGlzLmRpdi5zdHlsZS5jc3NUZXh0ID0gJyc7XG4gICAgICAvLyBBcHBseSBzdHlsZSB2YWx1ZXMgZGVmaW5lZCBpbiB0aGUgYm94U3R5bGUgcGFyYW1ldGVyOlxuICAgICAgdmFyIGJveFN0eWxlID0gdGhpcy5ib3hTdHlsZTtcbiAgICAgIGZvciAodmFyIGkgaW4gYm94U3R5bGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChib3hTdHlsZSwgaSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRoaXMuZGl2LnN0eWxlW2ldID0gYm94U3R5bGVbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIEZpeCBmb3IgaU9TIGRpc2FwcGVhcmluZyBJbmZvQm94IHByb2JsZW1cbiAgICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzkyMjk1MzUvZ29vZ2xlLW1hcHMtbWFya2Vycy1kaXNhcHBlYXItYXQtY2VydGFpbi16b29tLWxldmVsLW9ubHktb24taXBob25lLWlwYWRcbiAgICAgIHRoaXMuZGl2LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGVaKDApJztcbiAgICAgIC8vIEZpeCB1cCBvcGFjaXR5IHN0eWxlIGZvciBiZW5lZml0IG9mIE1TSUVcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXYuc3R5bGUub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5kaXYuc3R5bGUub3BhY2l0eSAhPT0gJycpIHtcbiAgICAgICAgLy8gU2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvY3NzL29wYWNpdHkuaHRtbFxuICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5kaXYuc3R5bGUub3BhY2l0eSB8fCAnJyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmRpdi5zdHlsZS5tc0ZpbHRlciA9ICdcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PScgKyBvcGFjaXR5ICogMTAwICsgJylcIic7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmZpbHRlciA9ICdhbHBoYShvcGFjaXR5PScgKyBvcGFjaXR5ICogMTAwICsgJyknO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHkgcmVxdWlyZWQgc3R5bGVzXG4gICAgICB0aGlzLmRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBpZiAodGhpcy56SW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUuekluZGV4ID0gdGhpcy56SW5kZXggKyAnJztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kaXYuc3R5bGUub3ZlcmZsb3cpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5nZXRCb3hXaWR0aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ3ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwXG4gICAgfTtcbiAgICBpZiAoIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gYnc7XG4gICAgfVxuICAgIGlmIChkb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmRpdi5vd25lckRvY3VtZW50O1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5kaXYsICcnKSA6IG51bGw7XG4gICAgICBpZiAoY29tcHV0ZWRTdHlsZSkge1xuICAgICAgICAvLyBUaGUgY29tcHV0ZWQgc3R5bGVzIGFyZSBhbHdheXMgaW4gcGl4ZWwgdW5pdHMgKGdvb2QhKVxuICAgICAgICBidy50b3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgIGJ3LmxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgIGJ3LnJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSAvLyBNU0lFXG4gICAgKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB2YXIgY3VycmVudFN0eWxlID0gdGhpcy5kaXYuY3VycmVudFN0eWxlO1xuICAgICAgaWYgKGN1cnJlbnRTdHlsZSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBzdHlsZXMgbWF5IG5vdCBiZSBpbiBwaXhlbCB1bml0cywgYnV0IGFzc3VtZSB0aGV5IGFyZSAoYmFkISlcbiAgICAgICAgYncudG9wID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlclRvcFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgYncuYm90dG9tID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgICAgYncubGVmdCA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICBidy5yaWdodCA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJSaWdodFdpZHRoIHx8ICcnLCAxMCkgfHwgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ3O1xuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5kaXYucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3JlYXRlSW5mb0JveERpdigpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgIHZhciBwaXhQb3NpdGlvbiA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwodGhpcy5wb3NpdGlvbik7XG4gICAgICBpZiAocGl4UG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IHBpeFBvc2l0aW9uLnggKyB0aGlzLnBpeGVsT2Zmc2V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgaWYgKHRoaXMuYWxpZ25Cb3R0b20pIHtcbiAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5ib3R0b20gPSAtKHBpeFBvc2l0aW9uLnkgKyB0aGlzLnBpeGVsT2Zmc2V0LmhlaWdodCkgKyAncHgnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IHBpeFBvc2l0aW9uLnkgKyB0aGlzLnBpeGVsT2Zmc2V0LmhlaWdodCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ib3hDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE11c3QgYmUgZmlyc3RcbiAgICAgIHRoaXMuYm94Q2xhc3MgPSBvcHRpb25zLmJveENsYXNzO1xuICAgICAgdGhpcy5zZXRCb3hTdHlsZSgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYm94U3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBNdXN0IGJlIHNlY29uZFxuICAgICAgdGhpcy5ib3hTdHlsZSA9IG9wdGlvbnMuYm94U3R5bGU7XG4gICAgICB0aGlzLnNldEJveFN0eWxlKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRDb250ZW50KG9wdGlvbnMuY29udGVudCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kaXNhYmxlQXV0b1BhbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZGlzYWJsZUF1dG9QYW4gPSBvcHRpb25zLmRpc2FibGVBdXRvUGFuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4V2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLm1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnBpeGVsT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5waXhlbE9mZnNldCA9IG9wdGlvbnMucGl4ZWxPZmZzZXQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGlnbkJvdHRvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuYWxpZ25Cb3R0b20gPSBvcHRpb25zLmFsaWduQm90dG9tO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuekluZGV4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5zZXRaSW5kZXgob3B0aW9ucy56SW5kZXgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xvc2VCb3hNYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmNsb3NlQm94TWFyZ2luID0gb3B0aW9ucy5jbG9zZUJveE1hcmdpbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsb3NlQm94VVJMICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jbG9zZUJveFVSTCA9IG9wdGlvbnMuY2xvc2VCb3hVUkw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5pbmZvQm94Q2xlYXJhbmNlID0gb3B0aW9ucy5pbmZvQm94Q2xlYXJhbmNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmlzSGlkZGVuID0gb3B0aW9ucy5pc0hpZGRlbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmlzSGlkZGVuID0gIW9wdGlvbnMudmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gPSBvcHRpb25zLmVuYWJsZUV2ZW50UHJvcGFnYXRpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgaWYgKHRoaXMuY2xvc2VMaXN0ZW5lcikge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNsb3NlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gT2RkIGNvZGUgcmVxdWlyZWQgdG8gbWFrZSB0aGluZ3Mgd29yayB3aXRoIE1TSUUuXG4gICAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldCkge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCkgKyBjb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIFBlcnZlcnNlIGNvZGUgcmVxdWlyZWQgdG8gbWFrZSB0aGluZ3Mgd29yayB3aXRoIE1TSUUuXG4gICAgICAvLyAoRW5zdXJlcyB0aGUgY2xvc2UgYm94IGRvZXMsIGluIGZhY3QsIGZsb2F0IHRvIHRoZSByaWdodC4pXG4gICAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldCkge1xuICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IHRoaXMuZGl2Lm9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKSArIGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpO1xuICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFkZENsaWNrSGFuZGxlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIGNvbnRlbnQgb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICAgKiBAbmFtZSBJbmZvQm94I2NvbnRlbnRfY2hhbmdlZFxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2NvbnRlbnRfY2hhbmdlZCcpO1xuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICB0aGlzLnBvc2l0aW9uID0gbGF0TG5nO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgcG9zaXRpb24gb2YgdGhlIEluZm9Cb3ggY2hhbmdlcy5cbiAgICAgKiBAbmFtZSBJbmZvQm94I3Bvc2l0aW9uX2NoYW5nZWRcbiAgICAgKiBAZXZlbnRcbiAgICAgKi9cbiAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdwb3NpdGlvbl9jaGFuZ2VkJyk7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLnNldFZpc2libGUgPSBmdW5jdGlvbiAoaXNWaXNpYmxlKSB7XG4gICAgdGhpcy5pc0hpZGRlbiA9ICFpc1Zpc2libGU7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy5pc0hpZGRlbiA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgIH1cbiAgfTtcbiAgSW5mb0JveC5wcm90b3R5cGUuc2V0WkluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdGhpcy56SW5kZXggPSBpbmRleDtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IGluZGV4ICsgJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgekluZGV4IG9mIHRoZSBJbmZvQm94IGNoYW5nZXMuXG4gICAgICogQG5hbWUgSW5mb0JveCN6aW5kZXhfY2hhbmdlZFxuICAgICAqIEBldmVudFxuICAgICAqL1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ3ppbmRleF9jaGFuZ2VkJyk7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfTtcbiAgSW5mb0JveC5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmdldFpJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy56SW5kZXg7XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmdldFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgcmV0dXJuIHR5cGVvZiBtYXAgPT09ICd1bmRlZmluZWQnIHx8IG1hcCA9PT0gbnVsbCA/IGZhbHNlIDogIXRoaXMuaXNIaWRkZW47XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG4gIH07XG4gIEluZm9Cb3gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG1hcCwgYW5jaG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnBvc2l0aW9uID0gYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGFuY2hvciwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB2YXIgcG9zaXRpb24gPSBhbmNob3IuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgX3RoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcExpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYW5jaG9yLCAnbWFwX2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBfdGhpcy5zZXRNYXAoYW5jaG9yLm1hcCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5zZXRNYXAobWFwKTtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMucGFuQm94KCk7XG4gICAgfVxuICB9O1xuICBJbmZvQm94LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbG9zZUxpc3RlbmVyKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNsb3NlTGlzdGVuZXIpO1xuICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmV2ZW50TGlzdGVuZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IF9hW19pXTtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMubW92ZUxpc3RlbmVyKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLm1vdmVMaXN0ZW5lcik7XG4gICAgICB0aGlzLm1vdmVMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hcExpc3RlbmVyKSB7XG4gICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLm1hcExpc3RlbmVyKTtcbiAgICAgIHRoaXMubWFwTGlzdGVuZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZXh0TGlzdGVuZXIpIHtcbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY29udGV4dExpc3RlbmVyKTtcbiAgICAgIHRoaXMuY29udGV4dExpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnNldE1hcChudWxsKTtcbiAgfTtcbiAgSW5mb0JveC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9iajEsIG9iajIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFeHRlbmQob2JqZWN0KSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5wcm90b3R5cGVbcHJvcGVydHldID0gb2JqZWN0LnByb3RvdHlwZVtwcm9wZXJ0eV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0uYXBwbHkob2JqMSwgW29iajJdKTtcbiAgfTtcbiAgcmV0dXJuIEluZm9Cb3g7XG59KCk7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJwb3NpdGlvblwiXSxcbiAgX2V4Y2x1ZGVkMiA9IFtcInBvc2l0aW9uXCJdO1xuZnVuY3Rpb24gb3duS2V5cyRiKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGIoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGIoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCRkID0ge1xuICBvbkNsb3NlQ2xpY2s6ICdjbG9zZWNsaWNrJyxcbiAgb25Db250ZW50Q2hhbmdlZDogJ2NvbnRlbnRfY2hhbmdlZCcsXG4gIG9uRG9tUmVhZHk6ICdkb21yZWFkeScsXG4gIG9uUG9zaXRpb25DaGFuZ2VkOiAncG9zaXRpb25fY2hhbmdlZCcsXG4gIG9uWmluZGV4Q2hhbmdlZDogJ3ppbmRleF9jaGFuZ2VkJ1xufTtcbnZhciB1cGRhdGVyTWFwJGQgPSB7XG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBwb3NpdGlvbihpbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpIHtcbiAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2Uuc2V0UG9zaXRpb24obmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbi5sYXQsIHBvc2l0aW9uLmxuZykpO1xuICAgIH1cbiAgfSxcbiAgdmlzaWJsZShpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gIH0sXG4gIHpJbmRleChpbnN0YW5jZSwgekluZGV4KSB7XG4gICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gIH1cbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkMyA9IHt9O1xuZnVuY3Rpb24gSW5mb0JveEZ1bmN0aW9uYWwoX3JlZikge1xuICB2YXIge1xuICAgIGNoaWxkcmVuLFxuICAgIGFuY2hvcixcbiAgICBvcHRpb25zLFxuICAgIHBvc2l0aW9uLFxuICAgIHpJbmRleCxcbiAgICBvbkNsb3NlQ2xpY2ssXG4gICAgb25Eb21SZWFkeSxcbiAgICBvbkNvbnRlbnRDaGFuZ2VkLFxuICAgIG9uUG9zaXRpb25DaGFuZ2VkLFxuICAgIG9uWmluZGV4Q2hhbmdlZCxcbiAgICBvbkxvYWQsXG4gICAgb25Vbm1vdW50XG4gIH0gPSBfcmVmO1xuICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgdmFyIFtpbnN0YW5jZSwgc2V0SW5zdGFuY2VdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2xvc2VDbGlja0xpc3RlbmVyLCBzZXRDbG9zZUNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZG9tUmVhZHlDbGlja0xpc3RlbmVyLCBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyLCBzZXRDb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciwgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFt6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lciwgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBjb250YWluZXJFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLmNsb3NlKCk7XG4gICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIGluc3RhbmNlLm9wZW4obWFwLCBhbmNob3IpO1xuICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZS5nZXRQb3NpdGlvbigpKSB7XG4gICAgICAgIGluc3RhbmNlLm9wZW4obWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFttYXAsIGluc3RhbmNlLCBhbmNob3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwb3NpdGlvbiAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHBvc2l0aW9uTGF0TG5nID0gcG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcgPyBwb3NpdGlvbiA6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmxhdCwgcG9zaXRpb24ubG5nKTtcbiAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uTGF0TG5nKTtcbiAgICB9XG4gIH0sIFtwb3NpdGlvbl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfVxuICB9LCBbekluZGV4XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2xvc2VDbGljaykge1xuICAgICAgaWYgKGNsb3NlQ2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbG9zZUNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xvc2VDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xvc2VDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRvbVJlYWR5KSB7XG4gICAgICBpZiAoZG9tUmVhZHlDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbVJlYWR5Q2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICB9XG4gIH0sIFtvbkRvbVJlYWR5XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgIGlmIChjb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvbkNvbnRlbnRDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICBpZiAocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb3NpdGlvbl9jaGFuZ2VkJywgb25Qb3NpdGlvbkNoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvblBvc2l0aW9uQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblppbmRleENoYW5nZWQpIHtcbiAgICAgIGlmICh6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25aaW5kZXhDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdmFyIF9yZWYyID0gb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQzLFxuICAgICAgICB7XG4gICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICB9ID0gX3JlZjIsXG4gICAgICAgIGluZm9Cb3hPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYyLCBfZXhjbHVkZWQpO1xuICAgICAgdmFyIHBvc2l0aW9uTGF0TG5nO1xuICAgICAgaWYgKF9wb3NpdGlvbiAmJiAhKF9wb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBvc2l0aW9uTGF0TG5nID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhfcG9zaXRpb24ubGF0LCBfcG9zaXRpb24ubG5nKTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmZvQm94ID0gbmV3IEluZm9Cb3goX29iamVjdFNwcmVhZCRiKF9vYmplY3RTcHJlYWQkYih7fSwgaW5mb0JveE9wdGlvbnMpLCBwb3NpdGlvbkxhdExuZyA/IHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uTGF0TG5nXG4gICAgICB9IDoge30pKTtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2V0SW5zdGFuY2UoaW5mb0JveCk7XG4gICAgICBpZiAob25DbG9zZUNsaWNrKSB7XG4gICAgICAgIHNldENsb3NlQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvQm94LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljaykpO1xuICAgICAgfVxuICAgICAgaWYgKG9uRG9tUmVhZHkpIHtcbiAgICAgICAgc2V0RG9tUmVhZHlDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9Cb3gsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvQm94LCAnY29udGVudF9jaGFuZ2VkJywgb25Db250ZW50Q2hhbmdlZCkpO1xuICAgICAgfVxuICAgICAgaWYgKG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb0JveCwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgfVxuICAgICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvQm94LCAnemluZGV4X2NoYW5nZWQnLCBvblppbmRleENoYW5nZWQpKTtcbiAgICAgIH1cbiAgICAgIGluZm9Cb3guc2V0Q29udGVudChjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICBpbmZvQm94Lm9wZW4obWFwLCBhbmNob3IpO1xuICAgICAgfSBlbHNlIGlmIChpbmZvQm94LmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgaW5mb0JveC5vcGVuKG1hcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3Igb3IgYSBwb3NpdGlvbiBwcm9wIGZvciA8SW5mb0JveD4uJyk7XG4gICAgICB9XG4gICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgIG9uTG9hZChpbmZvQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2xvc2VDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xvc2VDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tUmVhZHlDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9tUmVhZHlDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHpJbmRleENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCA/IGNyZWF0ZVBvcnRhbChDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgY29udGFpbmVyRWxlbWVudFJlZi5jdXJyZW50KSA6IG51bGw7XG59XG52YXIgSW5mb0JveEYgPSBtZW1vKEluZm9Cb3hGdW5jdGlvbmFsKTtcbmNsYXNzIEluZm9Cb3hDb21wb25lbnQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250YWluZXJFbGVtZW50XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGluZm9Cb3g6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJvcGVuXCIsIChpbmZvQm94LCBhbmNob3IpID0+IHtcbiAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgIGluZm9Cb3gub3Blbih0aGlzLmNvbnRleHQsIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5mb0JveC5nZXRQb3NpdGlvbigpKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICBpbmZvQm94Lm9wZW4odGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yIG9yIGEgcG9zaXRpb24gcHJvcCBmb3IgPEluZm9Cb3g+LicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldEluZm9Cb3hDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5pbmZvQm94ICE9PSBudWxsICYmIHRoaXMuY29udGFpbmVyRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0YXRlLmluZm9Cb3guc2V0Q29udGVudCh0aGlzLmNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICB0aGlzLm9wZW4odGhpcy5zdGF0ZS5pbmZvQm94LCB0aGlzLnByb3BzLmFuY2hvcik7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuaW5mb0JveCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3JlZjMgPSB0aGlzLnByb3BzLm9wdGlvbnMgfHwge30sXG4gICAgICB7XG4gICAgICAgIHBvc2l0aW9uXG4gICAgICB9ID0gX3JlZjMsXG4gICAgICBpbmZvQm94T3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmMywgX2V4Y2x1ZGVkMik7XG4gICAgdmFyIHBvc2l0aW9uTGF0TG5nO1xuICAgIGlmIChwb3NpdGlvbiAmJiAhKHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcG9zaXRpb25MYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmxhdCwgcG9zaXRpb24ubG5nKTtcbiAgICB9XG4gICAgdmFyIGluZm9Cb3ggPSBuZXcgSW5mb0JveChfb2JqZWN0U3ByZWFkJGIoX29iamVjdFNwcmVhZCRiKHt9LCBpbmZvQm94T3B0aW9ucyksIHBvc2l0aW9uTGF0TG5nID8ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uTGF0TG5nXG4gICAgfSA6IHt9KSk7XG4gICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGQsXG4gICAgICBldmVudE1hcDogZXZlbnRNYXAkZCxcbiAgICAgIHByZXZQcm9wczoge30sXG4gICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBpbnN0YW5jZTogaW5mb0JveFxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaW5mb0JveFxuICAgIH0sIHRoaXMuc2V0SW5mb0JveENhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHtcbiAgICAgIGluZm9Cb3hcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoaW5mb0JveCAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZCxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGQsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogaW5mb0JveFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHZhciB7XG4gICAgICBvblVubW91bnRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB2YXIge1xuICAgICAgaW5mb0JveFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmIChpbmZvQm94ICE9PSBudWxsKSB7XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChpbmZvQm94KTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIGluZm9Cb3guY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPyBjcmVhdGVQb3J0YWwoQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwgdGhpcy5jb250YWluZXJFbGVtZW50KSA6IG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShJbmZvQm94Q29tcG9uZW50LCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG52YXIgZmFzdERlZXBFcXVhbDtcbnZhciBoYXNSZXF1aXJlZEZhc3REZWVwRXF1YWw7XG5mdW5jdGlvbiByZXF1aXJlRmFzdERlZXBFcXVhbCgpIHtcbiAgaWYgKGhhc1JlcXVpcmVkRmFzdERlZXBFcXVhbCkgcmV0dXJuIGZhc3REZWVwRXF1YWw7XG4gIGhhc1JlcXVpcmVkRmFzdERlZXBFcXVhbCA9IDE7XG5cbiAgLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cbiAgZmFzdERlZXBFcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG4gIH07XG4gIHJldHVybiBmYXN0RGVlcEVxdWFsO1xufVxuXG52YXIgZmFzdERlZXBFcXVhbEV4cG9ydHMgPSByZXF1aXJlRmFzdERlZXBFcXVhbCgpO1xudmFyIGVxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzJDEoZmFzdERlZXBFcXVhbEV4cG9ydHMpO1xuXG52YXIgQVJSQVlfVFlQRVMgPSBbSW50OEFycmF5LCBVaW50OEFycmF5LCBVaW50OENsYW1wZWRBcnJheSwgSW50MTZBcnJheSwgVWludDE2QXJyYXksIEludDMyQXJyYXksIFVpbnQzMkFycmF5LCBGbG9hdDMyQXJyYXksIEZsb2F0NjRBcnJheV07XG5cbi8qKiBAdHlwZWRlZiB7SW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50OENsYW1wZWRBcnJheUNvbnN0cnVjdG9yIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvciB8IEludDMyQXJyYXlDb25zdHJ1Y3RvciB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3IgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvciB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfSBUeXBlZEFycmF5Q29uc3RydWN0b3IgKi9cblxudmFyIFZFUlNJT04gPSAxOyAvLyBzZXJpYWxpemVkIGZvcm1hdCB2ZXJzaW9uXG52YXIgSEVBREVSX1NJWkUgPSA4O1xuY2xhc3MgS0RCdXNoIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5kZXggZnJvbSByYXcgYEFycmF5QnVmZmVyYCBkYXRhLlxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICBzdGF0aWMgZnJvbShkYXRhKSB7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgQXJyYXlCdWZmZXIuJyk7XG4gICAgfVxuICAgIHZhciBbbWFnaWMsIHZlcnNpb25BbmRUeXBlXSA9IG5ldyBVaW50OEFycmF5KGRhdGEsIDAsIDIpO1xuICAgIGlmIChtYWdpYyAhPT0gMHhkYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGRvZXMgbm90IGFwcGVhciB0byBiZSBpbiBhIEtEQnVzaCBmb3JtYXQuJyk7XG4gICAgfVxuICAgIHZhciB2ZXJzaW9uID0gdmVyc2lvbkFuZFR5cGUgPj4gNDtcbiAgICBpZiAodmVyc2lvbiAhPT0gVkVSU0lPTikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR290IHZcIi5jb25jYXQodmVyc2lvbiwgXCIgZGF0YSB3aGVuIGV4cGVjdGVkIHZcIikuY29uY2F0KFZFUlNJT04sIFwiLlwiKSk7XG4gICAgfVxuICAgIHZhciBBcnJheVR5cGUgPSBBUlJBWV9UWVBFU1t2ZXJzaW9uQW5kVHlwZSAmIDB4MGZdO1xuICAgIGlmICghQXJyYXlUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VucmVjb2duaXplZCBhcnJheSB0eXBlLicpO1xuICAgIH1cbiAgICB2YXIgW25vZGVTaXplXSA9IG5ldyBVaW50MTZBcnJheShkYXRhLCAyLCAxKTtcbiAgICB2YXIgW251bUl0ZW1zXSA9IG5ldyBVaW50MzJBcnJheShkYXRhLCA0LCAxKTtcbiAgICByZXR1cm4gbmV3IEtEQnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFycmF5VHlwZSwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbmRleCB0aGF0IHdpbGwgaG9sZCBhIGdpdmVuIG51bWJlciBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG51bUl0ZW1zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbm9kZVNpemU9NjRdIFNpemUgb2YgdGhlIEtELXRyZWUgbm9kZSAoNjQgYnkgZGVmYXVsdCkuXG4gICAqIEBwYXJhbSB7VHlwZWRBcnJheUNvbnN0cnVjdG9yfSBbQXJyYXlUeXBlPUZsb2F0NjRBcnJheV0gVGhlIGFycmF5IHR5cGUgdXNlZCBmb3IgY29vcmRpbmF0ZXMgc3RvcmFnZSAoYEZsb2F0NjRBcnJheWAgYnkgZGVmYXVsdCkuXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IFtkYXRhXSAoRm9yIGludGVybmFsIHVzZSBvbmx5KVxuICAgKi9cbiAgY29uc3RydWN0b3IobnVtSXRlbXMpIHtcbiAgICB2YXIgbm9kZVNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDY0O1xuICAgIHZhciBBcnJheVR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEZsb2F0NjRBcnJheTtcbiAgICB2YXIgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGlmIChpc05hTihudW1JdGVtcykgfHwgbnVtSXRlbXMgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnBleHBlY3RlZCBudW1JdGVtcyB2YWx1ZTogXCIuY29uY2F0KG51bUl0ZW1zLCBcIi5cIikpO1xuICAgIHRoaXMubnVtSXRlbXMgPSArbnVtSXRlbXM7XG4gICAgdGhpcy5ub2RlU2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KCtub2RlU2l6ZSwgMiksIDY1NTM1KTtcbiAgICB0aGlzLkFycmF5VHlwZSA9IEFycmF5VHlwZTtcbiAgICB0aGlzLkluZGV4QXJyYXlUeXBlID0gbnVtSXRlbXMgPCA2NTUzNiA/IFVpbnQxNkFycmF5IDogVWludDMyQXJyYXk7XG4gICAgdmFyIGFycmF5VHlwZUluZGV4ID0gQVJSQVlfVFlQRVMuaW5kZXhPZih0aGlzLkFycmF5VHlwZSk7XG4gICAgdmFyIGNvb3Jkc0J5dGVTaXplID0gbnVtSXRlbXMgKiAyICogdGhpcy5BcnJheVR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgdmFyIGlkc0J5dGVTaXplID0gbnVtSXRlbXMgKiB0aGlzLkluZGV4QXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIHZhciBwYWRDb29yZHMgPSAoOCAtIGlkc0J5dGVTaXplICUgOCkgJSA4O1xuICAgIGlmIChhcnJheVR5cGVJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZWQgYXJyYXkgY2xhc3M6IFwiLmNvbmNhdChBcnJheVR5cGUsIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChkYXRhICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgLy8gcmVjb25zdHJ1Y3QgYW4gaW5kZXggZnJvbSBhIGJ1ZmZlclxuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuaWRzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSwgbnVtSXRlbXMpO1xuICAgICAgdGhpcy5jb29yZHMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzLCBudW1JdGVtcyAqIDIpO1xuICAgICAgdGhpcy5fcG9zID0gbnVtSXRlbXMgKiAyO1xuICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbml0aWFsaXplIGEgbmV3IGluZGV4XG4gICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXlCdWZmZXIoSEVBREVSX1NJWkUgKyBjb29yZHNCeXRlU2l6ZSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzKTtcbiAgICAgIHRoaXMuaWRzID0gbmV3IHRoaXMuSW5kZXhBcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSwgbnVtSXRlbXMpO1xuICAgICAgdGhpcy5jb29yZHMgPSBuZXcgdGhpcy5BcnJheVR5cGUodGhpcy5kYXRhLCBIRUFERVJfU0laRSArIGlkc0J5dGVTaXplICsgcGFkQ29vcmRzLCBudW1JdGVtcyAqIDIpO1xuICAgICAgdGhpcy5fcG9zID0gMDtcbiAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIHNldCBoZWFkZXJcbiAgICAgIG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSwgMCwgMikuc2V0KFsweGRiLCAoVkVSU0lPTiA8PCA0KSArIGFycmF5VHlwZUluZGV4XSk7XG4gICAgICBuZXcgVWludDE2QXJyYXkodGhpcy5kYXRhLCAyLCAxKVswXSA9IG5vZGVTaXplO1xuICAgICAgbmV3IFVpbnQzMkFycmF5KHRoaXMuZGF0YSwgNCwgMSlbMF0gPSBudW1JdGVtcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcG9pbnQgdG8gdGhlIGluZGV4LlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBBbiBpbmNyZW1lbnRhbCBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGFkZGVkIGl0ZW0gKHN0YXJ0aW5nIGZyb20gYDBgKS5cbiAgICovXG4gIGFkZCh4LCB5KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fcG9zID4+IDE7XG4gICAgdGhpcy5pZHNbaW5kZXhdID0gaW5kZXg7XG4gICAgdGhpcy5jb29yZHNbdGhpcy5fcG9zKytdID0geDtcbiAgICB0aGlzLmNvb3Jkc1t0aGlzLl9wb3MrK10gPSB5O1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGluZGV4aW5nIG9mIHRoZSBhZGRlZCBwb2ludHMuXG4gICAqL1xuICBmaW5pc2goKSB7XG4gICAgdmFyIG51bUFkZGVkID0gdGhpcy5fcG9zID4+IDE7XG4gICAgaWYgKG51bUFkZGVkICE9PSB0aGlzLm51bUl0ZW1zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRlZCBcIi5jb25jYXQobnVtQWRkZWQsIFwiIGl0ZW1zIHdoZW4gZXhwZWN0ZWQgXCIpLmNvbmNhdCh0aGlzLm51bUl0ZW1zLCBcIi5cIikpO1xuICAgIH1cbiAgICAvLyBrZC1zb3J0IGJvdGggYXJyYXlzIGZvciBlZmZpY2llbnQgc2VhcmNoXG4gICAgc29ydCh0aGlzLmlkcywgdGhpcy5jb29yZHMsIHRoaXMubm9kZVNpemUsIDAsIHRoaXMubnVtSXRlbXMgLSAxLCAwKTtcbiAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIHRoZSBpbmRleCBmb3IgaXRlbXMgd2l0aGluIGEgZ2l2ZW4gYm91bmRpbmcgYm94LlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWFxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluWVxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WFxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4WVxuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IEFuIGFycmF5IG9mIGluZGljZXMgY29ycmVwb25kaW5nIHRvIHRoZSBmb3VuZCBpdGVtcy5cbiAgICovXG4gIHJhbmdlKG1pblgsIG1pblksIG1heFgsIG1heFkpIHtcbiAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbm90IHlldCBpbmRleGVkIC0gY2FsbCBpbmRleC5maW5pc2goKS4nKTtcbiAgICB2YXIge1xuICAgICAgaWRzLFxuICAgICAgY29vcmRzLFxuICAgICAgbm9kZVNpemVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgc3RhY2sgPSBbMCwgaWRzLmxlbmd0aCAtIDEsIDBdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgaXRlbXMgaW4gcmFuZ2UgaW4gdGhlIGtkLXNvcnRlZCBhcnJheXNcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICB2YXIgYXhpcyA9IHN0YWNrLnBvcCgpIHx8IDA7XG4gICAgICB2YXIgcmlnaHQgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgdmFyIGxlZnQgPSBzdGFjay5wb3AoKSB8fCAwO1xuXG4gICAgICAvLyBpZiB3ZSByZWFjaGVkIFwidHJlZSBub2RlXCIsIHNlYXJjaCBsaW5lYXJseVxuICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA8PSBub2RlU2l6ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gbGVmdDsgaSA8PSByaWdodDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF94ID0gY29vcmRzWzIgKiBpXTtcbiAgICAgICAgICB2YXIgX3kgPSBjb29yZHNbMiAqIGkgKyAxXTtcbiAgICAgICAgICBpZiAoX3ggPj0gbWluWCAmJiBfeCA8PSBtYXhYICYmIF95ID49IG1pblkgJiYgX3kgPD0gbWF4WSkgcmVzdWx0LnB1c2goaWRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIGZpbmQgdGhlIG1pZGRsZSBpbmRleFxuICAgICAgdmFyIG0gPSBsZWZ0ICsgcmlnaHQgPj4gMTtcblxuICAgICAgLy8gaW5jbHVkZSB0aGUgbWlkZGxlIGl0ZW0gaWYgaXQncyBpbiByYW5nZVxuICAgICAgdmFyIHggPSBjb29yZHNbMiAqIG1dO1xuICAgICAgdmFyIHkgPSBjb29yZHNbMiAqIG0gKyAxXTtcbiAgICAgIGlmICh4ID49IG1pblggJiYgeCA8PSBtYXhYICYmIHkgPj0gbWluWSAmJiB5IDw9IG1heFkpIHJlc3VsdC5wdXNoKGlkc1ttXSk7XG5cbiAgICAgIC8vIHF1ZXVlIHNlYXJjaCBpbiBoYWx2ZXMgdGhhdCBpbnRlcnNlY3QgdGhlIHF1ZXJ5XG4gICAgICBpZiAoYXhpcyA9PT0gMCA/IG1pblggPD0geCA6IG1pblkgPD0geSkge1xuICAgICAgICBzdGFjay5wdXNoKGxlZnQpO1xuICAgICAgICBzdGFjay5wdXNoKG0gLSAxKTtcbiAgICAgICAgc3RhY2sucHVzaCgxIC0gYXhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoYXhpcyA9PT0gMCA/IG1heFggPj0geCA6IG1heFkgPj0geSkge1xuICAgICAgICBzdGFjay5wdXNoKG0gKyAxKTtcbiAgICAgICAgc3RhY2sucHVzaChyaWdodCk7XG4gICAgICAgIHN0YWNrLnB1c2goMSAtIGF4aXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCB0aGUgaW5kZXggZm9yIGl0ZW1zIHdpdGhpbiBhIGdpdmVuIHJhZGl1cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHF4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBxeVxuICAgKiBAcGFyYW0ge251bWJlcn0gciBRdWVyeSByYWRpdXMuXG4gICAqIEByZXR1cm5zIHtudW1iZXJbXX0gQW4gYXJyYXkgb2YgaW5kaWNlcyBjb3JyZXBvbmRpbmcgdG8gdGhlIGZvdW5kIGl0ZW1zLlxuICAgKi9cbiAgd2l0aGluKHF4LCBxeSwgcikge1xuICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHRocm93IG5ldyBFcnJvcignRGF0YSBub3QgeWV0IGluZGV4ZWQgLSBjYWxsIGluZGV4LmZpbmlzaCgpLicpO1xuICAgIHZhciB7XG4gICAgICBpZHMsXG4gICAgICBjb29yZHMsXG4gICAgICBub2RlU2l6ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBzdGFjayA9IFswLCBpZHMubGVuZ3RoIC0gMSwgMF07XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciByMiA9IHIgKiByO1xuXG4gICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBpdGVtcyB3aXRoaW4gcmFkaXVzIGluIHRoZSBrZC1zb3J0ZWQgYXJyYXlzXG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIGF4aXMgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgdmFyIHJpZ2h0ID0gc3RhY2sucG9wKCkgfHwgMDtcbiAgICAgIHZhciBsZWZ0ID0gc3RhY2sucG9wKCkgfHwgMDtcblxuICAgICAgLy8gaWYgd2UgcmVhY2hlZCBcInRyZWUgbm9kZVwiLCBzZWFyY2ggbGluZWFybHlcbiAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbm9kZVNpemUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgIGlmIChzcURpc3QoY29vcmRzWzIgKiBpXSwgY29vcmRzWzIgKiBpICsgMV0sIHF4LCBxeSkgPD0gcjIpIHJlc3VsdC5wdXNoKGlkc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyd2lzZSBmaW5kIHRoZSBtaWRkbGUgaW5kZXhcbiAgICAgIHZhciBtID0gbGVmdCArIHJpZ2h0ID4+IDE7XG5cbiAgICAgIC8vIGluY2x1ZGUgdGhlIG1pZGRsZSBpdGVtIGlmIGl0J3MgaW4gcmFuZ2VcbiAgICAgIHZhciB4ID0gY29vcmRzWzIgKiBtXTtcbiAgICAgIHZhciB5ID0gY29vcmRzWzIgKiBtICsgMV07XG4gICAgICBpZiAoc3FEaXN0KHgsIHksIHF4LCBxeSkgPD0gcjIpIHJlc3VsdC5wdXNoKGlkc1ttXSk7XG5cbiAgICAgIC8vIHF1ZXVlIHNlYXJjaCBpbiBoYWx2ZXMgdGhhdCBpbnRlcnNlY3QgdGhlIHF1ZXJ5XG4gICAgICBpZiAoYXhpcyA9PT0gMCA/IHF4IC0gciA8PSB4IDogcXkgLSByIDw9IHkpIHtcbiAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgc3RhY2sucHVzaChtIC0gMSk7XG4gICAgICAgIHN0YWNrLnB1c2goMSAtIGF4aXMpO1xuICAgICAgfVxuICAgICAgaWYgKGF4aXMgPT09IDAgPyBxeCArIHIgPj0geCA6IHF5ICsgciA+PSB5KSB7XG4gICAgICAgIHN0YWNrLnB1c2gobSArIDEpO1xuICAgICAgICBzdGFjay5wdXNoKHJpZ2h0KTtcbiAgICAgICAgc3RhY2sucHVzaCgxIC0gYXhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5IHwgVWludDMyQXJyYXl9IGlkc1xuICogQHBhcmFtIHtJbnN0YW5jZVR5cGU8VHlwZWRBcnJheUNvbnN0cnVjdG9yPn0gY29vcmRzXG4gKiBAcGFyYW0ge251bWJlcn0gbm9kZVNpemVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBheGlzXG4gKi9cbmZ1bmN0aW9uIHNvcnQoaWRzLCBjb29yZHMsIG5vZGVTaXplLCBsZWZ0LCByaWdodCwgYXhpcykge1xuICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSByZXR1cm47XG4gIHZhciBtID0gbGVmdCArIHJpZ2h0ID4+IDE7IC8vIG1pZGRsZSBpbmRleFxuXG4gIC8vIHNvcnQgaWRzIGFuZCBjb29yZHMgYXJvdW5kIHRoZSBtaWRkbGUgaW5kZXggc28gdGhhdCB0aGUgaGFsdmVzIGxpZVxuICAvLyBlaXRoZXIgbGVmdC9yaWdodCBvciB0b3AvYm90dG9tIGNvcnJlc3BvbmRpbmdseSAodGFraW5nIHR1cm5zKVxuICBzZWxlY3QoaWRzLCBjb29yZHMsIG0sIGxlZnQsIHJpZ2h0LCBheGlzKTtcblxuICAvLyByZWN1cnNpdmVseSBrZC1zb3J0IGZpcnN0IGhhbGYgYW5kIHNlY29uZCBoYWxmIG9uIHRoZSBvcHBvc2l0ZSBheGlzXG4gIHNvcnQoaWRzLCBjb29yZHMsIG5vZGVTaXplLCBsZWZ0LCBtIC0gMSwgMSAtIGF4aXMpO1xuICBzb3J0KGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbSArIDEsIHJpZ2h0LCAxIC0gYXhpcyk7XG59XG5cbi8qKlxuICogQ3VzdG9tIEZsb3lkLVJpdmVzdCBzZWxlY3Rpb24gYWxnb3JpdGhtOiBzb3J0IGlkcyBhbmQgY29vcmRzIHNvIHRoYXRcbiAqIFtsZWZ0Li5rLTFdIGl0ZW1zIGFyZSBzbWFsbGVyIHRoYW4gay10aCBpdGVtIChvbiBlaXRoZXIgeCBvciB5IGF4aXMpXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5IHwgVWludDMyQXJyYXl9IGlkc1xuICogQHBhcmFtIHtJbnN0YW5jZVR5cGU8VHlwZWRBcnJheUNvbnN0cnVjdG9yPn0gY29vcmRzXG4gKiBAcGFyYW0ge251bWJlcn0ga1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IGF4aXNcbiAqL1xuZnVuY3Rpb24gc2VsZWN0KGlkcywgY29vcmRzLCBrLCBsZWZ0LCByaWdodCwgYXhpcykge1xuICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICBzZWxlY3QoaWRzLCBjb29yZHMsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBheGlzKTtcbiAgICB9XG4gICAgdmFyIHQgPSBjb29yZHNbMiAqIGsgKyBheGlzXTtcbiAgICB2YXIgaSA9IGxlZnQ7XG4gICAgdmFyIGogPSByaWdodDtcbiAgICBzd2FwSXRlbShpZHMsIGNvb3JkcywgbGVmdCwgayk7XG4gICAgaWYgKGNvb3Jkc1syICogcmlnaHQgKyBheGlzXSA+IHQpIHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCByaWdodCk7XG4gICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICBzd2FwSXRlbShpZHMsIGNvb3JkcywgaSwgaik7XG4gICAgICBpKys7XG4gICAgICBqLS07XG4gICAgICB3aGlsZSAoY29vcmRzWzIgKiBpICsgYXhpc10gPCB0KSBpKys7XG4gICAgICB3aGlsZSAoY29vcmRzWzIgKiBqICsgYXhpc10gPiB0KSBqLS07XG4gICAgfVxuICAgIGlmIChjb29yZHNbMiAqIGxlZnQgKyBheGlzXSA9PT0gdCkgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGxlZnQsIGopO2Vsc2Uge1xuICAgICAgaisrO1xuICAgICAgc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGosIHJpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5IHwgVWludDMyQXJyYXl9IGlkc1xuICogQHBhcmFtIHtJbnN0YW5jZVR5cGU8VHlwZWRBcnJheUNvbnN0cnVjdG9yPn0gY29vcmRzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICogQHBhcmFtIHtudW1iZXJ9IGpcbiAqL1xuZnVuY3Rpb24gc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGksIGopIHtcbiAgc3dhcChpZHMsIGksIGopO1xuICBzd2FwKGNvb3JkcywgMiAqIGksIDIgKiBqKTtcbiAgc3dhcChjb29yZHMsIDIgKiBpICsgMSwgMiAqIGogKyAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luc3RhbmNlVHlwZTxUeXBlZEFycmF5Q29uc3RydWN0b3I+fSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKiBAcGFyYW0ge251bWJlcn0galxuICovXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICB2YXIgdG1wID0gYXJyW2ldO1xuICBhcnJbaV0gPSBhcnJbal07XG4gIGFycltqXSA9IHRtcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBheVxuICogQHBhcmFtIHtudW1iZXJ9IGJ4XG4gKiBAcGFyYW0ge251bWJlcn0gYnlcbiAqL1xuZnVuY3Rpb24gc3FEaXN0KGF4LCBheSwgYngsIGJ5KSB7XG4gIHZhciBkeCA9IGF4IC0gYng7XG4gIHZhciBkeSA9IGF5IC0gYnk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxudmFyIGRlZmF1bHRPcHRpb25zJDIgPSB7XG4gIG1pblpvb206IDAsXG4gIC8vIG1pbiB6b29tIHRvIGdlbmVyYXRlIGNsdXN0ZXJzIG9uXG4gIG1heFpvb206IDE2LFxuICAvLyBtYXggem9vbSBsZXZlbCB0byBjbHVzdGVyIHRoZSBwb2ludHMgb25cbiAgbWluUG9pbnRzOiAyLFxuICAvLyBtaW5pbXVtIHBvaW50cyB0byBmb3JtIGEgY2x1c3RlclxuICByYWRpdXM6IDQwLFxuICAvLyBjbHVzdGVyIHJhZGl1cyBpbiBwaXhlbHNcbiAgZXh0ZW50OiA1MTIsXG4gIC8vIHRpbGUgZXh0ZW50IChyYWRpdXMgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBpdClcbiAgbm9kZVNpemU6IDY0LFxuICAvLyBzaXplIG9mIHRoZSBLRC10cmVlIGxlYWYgbm9kZSwgYWZmZWN0cyBwZXJmb3JtYW5jZVxuICBsb2c6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGxvZyB0aW1pbmcgaW5mb1xuXG4gIC8vIHdoZXRoZXIgdG8gZ2VuZXJhdGUgbnVtZXJpYyBpZHMgZm9yIGlucHV0IGZlYXR1cmVzIChpbiB2ZWN0b3IgdGlsZXMpXG4gIGdlbmVyYXRlSWQ6IGZhbHNlLFxuICAvLyBhIHJlZHVjZSBmdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgY3VzdG9tIGNsdXN0ZXIgcHJvcGVydGllc1xuICByZWR1Y2U6IG51bGwsXG4gIC8vIChhY2N1bXVsYXRlZCwgcHJvcHMpID0+IHsgYWNjdW11bGF0ZWQuc3VtICs9IHByb3BzLnN1bTsgfVxuXG4gIC8vIHByb3BlcnRpZXMgdG8gdXNlIGZvciBpbmRpdmlkdWFsIHBvaW50cyB3aGVuIHJ1bm5pbmcgdGhlIHJlZHVjZXJcbiAgbWFwOiBwcm9wcyA9PiBwcm9wcyAvLyBwcm9wcyA9PiAoe3N1bTogcHJvcHMubXlfdmFsdWV9KVxufTtcbnZhciBmcm91bmQgPSBNYXRoLmZyb3VuZCB8fCAodG1wID0+IHggPT4ge1xuICB0bXBbMF0gPSAreDtcbiAgcmV0dXJuIHRtcFswXTtcbn0pKG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xudmFyIE9GRlNFVF9aT09NID0gMjtcbnZhciBPRkZTRVRfSUQgPSAzO1xudmFyIE9GRlNFVF9QQVJFTlQgPSA0O1xudmFyIE9GRlNFVF9OVU0gPSA1O1xudmFyIE9GRlNFVF9QUk9QID0gNjtcbmNsYXNzIFN1cGVyY2x1c3RlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoZGVmYXVsdE9wdGlvbnMkMiksIG9wdGlvbnMpO1xuICAgIHRoaXMudHJlZXMgPSBuZXcgQXJyYXkodGhpcy5vcHRpb25zLm1heFpvb20gKyAxKTtcbiAgICB0aGlzLnN0cmlkZSA9IHRoaXMub3B0aW9ucy5yZWR1Y2UgPyA3IDogNjtcbiAgICB0aGlzLmNsdXN0ZXJQcm9wcyA9IFtdO1xuICB9XG4gIGxvYWQocG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIGxvZyxcbiAgICAgIG1pblpvb20sXG4gICAgICBtYXhab29tXG4gICAgfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAobG9nKSBjb25zb2xlLnRpbWUoJ3RvdGFsIHRpbWUnKTtcbiAgICB2YXIgdGltZXJJZCA9IFwicHJlcGFyZSBcIi5jb25jYXQocG9pbnRzLmxlbmd0aCwgXCIgcG9pbnRzXCIpO1xuICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSh0aW1lcklkKTtcbiAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgIC8vIGdlbmVyYXRlIGEgY2x1c3RlciBvYmplY3QgZm9yIGVhY2ggcG9pbnQgYW5kIGluZGV4IGlucHV0IHBvaW50cyBpbnRvIGEgS0QtdHJlZVxuICAgIHZhciBkYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgaWYgKCFwLmdlb21ldHJ5KSBjb250aW51ZTtcbiAgICAgIHZhciBbbG5nLCBsYXRdID0gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgIHZhciB4ID0gZnJvdW5kKGxuZ1gobG5nKSk7XG4gICAgICB2YXIgeSA9IGZyb3VuZChsYXRZKGxhdCkpO1xuICAgICAgLy8gc3RvcmUgaW50ZXJuYWwgcG9pbnQvY2x1c3RlciBkYXRhIGluIGZsYXQgbnVtZXJpYyBhcnJheXMgZm9yIHBlcmZvcm1hbmNlXG4gICAgICBkYXRhLnB1c2goeCwgeSxcbiAgICAgIC8vIHByb2plY3RlZCBwb2ludCBjb29yZGluYXRlc1xuICAgICAgSW5maW5pdHksXG4gICAgICAvLyB0aGUgbGFzdCB6b29tIHRoZSBwb2ludCB3YXMgcHJvY2Vzc2VkIGF0XG4gICAgICBpLFxuICAgICAgLy8gaW5kZXggb2YgdGhlIHNvdXJjZSBmZWF0dXJlIGluIHRoZSBvcmlnaW5hbCBpbnB1dCBhcnJheVxuICAgICAgLTEsXG4gICAgICAvLyBwYXJlbnQgY2x1c3RlciBpZFxuICAgICAgMSAvLyBudW1iZXIgb2YgcG9pbnRzIGluIGEgY2x1c3RlclxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVkdWNlKSBkYXRhLnB1c2goMCk7IC8vIG5vb3BcbiAgICB9XG4gICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW21heFpvb20gKyAxXSA9IHRoaXMuX2NyZWF0ZVRyZWUoZGF0YSk7XG4gICAgaWYgKGxvZykgY29uc29sZS50aW1lRW5kKHRpbWVySWQpO1xuXG4gICAgLy8gY2x1c3RlciBwb2ludHMgb24gbWF4IHpvb20sIHRoZW4gY2x1c3RlciB0aGUgcmVzdWx0cyBvbiBwcmV2aW91cyB6b29tLCBldGMuO1xuICAgIC8vIHJlc3VsdHMgaW4gYSBjbHVzdGVyIGhpZXJhcmNoeSBhY3Jvc3Mgem9vbSBsZXZlbHNcbiAgICBmb3IgKHZhciB6ID0gbWF4Wm9vbTsgeiA+PSBtaW5ab29tOyB6LS0pIHtcbiAgICAgIHZhciBub3cgPSArRGF0ZS5ub3coKTtcblxuICAgICAgLy8gY3JlYXRlIGEgbmV3IHNldCBvZiBjbHVzdGVycyBmb3IgdGhlIHpvb20gYW5kIGluZGV4IHRoZW0gd2l0aCBhIEtELXRyZWVcbiAgICAgIHRyZWUgPSB0aGlzLnRyZWVzW3pdID0gdGhpcy5fY3JlYXRlVHJlZSh0aGlzLl9jbHVzdGVyKHRyZWUsIHopKTtcbiAgICAgIGlmIChsb2cpIGNvbnNvbGUubG9nKCd6JWQ6ICVkIGNsdXN0ZXJzIGluICVkbXMnLCB6LCB0cmVlLm51bUl0ZW1zLCArRGF0ZS5ub3coKSAtIG5vdyk7XG4gICAgfVxuICAgIGlmIChsb2cpIGNvbnNvbGUudGltZUVuZCgndG90YWwgdGltZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldENsdXN0ZXJzKGJib3gsIHpvb20pIHtcbiAgICB2YXIgbWluTG5nID0gKChiYm94WzBdICsgMTgwKSAlIDM2MCArIDM2MCkgJSAzNjAgLSAxODA7XG4gICAgdmFyIG1pbkxhdCA9IE1hdGgubWF4KC05MCwgTWF0aC5taW4oOTAsIGJib3hbMV0pKTtcbiAgICB2YXIgbWF4TG5nID0gYmJveFsyXSA9PT0gMTgwID8gMTgwIDogKChiYm94WzJdICsgMTgwKSAlIDM2MCArIDM2MCkgJSAzNjAgLSAxODA7XG4gICAgdmFyIG1heExhdCA9IE1hdGgubWF4KC05MCwgTWF0aC5taW4oOTAsIGJib3hbM10pKTtcbiAgICBpZiAoYmJveFsyXSAtIGJib3hbMF0gPj0gMzYwKSB7XG4gICAgICBtaW5MbmcgPSAtMTgwO1xuICAgICAgbWF4TG5nID0gMTgwO1xuICAgIH0gZWxzZSBpZiAobWluTG5nID4gbWF4TG5nKSB7XG4gICAgICB2YXIgZWFzdGVybkhlbSA9IHRoaXMuZ2V0Q2x1c3RlcnMoW21pbkxuZywgbWluTGF0LCAxODAsIG1heExhdF0sIHpvb20pO1xuICAgICAgdmFyIHdlc3Rlcm5IZW0gPSB0aGlzLmdldENsdXN0ZXJzKFstMTgwLCBtaW5MYXQsIG1heExuZywgbWF4TGF0XSwgem9vbSk7XG4gICAgICByZXR1cm4gZWFzdGVybkhlbS5jb25jYXQod2VzdGVybkhlbSk7XG4gICAgfVxuICAgIHZhciB0cmVlID0gdGhpcy50cmVlc1t0aGlzLl9saW1pdFpvb20oem9vbSldO1xuICAgIHZhciBpZHMgPSB0cmVlLnJhbmdlKGxuZ1gobWluTG5nKSwgbGF0WShtYXhMYXQpLCBsbmdYKG1heExuZyksIGxhdFkobWluTGF0KSk7XG4gICAgdmFyIGRhdGEgPSB0cmVlLmRhdGE7XG4gICAgdmFyIGNsdXN0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaWQgb2YgaWRzKSB7XG4gICAgICB2YXIgayA9IHRoaXMuc3RyaWRlICogaWQ7XG4gICAgICBjbHVzdGVycy5wdXNoKGRhdGFbayArIE9GRlNFVF9OVU1dID4gMSA/IGdldENsdXN0ZXJKU09OKGRhdGEsIGssIHRoaXMuY2x1c3RlclByb3BzKSA6IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsdXN0ZXJzO1xuICB9XG4gIGdldENoaWxkcmVuKGNsdXN0ZXJJZCkge1xuICAgIHZhciBvcmlnaW5JZCA9IHRoaXMuX2dldE9yaWdpbklkKGNsdXN0ZXJJZCk7XG4gICAgdmFyIG9yaWdpblpvb20gPSB0aGlzLl9nZXRPcmlnaW5ab29tKGNsdXN0ZXJJZCk7XG4gICAgdmFyIGVycm9yTXNnID0gJ05vIGNsdXN0ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGlkLic7XG4gICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW29yaWdpblpvb21dO1xuICAgIGlmICghdHJlZSkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICB2YXIgZGF0YSA9IHRyZWUuZGF0YTtcbiAgICBpZiAob3JpZ2luSWQgKiB0aGlzLnN0cmlkZSA+PSBkYXRhLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbiAgICB2YXIgciA9IHRoaXMub3B0aW9ucy5yYWRpdXMgLyAodGhpcy5vcHRpb25zLmV4dGVudCAqIE1hdGgucG93KDIsIG9yaWdpblpvb20gLSAxKSk7XG4gICAgdmFyIHggPSBkYXRhW29yaWdpbklkICogdGhpcy5zdHJpZGVdO1xuICAgIHZhciB5ID0gZGF0YVtvcmlnaW5JZCAqIHRoaXMuc3RyaWRlICsgMV07XG4gICAgdmFyIGlkcyA9IHRyZWUud2l0aGluKHgsIHksIHIpO1xuICAgIHZhciBjaGlsZHJlbiA9IFtdO1xuICAgIGZvciAodmFyIGlkIG9mIGlkcykge1xuICAgICAgdmFyIGsgPSBpZCAqIHRoaXMuc3RyaWRlO1xuICAgICAgaWYgKGRhdGFbayArIE9GRlNFVF9QQVJFTlRdID09PSBjbHVzdGVySWQpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChkYXRhW2sgKyBPRkZTRVRfTlVNXSA+IDEgPyBnZXRDbHVzdGVySlNPTihkYXRhLCBrLCB0aGlzLmNsdXN0ZXJQcm9wcykgOiB0aGlzLnBvaW50c1tkYXRhW2sgKyBPRkZTRVRfSURdXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIGdldExlYXZlcyhjbHVzdGVySWQsIGxpbWl0LCBvZmZzZXQpIHtcbiAgICBsaW1pdCA9IGxpbWl0IHx8IDEwO1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHZhciBsZWF2ZXMgPSBbXTtcbiAgICB0aGlzLl9hcHBlbmRMZWF2ZXMobGVhdmVzLCBjbHVzdGVySWQsIGxpbWl0LCBvZmZzZXQsIDApO1xuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cbiAgZ2V0VGlsZSh6LCB4LCB5KSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLnRyZWVzW3RoaXMuX2xpbWl0Wm9vbSh6KV07XG4gICAgdmFyIHoyID0gTWF0aC5wb3coMiwgeik7XG4gICAgdmFyIHtcbiAgICAgIGV4dGVudCxcbiAgICAgIHJhZGl1c1xuICAgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIHAgPSByYWRpdXMgLyBleHRlbnQ7XG4gICAgdmFyIHRvcCA9ICh5IC0gcCkgLyB6MjtcbiAgICB2YXIgYm90dG9tID0gKHkgKyAxICsgcCkgLyB6MjtcbiAgICB2YXIgdGlsZSA9IHtcbiAgICAgIGZlYXR1cmVzOiBbXVxuICAgIH07XG4gICAgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKHRyZWUucmFuZ2UoKHggLSBwKSAvIHoyLCB0b3AsICh4ICsgMSArIHApIC8gejIsIGJvdHRvbSksIHRyZWUuZGF0YSwgeCwgeSwgejIsIHRpbGUpO1xuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICB0aGlzLl9hZGRUaWxlRmVhdHVyZXModHJlZS5yYW5nZSgxIC0gcCAvIHoyLCB0b3AsIDEsIGJvdHRvbSksIHRyZWUuZGF0YSwgejIsIHksIHoyLCB0aWxlKTtcbiAgICB9XG4gICAgaWYgKHggPT09IHoyIC0gMSkge1xuICAgICAgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKHRyZWUucmFuZ2UoMCwgdG9wLCBwIC8gejIsIGJvdHRvbSksIHRyZWUuZGF0YSwgLTEsIHksIHoyLCB0aWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbGUuZmVhdHVyZXMubGVuZ3RoID8gdGlsZSA6IG51bGw7XG4gIH1cbiAgZ2V0Q2x1c3RlckV4cGFuc2lvblpvb20oY2x1c3RlcklkKSB7XG4gICAgdmFyIGV4cGFuc2lvblpvb20gPSB0aGlzLl9nZXRPcmlnaW5ab29tKGNsdXN0ZXJJZCkgLSAxO1xuICAgIHdoaWxlIChleHBhbnNpb25ab29tIDw9IHRoaXMub3B0aW9ucy5tYXhab29tKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKGNsdXN0ZXJJZCk7XG4gICAgICBleHBhbnNpb25ab29tKys7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSBicmVhaztcbiAgICAgIGNsdXN0ZXJJZCA9IGNoaWxkcmVuWzBdLnByb3BlcnRpZXMuY2x1c3Rlcl9pZDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuc2lvblpvb207XG4gIH1cbiAgX2FwcGVuZExlYXZlcyhyZXN1bHQsIGNsdXN0ZXJJZCwgbGltaXQsIG9mZnNldCwgc2tpcHBlZCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oY2x1c3RlcklkKTtcbiAgICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgdmFyIHByb3BzID0gY2hpbGQucHJvcGVydGllcztcbiAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5jbHVzdGVyKSB7XG4gICAgICAgIGlmIChza2lwcGVkICsgcHJvcHMucG9pbnRfY291bnQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgLy8gc2tpcCB0aGUgd2hvbGUgY2x1c3RlclxuICAgICAgICAgIHNraXBwZWQgKz0gcHJvcHMucG9pbnRfY291bnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZW50ZXIgdGhlIGNsdXN0ZXJcbiAgICAgICAgICBza2lwcGVkID0gdGhpcy5fYXBwZW5kTGVhdmVzKHJlc3VsdCwgcHJvcHMuY2x1c3Rlcl9pZCwgbGltaXQsIG9mZnNldCwgc2tpcHBlZCk7XG4gICAgICAgICAgLy8gZXhpdCB0aGUgY2x1c3RlclxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNraXBwZWQgPCBvZmZzZXQpIHtcbiAgICAgICAgLy8gc2tpcCBhIHNpbmdsZSBwb2ludFxuICAgICAgICBza2lwcGVkKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IGxpbWl0KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHNraXBwZWQ7XG4gIH1cbiAgX2NyZWF0ZVRyZWUoZGF0YSkge1xuICAgIHZhciB0cmVlID0gbmV3IEtEQnVzaChkYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlIHwgMCwgdGhpcy5vcHRpb25zLm5vZGVTaXplLCBGbG9hdDMyQXJyYXkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5zdHJpZGUpIHRyZWUuYWRkKGRhdGFbaV0sIGRhdGFbaSArIDFdKTtcbiAgICB0cmVlLmZpbmlzaCgpO1xuICAgIHRyZWUuZGF0YSA9IGRhdGE7XG4gICAgcmV0dXJuIHRyZWU7XG4gIH1cbiAgX2FkZFRpbGVGZWF0dXJlcyhpZHMsIGRhdGEsIHgsIHksIHoyLCB0aWxlKSB7XG4gICAgZm9yICh2YXIgaSBvZiBpZHMpIHtcbiAgICAgIHZhciBrID0gaSAqIHRoaXMuc3RyaWRlO1xuICAgICAgdmFyIGlzQ2x1c3RlciA9IGRhdGFbayArIE9GRlNFVF9OVU1dID4gMTtcbiAgICAgIHZhciB0YWdzID0gdm9pZCAwLFxuICAgICAgICBweCA9IHZvaWQgMCxcbiAgICAgICAgcHkgPSB2b2lkIDA7XG4gICAgICBpZiAoaXNDbHVzdGVyKSB7XG4gICAgICAgIHRhZ3MgPSBnZXRDbHVzdGVyUHJvcGVydGllcyhkYXRhLCBrLCB0aGlzLmNsdXN0ZXJQcm9wcyk7XG4gICAgICAgIHB4ID0gZGF0YVtrXTtcbiAgICAgICAgcHkgPSBkYXRhW2sgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wb2ludHNbZGF0YVtrICsgT0ZGU0VUX0lEXV07XG4gICAgICAgIHRhZ3MgPSBwLnByb3BlcnRpZXM7XG4gICAgICAgIHZhciBbbG5nLCBsYXRdID0gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgcHggPSBsbmdYKGxuZyk7XG4gICAgICAgIHB5ID0gbGF0WShsYXQpO1xuICAgICAgfVxuICAgICAgdmFyIGYgPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGdlb21ldHJ5OiBbW01hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChweCAqIHoyIC0geCkpLCBNYXRoLnJvdW5kKHRoaXMub3B0aW9ucy5leHRlbnQgKiAocHkgKiB6MiAtIHkpKV1dLFxuICAgICAgICB0YWdzXG4gICAgICB9O1xuXG4gICAgICAvLyBhc3NpZ24gaWRcbiAgICAgIHZhciBpZCA9IHZvaWQgMDtcbiAgICAgIGlmIChpc0NsdXN0ZXIgfHwgdGhpcy5vcHRpb25zLmdlbmVyYXRlSWQpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxseSBnZW5lcmF0ZSBpZCBmb3IgcG9pbnRzXG4gICAgICAgIGlkID0gZGF0YVtrICsgT0ZGU0VUX0lEXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGtlZXAgaWQgaWYgYWxyZWFkeSBhc3NpZ25lZFxuICAgICAgICBpZCA9IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dLmlkO1xuICAgICAgfVxuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIGYuaWQgPSBpZDtcbiAgICAgIHRpbGUuZmVhdHVyZXMucHVzaChmKTtcbiAgICB9XG4gIH1cbiAgX2xpbWl0Wm9vbSh6KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbihNYXRoLmZsb29yKCt6KSwgdGhpcy5vcHRpb25zLm1heFpvb20gKyAxKSk7XG4gIH1cbiAgX2NsdXN0ZXIodHJlZSwgem9vbSkge1xuICAgIHZhciB7XG4gICAgICByYWRpdXMsXG4gICAgICBleHRlbnQsXG4gICAgICByZWR1Y2UsXG4gICAgICBtaW5Qb2ludHNcbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciByID0gcmFkaXVzIC8gKGV4dGVudCAqIE1hdGgucG93KDIsIHpvb20pKTtcbiAgICB2YXIgZGF0YSA9IHRyZWUuZGF0YTtcbiAgICB2YXIgbmV4dERhdGEgPSBbXTtcbiAgICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGU7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlIHBvaW50IGF0IHRoaXMgem9vbSBsZXZlbCwgc2tpcCBpdFxuICAgICAgaWYgKGRhdGFbaSArIE9GRlNFVF9aT09NXSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgIGRhdGFbaSArIE9GRlNFVF9aT09NXSA9IHpvb207XG5cbiAgICAgIC8vIGZpbmQgYWxsIG5lYXJieSBwb2ludHNcbiAgICAgIHZhciB4ID0gZGF0YVtpXTtcbiAgICAgIHZhciB5ID0gZGF0YVtpICsgMV07XG4gICAgICB2YXIgbmVpZ2hib3JJZHMgPSB0cmVlLndpdGhpbihkYXRhW2ldLCBkYXRhW2kgKyAxXSwgcik7XG4gICAgICB2YXIgbnVtUG9pbnRzT3JpZ2luID0gZGF0YVtpICsgT0ZGU0VUX05VTV07XG4gICAgICB2YXIgbnVtUG9pbnRzID0gbnVtUG9pbnRzT3JpZ2luO1xuXG4gICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIHBvaW50cyBpbiBhIHBvdGVudGlhbCBjbHVzdGVyXG4gICAgICBmb3IgKHZhciBuZWlnaGJvcklkIG9mIG5laWdoYm9ySWRzKSB7XG4gICAgICAgIHZhciBrID0gbmVpZ2hib3JJZCAqIHN0cmlkZTtcbiAgICAgICAgLy8gZmlsdGVyIG91dCBuZWlnaGJvcnMgdGhhdCBhcmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKGRhdGFbayArIE9GRlNFVF9aT09NXSA+IHpvb20pIG51bVBvaW50cyArPSBkYXRhW2sgKyBPRkZTRVRfTlVNXTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgd2VyZSBuZWlnaGJvcnMgdG8gbWVyZ2UsIGFuZCB0aGVyZSBhcmUgZW5vdWdoIHBvaW50cyB0byBmb3JtIGEgY2x1c3RlclxuICAgICAgaWYgKG51bVBvaW50cyA+IG51bVBvaW50c09yaWdpbiAmJiBudW1Qb2ludHMgPj0gbWluUG9pbnRzKSB7XG4gICAgICAgIHZhciB3eCA9IHggKiBudW1Qb2ludHNPcmlnaW47XG4gICAgICAgIHZhciB3eSA9IHkgKiBudW1Qb2ludHNPcmlnaW47XG4gICAgICAgIHZhciBjbHVzdGVyUHJvcGVydGllcyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGNsdXN0ZXJQcm9wSW5kZXggPSAtMTtcblxuICAgICAgICAvLyBlbmNvZGUgYm90aCB6b29tIGFuZCBwb2ludCBpbmRleCBvbiB3aGljaCB0aGUgY2x1c3RlciBvcmlnaW5hdGVkIC0tIG9mZnNldCBieSB0b3RhbCBsZW5ndGggb2YgZmVhdHVyZXNcbiAgICAgICAgdmFyIGlkID0gKChpIC8gc3RyaWRlIHwgMCkgPDwgNSkgKyAoem9vbSArIDEpICsgdGhpcy5wb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBfbmVpZ2hib3JJZCBvZiBuZWlnaGJvcklkcykge1xuICAgICAgICAgIHZhciBfayA9IF9uZWlnaGJvcklkICogc3RyaWRlO1xuICAgICAgICAgIGlmIChkYXRhW19rICsgT0ZGU0VUX1pPT01dIDw9IHpvb20pIGNvbnRpbnVlO1xuICAgICAgICAgIGRhdGFbX2sgKyBPRkZTRVRfWk9PTV0gPSB6b29tOyAvLyBzYXZlIHRoZSB6b29tIChzbyBpdCBkb2Vzbid0IGdldCBwcm9jZXNzZWQgdHdpY2UpXG5cbiAgICAgICAgICB2YXIgbnVtUG9pbnRzMiA9IGRhdGFbX2sgKyBPRkZTRVRfTlVNXTtcbiAgICAgICAgICB3eCArPSBkYXRhW19rXSAqIG51bVBvaW50czI7IC8vIGFjY3VtdWxhdGUgY29vcmRpbmF0ZXMgZm9yIGNhbGN1bGF0aW5nIHdlaWdodGVkIGNlbnRlclxuICAgICAgICAgIHd5ICs9IGRhdGFbX2sgKyAxXSAqIG51bVBvaW50czI7XG4gICAgICAgICAgZGF0YVtfayArIE9GRlNFVF9QQVJFTlRdID0gaWQ7XG4gICAgICAgICAgaWYgKHJlZHVjZSkge1xuICAgICAgICAgICAgaWYgKCFjbHVzdGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgICBjbHVzdGVyUHJvcGVydGllcyA9IHRoaXMuX21hcChkYXRhLCBpLCB0cnVlKTtcbiAgICAgICAgICAgICAgY2x1c3RlclByb3BJbmRleCA9IHRoaXMuY2x1c3RlclByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyUHJvcHMucHVzaChjbHVzdGVyUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWR1Y2UoY2x1c3RlclByb3BlcnRpZXMsIHRoaXMuX21hcChkYXRhLCBfaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhW2kgKyBPRkZTRVRfUEFSRU5UXSA9IGlkO1xuICAgICAgICBuZXh0RGF0YS5wdXNoKHd4IC8gbnVtUG9pbnRzLCB3eSAvIG51bVBvaW50cywgSW5maW5pdHksIGlkLCAtMSwgbnVtUG9pbnRzKTtcbiAgICAgICAgaWYgKHJlZHVjZSkgbmV4dERhdGEucHVzaChjbHVzdGVyUHJvcEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxlZnQgcG9pbnRzIGFzIHVuY2x1c3RlcmVkXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyaWRlOyBqKyspIG5leHREYXRhLnB1c2goZGF0YVtpICsgal0pO1xuICAgICAgICBpZiAobnVtUG9pbnRzID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIF9uZWlnaGJvcklkMiBvZiBuZWlnaGJvcklkcykge1xuICAgICAgICAgICAgdmFyIF9rMiA9IF9uZWlnaGJvcklkMiAqIHN0cmlkZTtcbiAgICAgICAgICAgIGlmIChkYXRhW19rMiArIE9GRlNFVF9aT09NXSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgIGRhdGFbX2syICsgT0ZGU0VUX1pPT01dID0gem9vbTtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzdHJpZGU7IF9qKyspIG5leHREYXRhLnB1c2goZGF0YVtfazIgKyBfal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dERhdGE7XG4gIH1cblxuICAvLyBnZXQgaW5kZXggb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZFxuICBfZ2V0T3JpZ2luSWQoY2x1c3RlcklkKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJJZCAtIHRoaXMucG9pbnRzLmxlbmd0aCA+PiA1O1xuICB9XG5cbiAgLy8gZ2V0IHpvb20gb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZFxuICBfZ2V0T3JpZ2luWm9vbShjbHVzdGVySWQpIHtcbiAgICByZXR1cm4gKGNsdXN0ZXJJZCAtIHRoaXMucG9pbnRzLmxlbmd0aCkgJSAzMjtcbiAgfVxuICBfbWFwKGRhdGEsIGksIGNsb25lKSB7XG4gICAgaWYgKGRhdGFbaSArIE9GRlNFVF9OVU1dID4gMSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5jbHVzdGVyUHJvcHNbZGF0YVtpICsgT0ZGU0VUX1BST1BdXTtcbiAgICAgIHJldHVybiBjbG9uZSA/IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSA6IHByb3BzO1xuICAgIH1cbiAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLnBvaW50c1tkYXRhW2kgKyBPRkZTRVRfSURdXS5wcm9wZXJ0aWVzO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLm9wdGlvbnMubWFwKG9yaWdpbmFsKTtcbiAgICByZXR1cm4gY2xvbmUgJiYgcmVzdWx0ID09PSBvcmlnaW5hbCA/IE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCkgOiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENsdXN0ZXJKU09OKGRhdGEsIGksIGNsdXN0ZXJQcm9wcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICBpZDogZGF0YVtpICsgT0ZGU0VUX0lEXSxcbiAgICBwcm9wZXJ0aWVzOiBnZXRDbHVzdGVyUHJvcGVydGllcyhkYXRhLCBpLCBjbHVzdGVyUHJvcHMpLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgY29vcmRpbmF0ZXM6IFt4TG5nKGRhdGFbaV0pLCB5TGF0KGRhdGFbaSArIDFdKV1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbHVzdGVyUHJvcGVydGllcyhkYXRhLCBpLCBjbHVzdGVyUHJvcHMpIHtcbiAgdmFyIGNvdW50ID0gZGF0YVtpICsgT0ZGU0VUX05VTV07XG4gIHZhciBhYmJyZXYgPSBjb3VudCA+PSAxMDAwMCA/IFwiXCIuY29uY2F0KE1hdGgucm91bmQoY291bnQgLyAxMDAwKSwgXCJrXCIpIDogY291bnQgPj0gMTAwMCA/IFwiXCIuY29uY2F0KE1hdGgucm91bmQoY291bnQgLyAxMDApIC8gMTAsIFwia1wiKSA6IGNvdW50O1xuICB2YXIgcHJvcEluZGV4ID0gZGF0YVtpICsgT0ZGU0VUX1BST1BdO1xuICB2YXIgcHJvcGVydGllcyA9IHByb3BJbmRleCA9PT0gLTEgPyB7fSA6IE9iamVjdC5hc3NpZ24oe30sIGNsdXN0ZXJQcm9wc1twcm9wSW5kZXhdKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywge1xuICAgIGNsdXN0ZXI6IHRydWUsXG4gICAgY2x1c3Rlcl9pZDogZGF0YVtpICsgT0ZGU0VUX0lEXSxcbiAgICBwb2ludF9jb3VudDogY291bnQsXG4gICAgcG9pbnRfY291bnRfYWJicmV2aWF0ZWQ6IGFiYnJldlxuICB9KTtcbn1cblxuLy8gbG9uZ2l0dWRlL2xhdGl0dWRlIHRvIHNwaGVyaWNhbCBtZXJjYXRvciBpbiBbMC4uMV0gcmFuZ2VcbmZ1bmN0aW9uIGxuZ1gobG5nKSB7XG4gIHJldHVybiBsbmcgLyAzNjAgKyAwLjU7XG59XG5mdW5jdGlvbiBsYXRZKGxhdCkge1xuICB2YXIgc2luID0gTWF0aC5zaW4obGF0ICogTWF0aC5QSSAvIDE4MCk7XG4gIHZhciB5ID0gMC41IC0gMC4yNSAqIE1hdGgubG9nKCgxICsgc2luKSAvICgxIC0gc2luKSkgLyBNYXRoLlBJO1xuICByZXR1cm4geSA8IDAgPyAwIDogeSA+IDEgPyAxIDogeTtcbn1cblxuLy8gc3BoZXJpY2FsIG1lcmNhdG9yIHRvIGxvbmdpdHVkZS9sYXRpdHVkZVxuZnVuY3Rpb24geExuZyh4KSB7XG4gIHJldHVybiAoeCAtIDAuNSkgKiAzNjA7XG59XG5mdW5jdGlvbiB5TGF0KHkpIHtcbiAgdmFyIHkyID0gKDE4MCAtIHkgKiAzNjApICogTWF0aC5QSSAvIDE4MDtcbiAgcmV0dXJuIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cCh5MikpIC8gTWF0aC5QSSAtIDkwO1xufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMCkgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogdXRpbCBjbGFzcyB0aGF0IGNyZWF0ZXMgYSBjb21tb24gc2V0IG9mIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyB0byB3cmFwXG4gKiBzaGFyZWQgYmVoYXZpb3Igb2YgQWR2YW5jZWQgTWFya2VycyBhbmQgTWFya2Vycy5cbiAqL1xuY2xhc3MgTWFya2VyVXRpbHMge1xuICBzdGF0aWMgaXNBZHZhbmNlZE1hcmtlckF2YWlsYWJsZShtYXApIHtcbiAgICByZXR1cm4gZ29vZ2xlLm1hcHMubWFya2VyICYmIG1hcC5nZXRNYXBDYXBhYmlsaXRpZXMoKS5pc0FkdmFuY2VkTWFya2Vyc0F2YWlsYWJsZSA9PT0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpIHtcbiAgICByZXR1cm4gZ29vZ2xlLm1hcHMubWFya2VyICYmIG1hcmtlciBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLm1hcmtlci5BZHZhbmNlZE1hcmtlckVsZW1lbnQ7XG4gIH1cbiAgc3RhdGljIHNldE1hcChtYXJrZXIsIG1hcCkge1xuICAgIGlmICh0aGlzLmlzQWR2YW5jZWRNYXJrZXIobWFya2VyKSkge1xuICAgICAgbWFya2VyLm1hcCA9IG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyLnNldE1hcChtYXApO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0UG9zaXRpb24obWFya2VyKSB7XG4gICAgLy8gU3VwZXJDbHVzdGVyQWxnb3JpdGhtLmNhbGN1bGF0ZSBleHBlY3RzIGEgTGF0TG5nIGluc3RhbmNlIHNvIHdlIGZha2UgaXQgZm9yIEFkdiBNYXJrZXJzXG4gICAgaWYgKHRoaXMuaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpKSB7XG4gICAgICBpZiAobWFya2VyLnBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChtYXJrZXIucG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpIHtcbiAgICAgICAgICByZXR1cm4gbWFya2VyLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpbmNlIHdlIGNhbid0IGNhc3QgdG8gTGF0TG5nTGl0ZXJhbCBmb3IgcmVhc29ucyA9KFxuICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uLmxhdCAmJiBtYXJrZXIucG9zaXRpb24ubG5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5MYXRMbmcobWFya2VyLnBvc2l0aW9uLmxhdCwgbWFya2VyLnBvc2l0aW9uLmxuZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gIH1cbiAgc3RhdGljIGdldFZpc2libGUobWFya2VyKSB7XG4gICAgaWYgKHRoaXMuaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpKSB7XG4gICAgICAvKipcbiAgICAgICAqIEFsd2F5cyByZXR1cm4gdHJ1ZSBmb3IgQWR2YW5jZWQgTWFya2VycyBiZWNhdXNlIHRoZSBjbHVzdGVyZXJcbiAgICAgICAqIHVzZXMgZ2V0VmlzaWJsZSBhcyBhIHdheSB0byBjb3VudCBsZWdhY3kgbWFya2VycyBub3QgYXMgYW4gYWN0dWFsXG4gICAgICAgKiBpbmRpY2F0b3Igb2YgdmlzaWJpbGl0eSBmb3Igc29tZSByZWFzb24uIEV2ZW4gd2hlbiBtYXJrZXJzIGFyZSBoaWRkZW5cbiAgICAgICAqIE1hcmtlci5nZXRWaXNpYmxlIHJldHVybnMgYHRydWVgIGFuZCB0aGlzIGlzIHVzZWQgdG8gc2V0IHRoZSBtYXJrZXIgY291bnRcbiAgICAgICAqIG9uIHRoZSBjbHVzdGVyLiBTZWUgdGhlIGJlaGF2aW9yIG9mIENsdXN0ZXIuY291bnRcbiAgICAgICAqL1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXIuZ2V0VmlzaWJsZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNsYXNzIENsdXN0ZXIge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtlcnMsXG4gICAgICBwb3NpdGlvblxuICAgIH0gPSBfcmVmO1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBpZiAocG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBib3VuZHMoKSB7XG4gICAgaWYgKHRoaXMubWFya2Vycy5sZW5ndGggPT09IDAgJiYgIXRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuX3Bvc2l0aW9uLCB0aGlzLl9wb3NpdGlvbik7XG4gICAgZm9yICh2YXIgbWFya2VyIG9mIHRoaXMubWFya2Vycykge1xuICAgICAgYm91bmRzLmV4dGVuZChNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uIHx8IHRoaXMuYm91bmRzLmdldENlbnRlcigpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNvdW50IG9mICoqdmlzaWJsZSoqIG1hcmtlcnMuXG4gICAqL1xuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFya2Vycy5maWx0ZXIobSA9PiBNYXJrZXJVdGlscy5nZXRWaXNpYmxlKG0pKS5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIG1hcmtlciB0byB0aGUgY2x1c3Rlci5cbiAgICovXG4gIHB1c2gobWFya2VyKSB7XG4gICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYW51cCByZWZlcmVuY2VzIGFuZCByZW1vdmUgbWFya2VyIGZyb20gbWFwLlxuICAgKi9cbiAgZGVsZXRlKCkge1xuICAgIGlmICh0aGlzLm1hcmtlcikge1xuICAgICAgTWFya2VyVXRpbHMuc2V0TWFwKHRoaXMubWFya2VyLCBudWxsKTtcbiAgICAgIHRoaXMubWFya2VyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB0aGlzLm1hcmtlcnMubGVuZ3RoID0gMDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgdGhlIG1hcmtlcnMgdmlzaWJsZSBpbiBhIHBhZGRlZCBtYXAgdmlld3BvcnRcbiAqXG4gKiBAcGFyYW0gbWFwXG4gKiBAcGFyYW0gbWFwQ2FudmFzUHJvamVjdGlvblxuICogQHBhcmFtIG1hcmtlcnMgVGhlIGxpc3Qgb2YgbWFya2VyIHRvIGZpbHRlclxuICogQHBhcmFtIHZpZXdwb3J0UGFkZGluZ1BpeGVscyBUaGUgcGFkZGluZyBpbiBwaXhlbFxuICogQHJldHVybnMgVGhlIGxpc3Qgb2YgbWFya2VycyBpbiB0aGUgcGFkZGVkIHZpZXdwb3J0XG4gKi9cbnZhciBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydCA9IChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHZpZXdwb3J0UGFkZGluZ1BpeGVscykgPT4ge1xuICB2YXIgZXh0ZW5kZWRNYXBCb3VuZHMgPSBleHRlbmRCb3VuZHNUb1BhZGRlZFZpZXdwb3J0KG1hcC5nZXRCb3VuZHMoKSwgbWFwQ2FudmFzUHJvamVjdGlvbiwgdmlld3BvcnRQYWRkaW5nUGl4ZWxzKTtcbiAgcmV0dXJuIG1hcmtlcnMuZmlsdGVyKG1hcmtlciA9PiBleHRlbmRlZE1hcEJvdW5kcy5jb250YWlucyhNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpKSk7XG59O1xuLyoqXG4gKiBFeHRlbmRzIGEgYm91bmRzIGJ5IGEgbnVtYmVyIG9mIHBpeGVscyBpbiBlYWNoIGRpcmVjdGlvblxuICovXG52YXIgZXh0ZW5kQm91bmRzVG9QYWRkZWRWaWV3cG9ydCA9IChib3VuZHMsIHByb2plY3Rpb24sIG51bVBpeGVscykgPT4ge1xuICB2YXIge1xuICAgIG5vcnRoRWFzdCxcbiAgICBzb3V0aFdlc3RcbiAgfSA9IGxhdExuZ0JvdW5kc1RvUGl4ZWxCb3VuZHMoYm91bmRzLCBwcm9qZWN0aW9uKTtcbiAgdmFyIGV4dGVuZGVkUGl4ZWxCb3VuZHMgPSBleHRlbmRQaXhlbEJvdW5kcyh7XG4gICAgbm9ydGhFYXN0LFxuICAgIHNvdXRoV2VzdFxuICB9LCBudW1QaXhlbHMpO1xuICByZXR1cm4gcGl4ZWxCb3VuZHNUb0xhdExuZ0JvdW5kcyhleHRlbmRlZFBpeGVsQm91bmRzLCBwcm9qZWN0aW9uKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIGV4dGVuZGVkIGJvdW5kcyBhcyBhIGJib3ggW3dlc3RMbmcsIHNvdXRoTGF0LCBlYXN0TG5nLCBub3J0aExhdF1cbiAqL1xudmFyIGdldFBhZGRlZFZpZXdwb3J0ID0gKGJvdW5kcywgcHJvamVjdGlvbiwgcGl4ZWxzKSA9PiB7XG4gIHZhciBleHRlbmRlZCA9IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQoYm91bmRzLCBwcm9qZWN0aW9uLCBwaXhlbHMpO1xuICB2YXIgbmUgPSBleHRlbmRlZC5nZXROb3J0aEVhc3QoKTtcbiAgdmFyIHN3ID0gZXh0ZW5kZWQuZ2V0U291dGhXZXN0KCk7XG4gIHJldHVybiBbc3cubG5nKCksIHN3LmxhdCgpLCBuZS5sbmcoKSwgbmUubGF0KCldO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvc2l0aW9ucy5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBkaXN0YW5jZUJldHdlZW5Qb2ludHMgPSAocDEsIHAyKSA9PiB7XG4gIHZhciBSID0gNjM3MTsgLy8gUmFkaXVzIG9mIHRoZSBFYXJ0aCBpbiBrbVxuICB2YXIgZExhdCA9IChwMi5sYXQgLSBwMS5sYXQpICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIGRMb24gPSAocDIubG5nIC0gcDEubG5nKSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciBzaW5ETGF0ID0gTWF0aC5zaW4oZExhdCAvIDIpO1xuICB2YXIgc2luRExvbiA9IE1hdGguc2luKGRMb24gLyAyKTtcbiAgdmFyIGEgPSBzaW5ETGF0ICogc2luRExhdCArIE1hdGguY29zKHAxLmxhdCAqIE1hdGguUEkgLyAxODApICogTWF0aC5jb3MocDIubGF0ICogTWF0aC5QSSAvIDE4MCkgKiBzaW5ETG9uICogc2luRExvbjtcbiAgdmFyIGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xuICByZXR1cm4gUiAqIGM7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIExhdExuZyBib3VuZCB0byBwaXhlbHMuXG4gKlxuICogQGhpZGRlblxuICovXG52YXIgbGF0TG5nQm91bmRzVG9QaXhlbEJvdW5kcyA9IChib3VuZHMsIHByb2plY3Rpb24pID0+IHtcbiAgcmV0dXJuIHtcbiAgICBub3J0aEVhc3Q6IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldE5vcnRoRWFzdCgpKSxcbiAgICBzb3V0aFdlc3Q6IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldFNvdXRoV2VzdCgpKVxuICB9O1xufTtcbi8qKlxuICogRXh0ZW5kcyBhIHBpeGVsIGJvdW5kcyBieSBudW1QaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKlxuICogQGhpZGRlblxuICovXG52YXIgZXh0ZW5kUGl4ZWxCb3VuZHMgPSAoX3JlZjIsIG51bVBpeGVscykgPT4ge1xuICB2YXIge1xuICAgIG5vcnRoRWFzdCxcbiAgICBzb3V0aFdlc3RcbiAgfSA9IF9yZWYyO1xuICBub3J0aEVhc3QueCArPSBudW1QaXhlbHM7XG4gIG5vcnRoRWFzdC55IC09IG51bVBpeGVscztcbiAgc291dGhXZXN0LnggLT0gbnVtUGl4ZWxzO1xuICBzb3V0aFdlc3QueSArPSBudW1QaXhlbHM7XG4gIHJldHVybiB7XG4gICAgbm9ydGhFYXN0LFxuICAgIHNvdXRoV2VzdFxuICB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgcGl4ZWxCb3VuZHNUb0xhdExuZ0JvdW5kcyA9IChfcmVmMywgcHJvamVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIG5vcnRoRWFzdCxcbiAgICBzb3V0aFdlc3RcbiAgfSA9IF9yZWYzO1xuICB2YXIgc3cgPSBwcm9qZWN0aW9uLmZyb21EaXZQaXhlbFRvTGF0TG5nKHNvdXRoV2VzdCk7XG4gIHZhciBuZSA9IHByb2plY3Rpb24uZnJvbURpdlBpeGVsVG9MYXRMbmcobm9ydGhFYXN0KTtcbiAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoc3csIG5lKTtcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gIGNvbnN0cnVjdG9yKF9yZWY0KSB7XG4gICAgdmFyIHtcbiAgICAgIG1heFpvb20gPSAxNlxuICAgIH0gPSBfcmVmNDtcbiAgICB0aGlzLm1heFpvb20gPSBtYXhab29tO1xuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gYnlwYXNzIGNsdXN0ZXJpbmcgYmFzZWQgdXBvbiBzb21lIG1hcCBzdGF0ZSBzdWNoIGFzXG4gICAqIHpvb20sIG51bWJlciBvZiBtYXJrZXJzLCBldGMuXG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogIGNsdXN0ZXIoe21hcmtlcnMsIG1hcH06IEFsZ29yaXRobUlucHV0KTogQ2x1c3RlcltdIHtcbiAgICogICAgaWYgKHNob3VsZEJ5cGFzc0NsdXN0ZXJpbmcobWFwKSkge1xuICAgKiAgICAgIHJldHVybiB0aGlzLm5vb3Aoe21hcmtlcnN9KVxuICAgKiAgICB9XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBub29wKF9yZWY1KSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtlcnNcbiAgICB9ID0gX3JlZjU7XG4gICAgcmV0dXJuIG5vb3AkMShtYXJrZXJzKTtcbiAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCB2aWV3cG9ydCBhbGdvcml0aG0gcHJvdmVzIGEgY2xhc3MgdG8gZmlsdGVyIG1hcmtlcnMgYnkgYSBwYWRkZWRcbiAqIHZpZXdwb3J0LiBUaGlzIGlzIGEgY29tbW9uIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgdmFyIHtcbiAgICAgICAgdmlld3BvcnRQYWRkaW5nID0gNjBcbiAgICAgIH0gPSBfYSxcbiAgICAgIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcInZpZXdwb3J0UGFkZGluZ1wiXSk7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy52aWV3cG9ydFBhZGRpbmcgPSA2MDtcbiAgICB0aGlzLnZpZXdwb3J0UGFkZGluZyA9IHZpZXdwb3J0UGFkZGluZztcbiAgfVxuICBjYWxjdWxhdGUoX3JlZjYpIHtcbiAgICB2YXIge1xuICAgICAgbWFya2VycyxcbiAgICAgIG1hcCxcbiAgICAgIG1hcENhbnZhc1Byb2plY3Rpb25cbiAgICB9ID0gX3JlZjY7XG4gICAgaWYgKG1hcC5nZXRab29tKCkgPj0gdGhpcy5tYXhab29tKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbHVzdGVyczogdGhpcy5ub29wKHtcbiAgICAgICAgICBtYXJrZXJzXG4gICAgICAgIH0pLFxuICAgICAgICBjaGFuZ2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsdXN0ZXJzOiB0aGlzLmNsdXN0ZXIoe1xuICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgbWFwLFxuICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgbm9vcCQxID0gbWFya2VycyA9PiB7XG4gIHZhciBjbHVzdGVycyA9IG1hcmtlcnMubWFwKG1hcmtlciA9PiBuZXcgQ2x1c3Rlcih7XG4gICAgcG9zaXRpb246IE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlciksXG4gICAgbWFya2VyczogW21hcmtlcl1cbiAgfSkpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoZSBkZWZhdWx0IEdyaWQgYWxnb3JpdGhtIGhpc3RvcmljYWxseSB1c2VkIGluIEdvb2dsZSBNYXBzIG1hcmtlclxuICogY2x1c3RlcmluZy5cbiAqXG4gKiBUaGUgR3JpZCBhbGdvcml0aG0gZG9lcyBub3QgaW1wbGVtZW50IGNhY2hpbmcgYW5kIG1hcmtlcnMgbWF5IGZsYXNoIGFzIHRoZVxuICogdmlld3BvcnQgY2hhbmdlcy4gSW5zdGVhZCB1c2Uge0BsaW5rIFN1cGVyQ2x1c3RlckFsZ29yaXRobX0uXG4gKi9cbmNsYXNzIEdyaWRBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdFZpZXdwb3J0QWxnb3JpdGhtIHtcbiAgY29uc3RydWN0b3IoX2EpIHtcbiAgICB2YXIge1xuICAgICAgICBtYXhEaXN0YW5jZSA9IDQwMDAwLFxuICAgICAgICBncmlkU2l6ZSA9IDQwXG4gICAgICB9ID0gX2EsXG4gICAgICBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJtYXhEaXN0YW5jZVwiLCBcImdyaWRTaXplXCJdKTtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHpvb206IC0xXG4gICAgfTtcbiAgICB0aGlzLm1heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG4gICAgdGhpcy5ncmlkU2l6ZSA9IGdyaWRTaXplO1xuICB9XG4gIGNhbGN1bGF0ZShfcmVmNykge1xuICAgIHZhciB7XG4gICAgICBtYXJrZXJzLFxuICAgICAgbWFwLFxuICAgICAgbWFwQ2FudmFzUHJvamVjdGlvblxuICAgIH0gPSBfcmVmNztcbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICB6b29tOiBtYXAuZ2V0Wm9vbSgpXG4gICAgfTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnN0YXRlLnpvb20gPj0gdGhpcy5tYXhab29tICYmIHN0YXRlLnpvb20gPj0gdGhpcy5tYXhab29tKSA7ZWxzZSB7XG4gICAgICBjaGFuZ2VkID0gIWVxdWFsKHRoaXMuc3RhdGUsIHN0YXRlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGlmIChtYXAuZ2V0Wm9vbSgpID49IHRoaXMubWF4Wm9vbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2x1c3RlcnM6IHRoaXMubm9vcCh7XG4gICAgICAgICAgbWFya2Vyc1xuICAgICAgICB9KSxcbiAgICAgICAgY2hhbmdlZFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsdXN0ZXJzOiB0aGlzLmNsdXN0ZXIoe1xuICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgbWFwLFxuICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgY2x1c3RlcihfcmVmOCkge1xuICAgIHZhciB7XG4gICAgICBtYXJrZXJzLFxuICAgICAgbWFwLFxuICAgICAgbWFwQ2FudmFzUHJvamVjdGlvblxuICAgIH0gPSBfcmVmODtcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgbWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICB0aGlzLmFkZFRvQ2xvc2VzdENsdXN0ZXIobWFya2VyLCBtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNsdXN0ZXJzO1xuICB9XG4gIGFkZFRvQ2xvc2VzdENsdXN0ZXIobWFya2VyLCBtYXAsIHByb2plY3Rpb24pIHtcbiAgICB2YXIgbWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlOyAvLyBTb21lIGxhcmdlIG51bWJlclxuICAgIHZhciBjbHVzdGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSB0aGlzLmNsdXN0ZXJzW2ldO1xuICAgICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGNhbmRpZGF0ZS5ib3VuZHMuZ2V0Q2VudGVyKCkudG9KU09OKCksIE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcikudG9KU09OKCkpO1xuICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgY2x1c3RlciA9IGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsdXN0ZXIgJiYgZXh0ZW5kQm91bmRzVG9QYWRkZWRWaWV3cG9ydChjbHVzdGVyLmJvdW5kcywgcHJvamVjdGlvbiwgdGhpcy5ncmlkU2l6ZSkuY29udGFpbnMoTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSkpIHtcbiAgICAgIGNsdXN0ZXIucHVzaChtYXJrZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih7XG4gICAgICAgIG1hcmtlcnM6IFttYXJrZXJdXG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2x1c3RlcnMucHVzaChfY2x1c3Rlcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogTm9vcCBhbGdvcml0aG0gZG9lcyBub3QgZ2VuZXJhdGUgYW55IGNsdXN0ZXJzIG9yIGZpbHRlciBtYXJrZXJzIGJ5IHRoZSBhbiBleHRlbmRlZCB2aWV3cG9ydC5cbiAqL1xuY2xhc3MgTm9vcEFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0QWxnb3JpdGhtIHtcbiAgY29uc3RydWN0b3IoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9fcmVzdChfYSwgW10pO1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIGNhbGN1bGF0ZShfcmVmOSkge1xuICAgIHZhciB7XG4gICAgICBtYXJrZXJzLFxuICAgICAgbWFwLFxuICAgICAgbWFwQ2FudmFzUHJvamVjdGlvblxuICAgIH0gPSBfcmVmOTtcbiAgICByZXR1cm4ge1xuICAgICAgY2x1c3RlcnM6IHRoaXMuY2x1c3Rlcih7XG4gICAgICAgIG1hcmtlcnMsXG4gICAgICAgIG1hcCxcbiAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvblxuICAgICAgfSksXG4gICAgICBjaGFuZ2VkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2x1c3RlcihpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLm5vb3AoaW5wdXQpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB2ZXJ5IGZhc3QgSmF2YVNjcmlwdCBhbGdvcml0aG0gZm9yIGdlb3NwYXRpYWwgcG9pbnQgY2x1c3RlcmluZyB1c2luZyBLRCB0cmVlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3N1cGVyY2x1c3RlciBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBvcHRpb25zLlxuICovXG5jbGFzcyBTdXBlckNsdXN0ZXJBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgdmFyIHtcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgcmFkaXVzID0gNjBcbiAgICAgIH0gPSBfYSxcbiAgICAgIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcIm1heFpvb21cIiwgXCJyYWRpdXNcIl0pO1xuICAgIHN1cGVyKHtcbiAgICAgIG1heFpvb21cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgem9vbTogLTFcbiAgICB9O1xuICAgIHRoaXMuc3VwZXJDbHVzdGVyID0gbmV3IFN1cGVyY2x1c3RlcihPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFpvb206IHRoaXMubWF4Wm9vbSxcbiAgICAgIHJhZGl1c1xuICAgIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBjYWxjdWxhdGUoaW5wdXQpIHtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHpvb206IGlucHV0Lm1hcC5nZXRab29tKClcbiAgICB9O1xuICAgIGlmICghZXF1YWwoaW5wdXQubWFya2VycywgdGhpcy5tYXJrZXJzKSkge1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyBUT0RPIHVzZSBwcm94eSB0byBhdm9pZCBjb3B5P1xuICAgICAgdGhpcy5tYXJrZXJzID0gWy4uLmlucHV0Lm1hcmtlcnNdO1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMubWFya2Vycy5tYXAobWFya2VyID0+IHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKTtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gW3Bvc2l0aW9uLmxuZygpLCBwb3NpdGlvbi5sYXQoKV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBtYXJrZXJcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3VwZXJDbHVzdGVyLmxvYWQocG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS56b29tIDw9IHRoaXMubWF4Wm9vbSB8fCBzdGF0ZS56b29tIDw9IHRoaXMubWF4Wm9vbSkge1xuICAgICAgICBjaGFuZ2VkID0gIWVxdWFsKHRoaXMuc3RhdGUsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmNsdXN0ZXJzID0gdGhpcy5jbHVzdGVyKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsdXN0ZXJzOiB0aGlzLmNsdXN0ZXJzLFxuICAgICAgY2hhbmdlZFxuICAgIH07XG4gIH1cbiAgY2x1c3RlcihfcmVmMTApIHtcbiAgICB2YXIge1xuICAgICAgbWFwXG4gICAgfSA9IF9yZWYxMDtcbiAgICByZXR1cm4gdGhpcy5zdXBlckNsdXN0ZXIuZ2V0Q2x1c3RlcnMoWy0xODAsIC05MCwgMTgwLCA5MF0sIE1hdGgucm91bmQobWFwLmdldFpvb20oKSkpLm1hcChmZWF0dXJlID0+IHRoaXMudHJhbnNmb3JtQ2x1c3RlcihmZWF0dXJlKSk7XG4gIH1cbiAgdHJhbnNmb3JtQ2x1c3RlcihfcmVmMTEpIHtcbiAgICB2YXIge1xuICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgY29vcmRpbmF0ZXM6IFtsbmcsIGxhdF1cbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0aWVzXG4gICAgfSA9IF9yZWYxMTtcbiAgICBpZiAocHJvcGVydGllcy5jbHVzdGVyKSB7XG4gICAgICByZXR1cm4gbmV3IENsdXN0ZXIoe1xuICAgICAgICBtYXJrZXJzOiB0aGlzLnN1cGVyQ2x1c3Rlci5nZXRMZWF2ZXMocHJvcGVydGllcy5jbHVzdGVyX2lkLCBJbmZpbml0eSkubWFwKGxlYWYgPT4gbGVhZi5wcm9wZXJ0aWVzLm1hcmtlciksXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgbGF0LFxuICAgICAgICAgIGxuZ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIG1hcmtlciA9IHByb3BlcnRpZXMubWFya2VyO1xuICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICBtYXJrZXJzOiBbbWFya2VyXSxcbiAgICAgIHBvc2l0aW9uOiBNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnkgZmFzdCBKYXZhU2NyaXB0IGFsZ29yaXRobSBmb3IgZ2Vvc3BhdGlhbCBwb2ludCBjbHVzdGVyaW5nIHVzaW5nIEtEIHRyZWVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3VwZXJjbHVzdGVyIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFN1cGVyQ2x1c3RlclZpZXdwb3J0QWxnb3JpdGhtIGV4dGVuZHMgQWJzdHJhY3RWaWV3cG9ydEFsZ29yaXRobSB7XG4gIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgdmFyIHtcbiAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgcmFkaXVzID0gNjAsXG4gICAgICAgIHZpZXdwb3J0UGFkZGluZyA9IDYwXG4gICAgICB9ID0gX2EsXG4gICAgICBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJtYXhab29tXCIsIFwicmFkaXVzXCIsIFwidmlld3BvcnRQYWRkaW5nXCJdKTtcbiAgICBzdXBlcih7XG4gICAgICBtYXhab29tLFxuICAgICAgdmlld3BvcnRQYWRkaW5nXG4gICAgfSk7XG4gICAgdGhpcy5zdXBlckNsdXN0ZXIgPSBuZXcgU3VwZXJjbHVzdGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4Wm9vbTogdGhpcy5tYXhab29tLFxuICAgICAgcmFkaXVzXG4gICAgfSwgb3B0aW9ucykpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB6b29tOiAtMSxcbiAgICAgIHZpZXc6IFswLCAwLCAwLCAwXVxuICAgIH07XG4gIH1cbiAgY2FsY3VsYXRlKGlucHV0KSB7XG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgem9vbTogTWF0aC5yb3VuZChpbnB1dC5tYXAuZ2V0Wm9vbSgpKSxcbiAgICAgIHZpZXc6IGdldFBhZGRlZFZpZXdwb3J0KGlucHV0Lm1hcC5nZXRCb3VuZHMoKSwgaW5wdXQubWFwQ2FudmFzUHJvamVjdGlvbiwgdGhpcy52aWV3cG9ydFBhZGRpbmcpXG4gICAgfTtcbiAgICB2YXIgY2hhbmdlZCA9ICFlcXVhbCh0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgaWYgKCFlcXVhbChpbnB1dC5tYXJrZXJzLCB0aGlzLm1hcmtlcnMpKSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIC8vIFRPRE8gdXNlIHByb3h5IHRvIGF2b2lkIGNvcHk/XG4gICAgICB0aGlzLm1hcmtlcnMgPSBbLi4uaW5wdXQubWFya2Vyc107XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5tYXJrZXJzLm1hcChtYXJrZXIgPT4ge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpO1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbcG9zaXRpb24ubG5nKCksIHBvc2l0aW9uLmxhdCgpXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG1hcmtlclxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zdXBlckNsdXN0ZXIubG9hZChwb2ludHMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5jbHVzdGVycyA9IHRoaXMuY2x1c3RlcihpbnB1dCk7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjbHVzdGVyczogdGhpcy5jbHVzdGVycyxcbiAgICAgIGNoYW5nZWRcbiAgICB9O1xuICB9XG4gIGNsdXN0ZXIoX3JlZjEyKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcCxcbiAgICAgIG1hcENhbnZhc1Byb2plY3Rpb25cbiAgICB9ID0gX3JlZjEyO1xuICAgIC8qIHJlY2FsY3VsYXRlIG5ldyBzdGF0ZSBiZWNhdXNlIHdlIGNhbid0IHVzZSB0aGUgY2FjaGVkIHZlcnNpb24uICovXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgem9vbTogTWF0aC5yb3VuZChtYXAuZ2V0Wm9vbSgpKSxcbiAgICAgIHZpZXc6IGdldFBhZGRlZFZpZXdwb3J0KG1hcC5nZXRCb3VuZHMoKSwgbWFwQ2FudmFzUHJvamVjdGlvbiwgdGhpcy52aWV3cG9ydFBhZGRpbmcpXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5zdXBlckNsdXN0ZXIuZ2V0Q2x1c3RlcnMoc3RhdGUudmlldywgc3RhdGUuem9vbSkubWFwKGZlYXR1cmUgPT4gdGhpcy50cmFuc2Zvcm1DbHVzdGVyKGZlYXR1cmUpKTtcbiAgfVxuICB0cmFuc2Zvcm1DbHVzdGVyKF9yZWYxMykge1xuICAgIHZhciB7XG4gICAgICBnZW9tZXRyeToge1xuICAgICAgICBjb29yZGluYXRlczogW2xuZywgbGF0XVxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXNcbiAgICB9ID0gX3JlZjEzO1xuICAgIGlmIChwcm9wZXJ0aWVzLmNsdXN0ZXIpIHtcbiAgICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICAgIG1hcmtlcnM6IHRoaXMuc3VwZXJDbHVzdGVyLmdldExlYXZlcyhwcm9wZXJ0aWVzLmNsdXN0ZXJfaWQsIEluZmluaXR5KS5tYXAobGVhZiA9PiBsZWFmLnByb3BlcnRpZXMubWFya2VyKSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBsYXQsXG4gICAgICAgICAgbG5nXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbWFya2VyID0gcHJvcGVydGllcy5tYXJrZXI7XG4gICAgcmV0dXJuIG5ldyBDbHVzdGVyKHtcbiAgICAgIG1hcmtlcnM6IFttYXJrZXJdLFxuICAgICAgcG9zaXRpb246IE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcilcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRpc3RpY3Mgb24gYWxsIGNsdXN0ZXJzIGluIHRoZSBjdXJyZW50IHJlbmRlciBjeWNsZSBmb3IgdXNlIGluIHtAbGluayBSZW5kZXJlci5yZW5kZXJ9LlxuICovXG5jbGFzcyBDbHVzdGVyU3RhdHMge1xuICBjb25zdHJ1Y3RvcihtYXJrZXJzLCBjbHVzdGVycykge1xuICAgIHRoaXMubWFya2VycyA9IHtcbiAgICAgIHN1bTogbWFya2Vycy5sZW5ndGhcbiAgICB9O1xuICAgIHZhciBjbHVzdGVyTWFya2VyQ291bnRzID0gY2x1c3RlcnMubWFwKGEgPT4gYS5jb3VudCk7XG4gICAgdmFyIGNsdXN0ZXJNYXJrZXJTdW0gPSBjbHVzdGVyTWFya2VyQ291bnRzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIHRoaXMuY2x1c3RlcnMgPSB7XG4gICAgICBjb3VudDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgbWFya2Vyczoge1xuICAgICAgICBtZWFuOiBjbHVzdGVyTWFya2VyU3VtIC8gY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICBzdW06IGNsdXN0ZXJNYXJrZXJTdW0sXG4gICAgICAgIG1pbjogTWF0aC5taW4oLi4uY2x1c3Rlck1hcmtlckNvdW50cyksXG4gICAgICAgIG1heDogTWF0aC5tYXgoLi4uY2x1c3Rlck1hcmtlckNvdW50cylcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5jbGFzcyBEZWZhdWx0UmVuZGVyZXIge1xuICAvKipcbiAgICogVGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uIGZvciB0aGUgbGlicmFyeSB1c2VkIGJ5IHtAbGluayBNYXJrZXJDbHVzdGVyZXJ9LlxuICAgKlxuICAgKiBDdXJyZW50bHkgc2V0IHRvIHVzZSB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIC8vIGNoYW5nZSBjb2xvciBpZiB0aGlzIGNsdXN0ZXIgaGFzIG1vcmUgbWFya2VycyB0aGFuIHRoZSBtZWFuIGNsdXN0ZXJcbiAgICogY29uc3QgY29sb3IgPVxuICAgKiAgIGNvdW50ID4gTWF0aC5tYXgoMTAsIHN0YXRzLmNsdXN0ZXJzLm1hcmtlcnMubWVhbilcbiAgICogICAgID8gXCIjZmYwMDAwXCJcbiAgICogICAgIDogXCIjMDAwMGZmXCI7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBzdmcgdXJsIHdpdGggZmlsbCBjb2xvclxuICAgKiBjb25zdCBzdmcgPSB3aW5kb3cuYnRvYShgXG4gICAqIDxzdmcgZmlsbD1cIiR7Y29sb3J9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQwIDI0MFwiPlxuICAgKiAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuNlwiIHI9XCI3MFwiIC8+XG4gICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4zXCIgcj1cIjkwXCIgLz5cbiAgICogICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjJcIiByPVwiMTEwXCIgLz5cbiAgICogICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjFcIiByPVwiMTMwXCIgLz5cbiAgICogPC9zdmc+YCk7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBtYXJrZXIgdXNpbmcgc3ZnIGljb25cbiAgICogcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgKiAgIHBvc2l0aW9uLFxuICAgKiAgIGljb246IHtcbiAgICogICAgIHVybDogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtzdmd9YCxcbiAgICogICAgIHNjYWxlZFNpemU6IG5ldyBnb29nbGUubWFwcy5TaXplKDQ1LCA0NSksXG4gICAqICAgfSxcbiAgICogICBsYWJlbDoge1xuICAgKiAgICAgdGV4dDogU3RyaW5nKGNvdW50KSxcbiAgICogICAgIGNvbG9yOiBcInJnYmEoMjU1LDI1NSwyNTUsMC45KVwiLFxuICAgKiAgICAgZm9udFNpemU6IFwiMTJweFwiLFxuICAgKiAgIH0sXG4gICAqICAgLy8gYWRqdXN0IHpJbmRleCB0byBiZSBhYm92ZSBvdGhlciBtYXJrZXJzXG4gICAqICAgekluZGV4OiAxMDAwICsgY291bnQsXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIHJlbmRlcihfcmVmMTQsIHN0YXRzLCBtYXApIHtcbiAgICB2YXIge1xuICAgICAgY291bnQsXG4gICAgICBwb3NpdGlvblxuICAgIH0gPSBfcmVmMTQ7XG4gICAgLy8gY2hhbmdlIGNvbG9yIGlmIHRoaXMgY2x1c3RlciBoYXMgbW9yZSBtYXJrZXJzIHRoYW4gdGhlIG1lYW4gY2x1c3RlclxuICAgIHZhciBjb2xvciA9IGNvdW50ID4gTWF0aC5tYXgoMTAsIHN0YXRzLmNsdXN0ZXJzLm1hcmtlcnMubWVhbikgPyBcIiNmZjAwMDBcIiA6IFwiIzAwMDBmZlwiO1xuICAgIC8vIGNyZWF0ZSBzdmcgbGl0ZXJhbCB3aXRoIGZpbGwgY29sb3JcbiAgICB2YXIgc3ZnID0gXCI8c3ZnIGZpbGw9XFxcIlwiLmNvbmNhdChjb2xvciwgXCJcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCIgdmlld0JveD1cXFwiMCAwIDI0MCAyNDBcXFwiIHdpZHRoPVxcXCI1MFxcXCIgaGVpZ2h0PVxcXCI1MFxcXCI+XFxuPGNpcmNsZSBjeD1cXFwiMTIwXFxcIiBjeT1cXFwiMTIwXFxcIiBvcGFjaXR5PVxcXCIuNlxcXCIgcj1cXFwiNzBcXFwiIC8+XFxuPGNpcmNsZSBjeD1cXFwiMTIwXFxcIiBjeT1cXFwiMTIwXFxcIiBvcGFjaXR5PVxcXCIuM1xcXCIgcj1cXFwiOTBcXFwiIC8+XFxuPGNpcmNsZSBjeD1cXFwiMTIwXFxcIiBjeT1cXFwiMTIwXFxcIiBvcGFjaXR5PVxcXCIuMlxcXCIgcj1cXFwiMTEwXFxcIiAvPlxcbjx0ZXh0IHg9XFxcIjUwJVxcXCIgeT1cXFwiNTAlXFxcIiBzdHlsZT1cXFwiZmlsbDojZmZmXFxcIiB0ZXh0LWFuY2hvcj1cXFwibWlkZGxlXFxcIiBmb250LXNpemU9XFxcIjUwXFxcIiBkb21pbmFudC1iYXNlbGluZT1cXFwibWlkZGxlXFxcIiBmb250LWZhbWlseT1cXFwicm9ib3RvLGFyaWFsLHNhbnMtc2VyaWZcXFwiPlwiKS5jb25jYXQoY291bnQsIFwiPC90ZXh0Plxcbjwvc3ZnPlwiKTtcbiAgICB2YXIgdGl0bGUgPSBcIkNsdXN0ZXIgb2YgXCIuY29uY2F0KGNvdW50LCBcIiBtYXJrZXJzXCIpLFxuICAgICAgLy8gYWRqdXN0IHpJbmRleCB0byBiZSBhYm92ZSBvdGhlciBtYXJrZXJzXG4gICAgICB6SW5kZXggPSBOdW1iZXIoZ29vZ2xlLm1hcHMuTWFya2VyLk1BWF9aSU5ERVgpICsgY291bnQ7XG4gICAgaWYgKE1hcmtlclV0aWxzLmlzQWR2YW5jZWRNYXJrZXJBdmFpbGFibGUobWFwKSkge1xuICAgICAgLy8gY3JlYXRlIGNsdXN0ZXIgU1ZHIGVsZW1lbnRcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICB2YXIgc3ZnRWwgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2ZywgXCJpbWFnZS9zdmcreG1sXCIpLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHN2Z0VsLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwIDI1KVwiKTtcbiAgICAgIHZhciBfY2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICAgIG1hcCxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHpJbmRleCxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbnRlbnQ6IHN2Z0VsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KF9jbHVzdGVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHZhciBjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgekluZGV4LFxuICAgICAgdGl0bGUsXG4gICAgICBpY29uOiB7XG4gICAgICAgIHVybDogXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiLmNvbmNhdChidG9hKHN2ZykpLFxuICAgICAgICBhbmNob3I6IG5ldyBnb29nbGUubWFwcy5Qb2ludCgyNSwgMjUpXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcihjbHVzdGVyT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXh0ZW5kcyBhbiBvYmplY3QncyBwcm90b3R5cGUgYnkgYW5vdGhlcidzLlxuICpcbiAqIEBwYXJhbSB0eXBlMSBUaGUgVHlwZSB0byBiZSBleHRlbmRlZC5cbiAqIEBwYXJhbSB0eXBlMiBUaGUgVHlwZSB0byBleHRlbmQgd2l0aC5cbiAqIEBpZ25vcmVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGV4dGVuZCh0eXBlMSwgdHlwZTIpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0eXBlMi5wcm90b3R5cGUpIHtcbiAgICB0eXBlMS5wcm90b3R5cGVbcHJvcGVydHldID0gdHlwZTIucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgfVxufVxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIE92ZXJsYXlWaWV3U2FmZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIE1hcmtlckNsdXN0ZXJlciBpbXBsZW1lbnRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3IGludGVyZmFjZS4gV2UgdXNlIHRoZVxuICAgIC8vIGV4dGVuZCBmdW5jdGlvbiB0byBleHRlbmQgTWFya2VyQ2x1c3RlcmVyIHdpdGggZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXdcbiAgICAvLyBiZWNhdXNlIGl0IG1pZ2h0IG5vdCBhbHdheXMgYmUgYXZhaWxhYmxlIHdoZW4gdGhlIGNvZGUgaXMgZGVmaW5lZCBzbyB3ZVxuICAgIC8vIGxvb2sgZm9yIGl0IGF0IHRoZSBsYXN0IHBvc3NpYmxlIG1vbWVudC4gSWYgaXQgZG9lc24ndCBleGlzdCBub3cgdGhlblxuICAgIC8vIHRoZXJlIGlzIG5vIHBvaW50IGdvaW5nIGFoZWFkIDopXG4gICAgZXh0ZW5kKE92ZXJsYXlWaWV3U2FmZSwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBNYXJrZXJDbHVzdGVyZXJFdmVudHM7XG4oZnVuY3Rpb24gKE1hcmtlckNsdXN0ZXJlckV2ZW50cykge1xuICBNYXJrZXJDbHVzdGVyZXJFdmVudHNbXCJDTFVTVEVSSU5HX0JFR0lOXCJdID0gXCJjbHVzdGVyaW5nYmVnaW5cIjtcbiAgTWFya2VyQ2x1c3RlcmVyRXZlbnRzW1wiQ0xVU1RFUklOR19FTkRcIl0gPSBcImNsdXN0ZXJpbmdlbmRcIjtcbiAgTWFya2VyQ2x1c3RlcmVyRXZlbnRzW1wiQ0xVU1RFUl9DTElDS1wiXSA9IFwiY2xpY2tcIjtcbn0pKE1hcmtlckNsdXN0ZXJlckV2ZW50cyB8fCAoTWFya2VyQ2x1c3RlcmVyRXZlbnRzID0ge30pKTtcbnZhciBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyID0gKF8sIGNsdXN0ZXIsIG1hcCkgPT4ge1xuICBtYXAuZml0Qm91bmRzKGNsdXN0ZXIuYm91bmRzKTtcbn07XG4vKipcbiAqIE1hcmtlckNsdXN0ZXJlciBjcmVhdGVzIGFuZCBtYW5hZ2VzIHBlci16b29tLWxldmVsIGNsdXN0ZXJzIGZvciBsYXJnZSBhbW91bnRzXG4gKiBvZiBtYXJrZXJzLiBTZWUge0BsaW5rIE1hcmtlckNsdXN0ZXJlck9wdGlvbnN9IGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICovXG5jbGFzcyBNYXJrZXJDbHVzdGVyZXIgZXh0ZW5kcyBPdmVybGF5Vmlld1NhZmUge1xuICBjb25zdHJ1Y3RvcihfcmVmMTUpIHtcbiAgICB2YXIge1xuICAgICAgbWFwLFxuICAgICAgbWFya2VycyA9IFtdLFxuICAgICAgYWxnb3JpdGhtT3B0aW9ucyA9IHt9LFxuICAgICAgYWxnb3JpdGhtID0gbmV3IFN1cGVyQ2x1c3RlckFsZ29yaXRobShhbGdvcml0aG1PcHRpb25zKSxcbiAgICAgIHJlbmRlcmVyID0gbmV3IERlZmF1bHRSZW5kZXJlcigpLFxuICAgICAgb25DbHVzdGVyQ2xpY2sgPSBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyXG4gICAgfSA9IF9yZWYxNTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWFya2VycyA9IFsuLi5tYXJrZXJzXTtcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgdGhpcy5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMub25DbHVzdGVyQ2xpY2sgPSBvbkNsdXN0ZXJDbGljaztcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLnNldE1hcChtYXApO1xuICAgIH1cbiAgfVxuICBhZGRNYXJrZXIobWFya2VyLCBub0RyYXcpIHtcbiAgICBpZiAodGhpcy5tYXJrZXJzLmluY2x1ZGVzKG1hcmtlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICBpZiAoIW5vRHJhdykge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gIH1cbiAgYWRkTWFya2VycyhtYXJrZXJzLCBub0RyYXcpIHtcbiAgICBtYXJrZXJzLmZvckVhY2gobWFya2VyID0+IHtcbiAgICAgIHRoaXMuYWRkTWFya2VyKG1hcmtlciwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgaWYgKCFub0RyYXcpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU1hcmtlcihtYXJrZXIsIG5vRHJhdykge1xuICAgIHZhciBpbmRleCA9IHRoaXMubWFya2Vycy5pbmRleE9mKG1hcmtlcik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgLy8gTWFya2VyIGlzIG5vdCBpbiBvdXIgbGlzdCBvZiBtYXJrZXJzLCBzbyBkbyBub3RoaW5nOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBNYXJrZXJVdGlscy5zZXRNYXAobWFya2VyLCBudWxsKTtcbiAgICB0aGlzLm1hcmtlcnMuc3BsaWNlKGluZGV4LCAxKTsgLy8gUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgbGlzdCBvZiBtYW5hZ2VkIG1hcmtlcnNcbiAgICBpZiAoIW5vRHJhdykge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVtb3ZlTWFya2VycyhtYXJrZXJzLCBub0RyYXcpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIG1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgcmVtb3ZlZCA9IHRoaXMucmVtb3ZlTWFya2VyKG1hcmtlciwgdHJ1ZSkgfHwgcmVtb3ZlZDtcbiAgICB9KTtcbiAgICBpZiAocmVtb3ZlZCAmJiAhbm9EcmF3KSB7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICBjbGVhck1hcmtlcnMobm9EcmF3KSB7XG4gICAgdGhpcy5tYXJrZXJzLmxlbmd0aCA9IDA7XG4gICAgaWYgKCFub0RyYXcpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWNhbGN1bGF0ZXMgYW5kIGRyYXdzIGFsbCB0aGUgbWFya2VyIGNsdXN0ZXJzLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIGlmIChtYXAgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5NYXAgJiYgbWFwLmdldFByb2plY3Rpb24oKSkge1xuICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBNYXJrZXJDbHVzdGVyZXJFdmVudHMuQ0xVU1RFUklOR19CRUdJTiwgdGhpcyk7XG4gICAgICB2YXIge1xuICAgICAgICBjbHVzdGVycyxcbiAgICAgICAgY2hhbmdlZFxuICAgICAgfSA9IHRoaXMuYWxnb3JpdGhtLmNhbGN1bGF0ZSh7XG4gICAgICAgIG1hcmtlcnM6IHRoaXMubWFya2VycyxcbiAgICAgICAgbWFwLFxuICAgICAgICBtYXBDYW52YXNQcm9qZWN0aW9uOiB0aGlzLmdldFByb2plY3Rpb24oKVxuICAgICAgfSk7XG4gICAgICAvLyBBbGxvdyBhbGdvcml0aG1zIHRvIHJldHVybiBmbGFnIG9uIHdoZXRoZXIgdGhlIGNsdXN0ZXJzL21hcmtlcnMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgaWYgKGNoYW5nZWQgfHwgY2hhbmdlZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQWNjdW11bGF0ZSB0aGUgbWFya2VycyBvZiB0aGUgY2x1c3RlcnMgY29tcG9zZWQgb2YgYSBzaW5nbGUgbWFya2VyLlxuICAgICAgICAvLyBUaG9zZSBjbHVzdGVycyBkaXJlY3RseSB1c2UgdGhlIG1hcmtlci5cbiAgICAgICAgLy8gQ2x1c3RlcnMgd2l0aCBtb3JlIHRoYW4gb25lIG1hcmtlcnMgdXNlIGEgZ3JvdXAgbWFya2VyIGdlbmVyYXRlZCBieSBhIHJlbmRlcmVyLlxuICAgICAgICB2YXIgc2luZ2xlTWFya2VyID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKHZhciBjbHVzdGVyIG9mIGNsdXN0ZXJzKSB7XG4gICAgICAgICAgaWYgKGNsdXN0ZXIubWFya2Vycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgc2luZ2xlTWFya2VyLmFkZChjbHVzdGVyLm1hcmtlcnNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXBNYXJrZXJzID0gW107XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhlIGNsdXN0ZXJzIHRoYXQgYXJlIGN1cnJlbnRseSByZW5kZXJlZC5cbiAgICAgICAgZm9yICh2YXIgX2NsdXN0ZXIyIG9mIHRoaXMuY2x1c3RlcnMpIHtcbiAgICAgICAgICBpZiAoX2NsdXN0ZXIyLm1hcmtlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jbHVzdGVyMi5tYXJrZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoIXNpbmdsZU1hcmtlci5oYXMoX2NsdXN0ZXIyLm1hcmtlcikpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIG1hcmtlcjpcbiAgICAgICAgICAgICAgLy8gLSB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBiZWNhdXNlIGl0IGlzIGZyb20gYSBjbHVzdGVyIHdpdGggMSBtYXJrZXIsXG4gICAgICAgICAgICAgIC8vIC0gc2hvdWxkIG5vIG1vcmUgYmUgcmVuZGVyZWQgYXMgaXQgaXMgbm90IGluIHNpbmdsZU1hcmtlci5cbiAgICAgICAgICAgICAgTWFya2VyVXRpbHMuc2V0TWFwKF9jbHVzdGVyMi5tYXJrZXIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgcmVtb3ZhbCBvZiBvbGQgZ3JvdXAgbWFya2VycyB0byBhdm9pZCBmbGlja2VyaW5nLlxuICAgICAgICAgICAgZ3JvdXBNYXJrZXJzLnB1c2goX2NsdXN0ZXIyLm1hcmtlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBjbHVzdGVycztcbiAgICAgICAgdGhpcy5yZW5kZXJDbHVzdGVycygpO1xuICAgICAgICAvLyBEZWxheWVkIHJlbW92YWwgb2YgdGhlIG1hcmtlcnMgb2YgdGhlIGZvcm1lciBncm91cHMuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBncm91cE1hcmtlcnMuZm9yRWFjaChtYXJrZXIgPT4gTWFya2VyVXRpbHMuc2V0TWFwKG1hcmtlciwgbnVsbCkpKTtcbiAgICAgIH1cbiAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgTWFya2VyQ2x1c3RlcmVyRXZlbnRzLkNMVVNURVJJTkdfRU5ELCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25BZGQoKSB7XG4gICAgdGhpcy5pZGxlTGlzdGVuZXIgPSB0aGlzLmdldE1hcCgpLmFkZExpc3RlbmVyKFwiaWRsZVwiLCB0aGlzLnJlbmRlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG4gIG9uUmVtb3ZlKCkge1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuaWRsZUxpc3RlbmVyKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5tYXJrZXJzLmZvckVhY2gobWFya2VyID0+IE1hcmtlclV0aWxzLnNldE1hcChtYXJrZXIsIG51bGwpKTtcbiAgICB0aGlzLmNsdXN0ZXJzLmZvckVhY2goY2x1c3RlciA9PiBjbHVzdGVyLmRlbGV0ZSgpKTtcbiAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gIH1cbiAgcmVuZGVyQ2x1c3RlcnMoKSB7XG4gICAgLy8gR2VuZXJhdGUgc3RhdHMgdG8gcGFzcyB0byByZW5kZXJlcnMuXG4gICAgdmFyIHN0YXRzID0gbmV3IENsdXN0ZXJTdGF0cyh0aGlzLm1hcmtlcnMsIHRoaXMuY2x1c3RlcnMpO1xuICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgIHRoaXMuY2x1c3RlcnMuZm9yRWFjaChjbHVzdGVyID0+IHtcbiAgICAgIGlmIChjbHVzdGVyLm1hcmtlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNsdXN0ZXIubWFya2VyID0gY2x1c3Rlci5tYXJrZXJzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgdGhlIG1hcmtlciB0byByZXByZXNlbnQgdGhlIGdyb3VwLlxuICAgICAgICBjbHVzdGVyLm1hcmtlciA9IHRoaXMucmVuZGVyZXIucmVuZGVyKGNsdXN0ZXIsIHN0YXRzLCBtYXApO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGluZGl2aWR1YWwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgICAgIGNsdXN0ZXIubWFya2Vycy5mb3JFYWNoKG1hcmtlciA9PiBNYXJrZXJVdGlscy5zZXRNYXAobWFya2VyLCBudWxsKSk7XG4gICAgICAgIGlmICh0aGlzLm9uQ2x1c3RlckNsaWNrKSB7XG4gICAgICAgICAgY2x1c3Rlci5tYXJrZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgTWFya2VyQ2x1c3RlcmVyRXZlbnRzLkNMVVNURVJfQ0xJQ0ssIGNsdXN0ZXIpO1xuICAgICAgICAgICAgdGhpcy5vbkNsdXN0ZXJDbGljayhldmVudCwgY2x1c3RlciwgbWFwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTWFya2VyVXRpbHMuc2V0TWFwKGNsdXN0ZXIubWFya2VyLCBtYXApO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBpbmRleF9lc20gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQWJzdHJhY3RBbGdvcml0aG06IEFic3RyYWN0QWxnb3JpdGhtLFxuICBBYnN0cmFjdFZpZXdwb3J0QWxnb3JpdGhtOiBBYnN0cmFjdFZpZXdwb3J0QWxnb3JpdGhtLFxuICBDbHVzdGVyOiBDbHVzdGVyLFxuICBDbHVzdGVyU3RhdHM6IENsdXN0ZXJTdGF0cyxcbiAgRGVmYXVsdFJlbmRlcmVyOiBEZWZhdWx0UmVuZGVyZXIsXG4gIEdyaWRBbGdvcml0aG06IEdyaWRBbGdvcml0aG0sXG4gIE1hcmtlckNsdXN0ZXJlcjogTWFya2VyQ2x1c3RlcmVyLFxuICBnZXQgTWFya2VyQ2x1c3RlcmVyRXZlbnRzICgpIHsgcmV0dXJuIE1hcmtlckNsdXN0ZXJlckV2ZW50czsgfSxcbiAgTWFya2VyVXRpbHM6IE1hcmtlclV0aWxzLFxuICBOb29wQWxnb3JpdGhtOiBOb29wQWxnb3JpdGhtLFxuICBTdXBlckNsdXN0ZXJBbGdvcml0aG06IFN1cGVyQ2x1c3RlckFsZ29yaXRobSxcbiAgU3VwZXJDbHVzdGVyVmlld3BvcnRBbGdvcml0aG06IFN1cGVyQ2x1c3RlclZpZXdwb3J0QWxnb3JpdGhtLFxuICBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyOiBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyLFxuICBkaXN0YW5jZUJldHdlZW5Qb2ludHM6IGRpc3RhbmNlQmV0d2VlblBvaW50cyxcbiAgZXh0ZW5kQm91bmRzVG9QYWRkZWRWaWV3cG9ydDogZXh0ZW5kQm91bmRzVG9QYWRkZWRWaWV3cG9ydCxcbiAgZXh0ZW5kUGl4ZWxCb3VuZHM6IGV4dGVuZFBpeGVsQm91bmRzLFxuICBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydDogZmlsdGVyTWFya2Vyc1RvUGFkZGVkVmlld3BvcnQsXG4gIGdldFBhZGRlZFZpZXdwb3J0OiBnZXRQYWRkZWRWaWV3cG9ydCxcbiAgbm9vcDogbm9vcCQxLFxuICBwaXhlbEJvdW5kc1RvTGF0TG5nQm91bmRzOiBwaXhlbEJvdW5kc1RvTGF0TG5nQm91bmRzXG59KTtcblxuZnVuY3Rpb24gb3duS2V5cyRhKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkYShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJGEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJGEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIHVzZUdvb2dsZU1hcmtlckNsdXN0ZXJlcihvcHRpb25zKSB7XG4gIHZhciBtYXAgPSB1c2VHb29nbGVNYXAoKTtcbiAgdmFyIFttYXJrZXJDbHVzdGVyZXIsIHNldE1hcmtlckNsdXN0ZXJlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWFwICYmIG1hcmtlckNsdXN0ZXJlciA9PT0gbnVsbCkge1xuICAgICAgdmFyIG1hcmtlckNsdXN0ZXIgPSBuZXcgTWFya2VyQ2x1c3RlcmVyKF9vYmplY3RTcHJlYWQkYShfb2JqZWN0U3ByZWFkJGEoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBtYXBcbiAgICAgIH0pKTtcbiAgICAgIHNldE1hcmtlckNsdXN0ZXJlcihtYXJrZXJDbHVzdGVyKTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgcmV0dXJuIG1hcmtlckNsdXN0ZXJlcjtcbn1cbi8qKiBXcmFwcGVyIGFyb3VuZCBbQGdvb2dsZW1hcHMvbWFya2VyY2x1c3RlcmVyXShodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlbWFwcy9qcy1tYXJrZXJjbHVzdGVyZXIpXG4gKlxuICogQWNjZXB0cyB7QGxpbmsgIE1hcmtlckNsdXN0ZXJlck9wdGlvbnNTdWJzZXR9IHdoaWNoIGlzIGEgc3Vic2V0IG9mICB7QGxpbmsgTWFya2VyQ2x1c3RlcmVyT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gR29vZ2xlTWFya2VyQ2x1c3RlcmVyKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlbixcbiAgICBvcHRpb25zXG4gIH0gPSBfcmVmO1xuICB2YXIgbWFya2VyQ2x1c3RlcmVyID0gdXNlR29vZ2xlTWFya2VyQ2x1c3RlcmVyKG9wdGlvbnMpO1xuICByZXR1cm4gbWFya2VyQ2x1c3RlcmVyICE9PSBudWxsID8gY2hpbGRyZW4obWFya2VyQ2x1c3RlcmVyKSA6IG51bGw7XG59XG52YXIgR29vZ2xlTWFya2VyQ2x1c3RlcmVyJDEgPSBtZW1vKEdvb2dsZU1hcmtlckNsdXN0ZXJlcik7XG5cbnZhciBldmVudE1hcCRjID0ge1xuICBvbkNsb3NlQ2xpY2s6ICdjbG9zZWNsaWNrJyxcbiAgb25Db250ZW50Q2hhbmdlZDogJ2NvbnRlbnRfY2hhbmdlZCcsXG4gIG9uRG9tUmVhZHk6ICdkb21yZWFkeScsXG4gIG9uUG9zaXRpb25DaGFuZ2VkOiAncG9zaXRpb25fY2hhbmdlZCcsXG4gIG9uWmluZGV4Q2hhbmdlZDogJ3ppbmRleF9jaGFuZ2VkJ1xufTtcbnZhciB1cGRhdGVyTWFwJGMgPSB7XG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBwb3NpdGlvbihpbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gIH0sXG4gIHpJbmRleChpbnN0YW5jZSwgekluZGV4KSB7XG4gICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gIH1cbn07XG5mdW5jdGlvbiBJbmZvV2luZG93RnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgY2hpbGRyZW4sXG4gICAgYW5jaG9yLFxuICAgIG9wdGlvbnMsXG4gICAgcG9zaXRpb24sXG4gICAgekluZGV4LFxuICAgIG9uQ2xvc2VDbGljayxcbiAgICBvbkRvbVJlYWR5LFxuICAgIG9uQ29udGVudENoYW5nZWQsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQsXG4gICAgb25aaW5kZXhDaGFuZ2VkLFxuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjbG9zZWNsaWNrTGlzdGVuZXIsIHNldENsb3NlQ2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkb21yZWFkeWNsaWNrTGlzdGVuZXIsIHNldERvbVJlYWR5Q2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIsIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyLCBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3ppbmRleGNoYW5nZWRjbGlja0xpc3RlbmVyLCBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIGNvbnRhaW5lckVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5jbG9zZSgpO1xuICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCwgYW5jaG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zdGFuY2UuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbWFwLCBpbnN0YW5jZSwgYW5jaG9yXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sIFtwb3NpdGlvbl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfVxuICB9LCBbekluZGV4XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2xvc2VDbGljaykge1xuICAgICAgaWYgKGNsb3NlY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbG9zZWNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xvc2VDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xvc2VDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRvbVJlYWR5KSB7XG4gICAgICBpZiAoZG9tcmVhZHljbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICB9XG4gIH0sIFtvbkRvbVJlYWR5XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ29udGVudENoYW5nZWQpIHtcbiAgICAgIGlmIChjb250ZW50Y2hhbmdlZGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvbkNvbnRlbnRDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICBpZiAocG9zaXRpb25jaGFuZ2VkY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb3NpdGlvbl9jaGFuZ2VkJywgb25Qb3NpdGlvbkNoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvblBvc2l0aW9uQ2hhbmdlZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblppbmRleENoYW5nZWQpIHtcbiAgICAgIGlmICh6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgfVxuICB9LCBbb25aaW5kZXhDaGFuZ2VkXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIGluZm9XaW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyhvcHRpb25zKTtcbiAgICBzZXRJbnN0YW5jZShpbmZvV2luZG93KTtcbiAgICBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAob25DbG9zZUNsaWNrKSB7XG4gICAgICBzZXRDbG9zZUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uRG9tUmVhZHkpIHtcbiAgICAgIHNldERvbVJlYWR5Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvV2luZG93LCAnZG9tcmVhZHknLCBvbkRvbVJlYWR5KSk7XG4gICAgfVxuICAgIGlmIChvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICBzZXRDb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICB9XG4gICAgaWYgKG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3csICdwb3NpdGlvbl9jaGFuZ2VkJywgb25Qb3NpdGlvbkNoYW5nZWQpKTtcbiAgICB9XG4gICAgaWYgKG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ3ppbmRleF9jaGFuZ2VkJywgb25aaW5kZXhDaGFuZ2VkKSk7XG4gICAgfVxuICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgaW5mb1dpbmRvdy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfVxuICAgIGlmICh6SW5kZXgpIHtcbiAgICAgIGluZm9XaW5kb3cuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfVxuICAgIGlmIChhbmNob3IpIHtcbiAgICAgIGluZm9XaW5kb3cub3BlbihtYXAsIGFuY2hvcik7XG4gICAgfSBlbHNlIGlmIChpbmZvV2luZG93LmdldFBvc2l0aW9uKCkpIHtcbiAgICAgIGluZm9XaW5kb3cub3BlbihtYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yICh0eXBpY2FsbHkgcmVuZGVyIGl0IGluc2lkZSBhIDxNYXJrZXI+KSBvciBhIHBvc2l0aW9uIHByb3BzIGZvciA8SW5mb1dpbmRvdz4uXCIpO1xuICAgIH1cbiAgICBpZiAob25Mb2FkKSB7XG4gICAgICBvbkxvYWQoaW5mb1dpbmRvdyk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoY2xvc2VjbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsb3NlY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRlbnRjaGFuZ2VkY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoZG9tcmVhZHljbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRvbXJlYWR5Y2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb25jaGFuZ2VkY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmICh6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChpbmZvV2luZG93KTtcbiAgICAgIH1cbiAgICAgIGluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQgPyBjcmVhdGVQb3J0YWwoQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCkgOiBudWxsO1xufVxudmFyIEluZm9XaW5kb3dGID0gbWVtbyhJbmZvV2luZG93RnVuY3Rpb25hbCk7XG5jbGFzcyBJbmZvV2luZG93IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGFpbmVyRWxlbWVudFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBpbmZvV2luZG93OiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3BlblwiLCAoaW5mb1dpbmRvdywgYW5jaG9yKSA9PiB7XG4gICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIGluZm9XaW5kb3cub3Blbih0aGlzLmNvbnRleHQsIGFuY2hvcik7XG4gICAgICB9IGVsc2UgaWYgKGluZm9XaW5kb3cuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICBpbmZvV2luZG93Lm9wZW4odGhpcy5jb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgXCJZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBhbmNob3IgKHR5cGljYWxseSByZW5kZXIgaXQgaW5zaWRlIGEgPE1hcmtlcj4pIG9yIGEgcG9zaXRpb24gcHJvcHMgZm9yIDxJbmZvV2luZG93Pi5cIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0SW5mb1dpbmRvd0NhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwgJiYgdGhpcy5jb250YWluZXJFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuaW5mb1dpbmRvdy5zZXRDb250ZW50KHRoaXMuY29udGFpbmVyRWxlbWVudCk7XG4gICAgICAgIHRoaXMub3Blbih0aGlzLnN0YXRlLmluZm9XaW5kb3csIHRoaXMucHJvcHMuYW5jaG9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5pbmZvV2luZG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3codGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRjLFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiBpbmZvV2luZG93XG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmZvV2luZG93XG4gICAgICB9O1xuICAgIH0sIHRoaXMuc2V0SW5mb1dpbmRvd0NhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5mb1dpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYyxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGMsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5pbmZvV2luZG93XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5mb1dpbmRvdyAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuaW5mb1dpbmRvdyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPyBjcmVhdGVQb3J0YWwoQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSwgdGhpcy5jb250YWluZXJFbGVtZW50KSA6IG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShJbmZvV2luZG93LCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDkoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkOShPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkOShPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxudmFyIGV2ZW50TWFwJGIgPSB7XG4gIG9uQ2xpY2s6ICdjbGljaycsXG4gIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gIG9uRHJhZzogJ2RyYWcnLFxuICBvbkRyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgb25EcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIG9uTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgb25SaWdodENsaWNrOiAncmlnaHRjbGljaydcbn07XG52YXIgdXBkYXRlck1hcCRiID0ge1xuICBkcmFnZ2FibGUoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICB9LFxuICBlZGl0YWJsZShpbnN0YW5jZSwgZWRpdGFibGUpIHtcbiAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gIH0sXG4gIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBwYXRoKGluc3RhbmNlLCBwYXRoKSB7XG4gICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgfSxcbiAgdmlzaWJsZShpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gIH1cbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkMSA9IHt9O1xuZnVuY3Rpb24gUG9seWxpbmVGdW5jdGlvbmFsKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBvcHRpb25zLFxuICAgIGRyYWdnYWJsZSxcbiAgICBlZGl0YWJsZSxcbiAgICB2aXNpYmxlLFxuICAgIHBhdGgsXG4gICAgb25EYmxDbGljayxcbiAgICBvbkRyYWdFbmQsXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Nb3VzZU1vdmUsXG4gICAgb25Nb3VzZU91dCxcbiAgICBvbk1vdXNlT3ZlcixcbiAgICBvbk1vdXNlVXAsXG4gICAgb25SaWdodENsaWNrLFxuICAgIG9uQ2xpY2ssXG4gICAgb25EcmFnLFxuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnRcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkYmxjbGlja0xpc3RlbmVyLCBzZXREYmxjbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RyYWdlbmRMaXN0ZW5lciwgc2V0RHJhZ2VuZExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RyYWdzdGFydExpc3RlbmVyLCBzZXREcmFnc3RhcnRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZWRvd25MaXN0ZW5lciwgc2V0TW91c2Vkb3duTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2Vtb3ZlTGlzdGVuZXIsIHNldE1vdXNlbW92ZUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlb3V0TGlzdGVuZXIsIHNldE1vdXNlb3V0TGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdmVyTGlzdGVuZXIsIHNldE1vdXNlb3Zlckxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNldXBMaXN0ZW5lciwgc2V0TW91c2V1cExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3JpZ2h0Y2xpY2tMaXN0ZW5lciwgc2V0UmlnaHRjbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2NsaWNrTGlzdGVuZXIsIHNldENsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ0xpc3RlbmVyLCBzZXREcmFnTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9XG4gIH0sIFttYXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgZHJhZ2dhYmxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgZWRpdGFibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgcGF0aF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICB9XG4gIH0sIFtvbkRibENsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ0VuZCkge1xuICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgIH1cbiAgfSwgW29uRHJhZ0VuZF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWdTdGFydF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlRG93bl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlTW92ZSkge1xuICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlbW92ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlTW92ZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3V0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikpO1xuICAgIH1cbiAgfSwgW29uTW91c2VPdmVyXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VVcCkge1xuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VVcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICB9XG4gIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgfVxuICB9LCBbb25DbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWcpIHtcbiAgICAgIGlmIChkcmFnTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWddKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgcG9seWxpbmUgPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUoX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgb3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQxKSwge30sIHtcbiAgICAgIG1hcFxuICAgIH0pKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgcG9seWxpbmUuc2V0UGF0aChwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcG9seWxpbmUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBvbHlsaW5lLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwb2x5bGluZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9XG4gICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgIH1cbiAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlTW92ZSkge1xuICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU91dCkge1xuICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VVcCkge1xuICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgIH1cbiAgICBpZiAob25SaWdodENsaWNrKSB7XG4gICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkRyYWcpIHtcbiAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICB9XG4gICAgc2V0SW5zdGFuY2UocG9seWxpbmUpO1xuICAgIGlmIChvbkxvYWQpIHtcbiAgICAgIG9uTG9hZChwb2x5bGluZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICBvblVubW91bnQocG9seWxpbmUpO1xuICAgICAgfVxuICAgICAgcG9seWxpbmUuc2V0TWFwKG51bGwpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgUG9seWxpbmVGID0gbWVtbyhQb2x5bGluZUZ1bmN0aW9uYWwpO1xuY2xhc3MgUG9seWxpbmUgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBwb2x5bGluZTogbnVsbFxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFBvbHlsaW5lQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9seWxpbmUgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5wb2x5bGluZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHBvbHlsaW5lID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlsaW5lKF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXA6IHRoaXMuY29udGV4dFxuICAgIH0pKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYixcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRiLFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiBwb2x5bGluZVxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0UG9seWxpbmUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2x5bGluZVxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldFBvbHlsaW5lQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb2x5bGluZSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYixcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGIsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5wb2x5bGluZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvbHlsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5wb2x5bGluZSk7XG4gICAgfVxuICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICB0aGlzLnN0YXRlLnBvbHlsaW5lLnNldE1hcChudWxsKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShQb2x5bGluZSwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDgoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDgoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCRhID0ge1xuICBvbkNsaWNrOiAnY2xpY2snLFxuICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICBvbkRyYWc6ICdkcmFnJyxcbiAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICBvbk1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snXG59O1xudmFyIHVwZGF0ZXJNYXAkYSA9IHtcbiAgZHJhZ2dhYmxlKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgfSxcbiAgZWRpdGFibGUoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgaW5zdGFuY2Uuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICB9LFxuICBtYXAoaW5zdGFuY2UsIG1hcCkge1xuICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICB9LFxuICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfSxcbiAgcGF0aChpbnN0YW5jZSwgcGF0aCkge1xuICAgIGluc3RhbmNlLnNldFBhdGgocGF0aCk7XG4gIH0sXG4gIHBhdGhzKGluc3RhbmNlLCBwYXRocykge1xuICAgIGluc3RhbmNlLnNldFBhdGhzKHBhdGhzKTtcbiAgfSxcbiAgdmlzaWJsZShpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBQb2x5Z29uRnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgb3B0aW9ucyxcbiAgICBkcmFnZ2FibGUsXG4gICAgZWRpdGFibGUsXG4gICAgdmlzaWJsZSxcbiAgICBwYXRoLFxuICAgIHBhdGhzLFxuICAgIG9uRGJsQ2xpY2ssXG4gICAgb25EcmFnRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uTW91c2VEb3duLFxuICAgIG9uTW91c2VNb3ZlLFxuICAgIG9uTW91c2VPdXQsXG4gICAgb25Nb3VzZU92ZXIsXG4gICAgb25Nb3VzZVVwLFxuICAgIG9uUmlnaHRDbGljayxcbiAgICBvbkNsaWNrLFxuICAgIG9uRHJhZyxcbiAgICBvbkxvYWQsXG4gICAgb25Vbm1vdW50LFxuICAgIG9uRWRpdFxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBbaW5zdGFuY2UsIHNldEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RibGNsaWNrTGlzdGVuZXIsIHNldERibGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ2VuZExpc3RlbmVyLCBzZXREcmFnZW5kTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ3N0YXJ0TGlzdGVuZXIsIHNldERyYWdzdGFydExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlZG93bkxpc3RlbmVyLCBzZXRNb3VzZWRvd25MaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW1vdmVMaXN0ZW5lciwgc2V0TW91c2Vtb3ZlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdXRMaXN0ZW5lciwgc2V0TW91c2VvdXRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW92ZXJMaXN0ZW5lciwgc2V0TW91c2VvdmVyTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2V1cExpc3RlbmVyLCBzZXRNb3VzZXVwTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcmlnaHRjbGlja0xpc3RlbmVyLCBzZXRSaWdodGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2xpY2tMaXN0ZW5lciwgc2V0Q2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnTGlzdGVuZXIsIHNldERyYWdMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBlZGl0YWJsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIHZpc2libGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZS5zZXRQYXRoKHBhdGgpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBwYXRoXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXRocyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFBhdGhzKHBhdGhzKTtcbiAgICB9XG4gIH0sIFtpbnN0YW5jZSwgcGF0aHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgdHlwZW9mIG9uRGJsQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgIH1cbiAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLmdldFBhdGgoKSwgJ2luc2VydF9hdCcsICgpID0+IHtcbiAgICAgIG9uRWRpdCA9PT0gbnVsbCB8fCBvbkVkaXQgPT09IHZvaWQgMCB8fCBvbkVkaXQoaW5zdGFuY2UpO1xuICAgIH0pO1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLmdldFBhdGgoKSwgJ3NldF9hdCcsICgpID0+IHtcbiAgICAgIG9uRWRpdCA9PT0gbnVsbCB8fCBvbkVkaXQgPT09IHZvaWQgMCB8fCBvbkVkaXQoaW5zdGFuY2UpO1xuICAgIH0pO1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLmdldFBhdGgoKSwgJ3JlbW92ZV9hdCcsICgpID0+IHtcbiAgICAgIG9uRWRpdCA9PT0gbnVsbCB8fCBvbkVkaXQgPT09IHZvaWQgMCB8fCBvbkVkaXQoaW5zdGFuY2UpO1xuICAgIH0pO1xuICB9LCBbaW5zdGFuY2UsIG9uRWRpdF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiB0eXBlb2Ygb25EcmFnRW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgfVxuICB9LCBbb25EcmFnRW5kXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIHR5cGVvZiBvbkRyYWdTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWdTdGFydF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiB0eXBlb2Ygb25Nb3VzZURvd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZURvd25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgdHlwZW9mIG9uTW91c2VNb3ZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgIH1cbiAgfSwgW29uTW91c2VNb3ZlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIHR5cGVvZiBvbk1vdXNlT3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3V0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIHR5cGVvZiBvbk1vdXNlT3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiB0eXBlb2Ygb25Nb3VzZVVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNldXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZVVwXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIHR5cGVvZiBvblJpZ2h0Q2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICB9XG4gIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgdHlwZW9mIG9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgdHlwZW9mIG9uRHJhZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZycsIG9uRHJhZykpO1xuICAgIH1cbiAgfSwgW29uRHJhZ10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBwb2x5Z29uID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24oX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXBcbiAgICB9KSk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBvbHlnb24uc2V0UGF0aChwYXRoKTtcbiAgICB9XG4gICAgaWYgKHBhdGhzKSB7XG4gICAgICBwb2x5Z29uLnNldFBhdGhzKHBhdGhzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcG9seWdvbi5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcG9seWdvbi5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcG9seWdvbi5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9XG4gICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgIH1cbiAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICB9XG4gICAgaWYgKG9uUmlnaHRDbGljaykge1xuICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZykge1xuICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdkcmFnJywgb25EcmFnKSk7XG4gICAgfVxuICAgIHNldEluc3RhbmNlKHBvbHlnb24pO1xuICAgIGlmIChvbkxvYWQpIHtcbiAgICAgIG9uTG9hZChwb2x5Z29uKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChwb2x5Z29uKTtcbiAgICAgIH1cbiAgICAgIHBvbHlnb24uc2V0TWFwKG51bGwpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgUG9seWdvbkYgPSBtZW1vKFBvbHlnb25GdW5jdGlvbmFsKTtcbmNsYXNzIFBvbHlnb24gZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgcG9seWdvbk9wdGlvbnMgPSB0aGlzLnByb3BzLm9wdGlvbnMgfHwge307XG4gICAgdGhpcy5wb2x5Z29uID0gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24ocG9seWdvbk9wdGlvbnMpO1xuICAgIHRoaXMucG9seWdvbi5zZXRNYXAodGhpcy5jb250ZXh0KTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYSxcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRhLFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiB0aGlzLnBvbHlnb25cbiAgICB9KTtcbiAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMucG9seWdvbik7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5wb2x5Z29uKSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRhLFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYSxcbiAgICAgICAgcHJldlByb3BzLFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLnBvbHlnb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5wb2x5Z29uKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5wb2x5Z29uKTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIGlmICh0aGlzLnBvbHlnb24pIHtcbiAgICAgICAgdGhpcy5wb2x5Z29uLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoUG9seWdvbiwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDcoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDcoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCQ5ID0ge1xuICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gIG9uQ2xpY2s6ICdjbGljaycsXG4gIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gIG9uRHJhZzogJ2RyYWcnLFxuICBvbkRyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgb25EcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIG9uTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgb25SaWdodENsaWNrOiAncmlnaHRjbGljaydcbn07XG52YXIgdXBkYXRlck1hcCQ5ID0ge1xuICBib3VuZHMoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICB9LFxuICBkcmFnZ2FibGUoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICB9LFxuICBlZGl0YWJsZShpbnN0YW5jZSwgZWRpdGFibGUpIHtcbiAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gIH0sXG4gIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICB2aXNpYmxlKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFJlY3RhbmdsZUZ1bmN0aW9uYWwoX3JlZikge1xuICB2YXIge1xuICAgIG9wdGlvbnMsXG4gICAgYm91bmRzLFxuICAgIGRyYWdnYWJsZSxcbiAgICBlZGl0YWJsZSxcbiAgICB2aXNpYmxlLFxuICAgIG9uRGJsQ2xpY2ssXG4gICAgb25EcmFnRW5kLFxuICAgIG9uRHJhZ1N0YXJ0LFxuICAgIG9uTW91c2VEb3duLFxuICAgIG9uTW91c2VNb3ZlLFxuICAgIG9uTW91c2VPdXQsXG4gICAgb25Nb3VzZU92ZXIsXG4gICAgb25Nb3VzZVVwLFxuICAgIG9uUmlnaHRDbGljayxcbiAgICBvbkNsaWNrLFxuICAgIG9uRHJhZyxcbiAgICBvbkJvdW5kc0NoYW5nZWQsXG4gICAgb25Mb2FkLFxuICAgIG9uVW5tb3VudFxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBbaW5zdGFuY2UsIHNldEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RibGNsaWNrTGlzdGVuZXIsIHNldERibGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ2VuZExpc3RlbmVyLCBzZXREcmFnZW5kTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ3N0YXJ0TGlzdGVuZXIsIHNldERyYWdzdGFydExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlZG93bkxpc3RlbmVyLCBzZXRNb3VzZWRvd25MaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW1vdmVMaXN0ZW5lciwgc2V0TW91c2Vtb3ZlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdXRMaXN0ZW5lciwgc2V0TW91c2VvdXRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW92ZXJMaXN0ZW5lciwgc2V0TW91c2VvdmVyTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2V1cExpc3RlbmVyLCBzZXRNb3VzZXVwTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcmlnaHRDbGlja0xpc3RlbmVyLCBzZXRSaWdodENsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2xpY2tMaXN0ZW5lciwgc2V0Q2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnTGlzdGVuZXIsIHNldERyYWdMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtib3VuZHNDaGFuZ2VkTGlzdGVuZXIsIHNldEJvdW5kc0NoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBlZGl0YWJsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIHZpc2libGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGJvdW5kcyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBib3VuZHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EYmxDbGljaykge1xuICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25EYmxDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdFbmQpIHtcbiAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWdFbmRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgfVxuICB9LCBbb25EcmFnU3RhcnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZURvd25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU1vdmUpIHtcbiAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU91dF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3Zlcikge1xuICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlVXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICBpZiAocmlnaHRDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Q2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRSaWdodENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25SaWdodENsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2spIHtcbiAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnKSB7XG4gICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgfVxuICB9LCBbb25EcmFnXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQm91bmRzQ2hhbmdlZCkge1xuICAgICAgaWYgKGJvdW5kc0NoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihib3VuZHNDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Qm91bmRzQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnYm91bmRzX2NoYW5nZWQnLCBvbkJvdW5kc0NoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvbkJvdW5kc0NoYW5nZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgcmVjdGFuZ2xlID0gbmV3IGdvb2dsZS5tYXBzLlJlY3RhbmdsZShfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIG1hcFxuICAgIH0pKTtcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZWN0YW5nbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlY3RhbmdsZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVjdGFuZ2xlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJvdW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlY3RhbmdsZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkRyYWdFbmQpIHtcbiAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgfVxuICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgIHNldE1vdXNlbW92ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgfVxuICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgIHNldFJpZ2h0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgICBpZiAob25EcmFnKSB7XG4gICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZycsIG9uRHJhZykpO1xuICAgIH1cbiAgICBpZiAob25Cb3VuZHNDaGFuZ2VkKSB7XG4gICAgICBzZXRCb3VuZHNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnYm91bmRzX2NoYW5nZWQnLCBvbkJvdW5kc0NoYW5nZWQpKTtcbiAgICB9XG4gICAgc2V0SW5zdGFuY2UocmVjdGFuZ2xlKTtcbiAgICBpZiAob25Mb2FkKSB7XG4gICAgICBvbkxvYWQocmVjdGFuZ2xlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0Q2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodENsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGJvdW5kc0NoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChyZWN0YW5nbGUpO1xuICAgICAgfVxuICAgICAgcmVjdGFuZ2xlLnNldE1hcChudWxsKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufVxudmFyIFJlY3RhbmdsZUYgPSBtZW1vKFJlY3RhbmdsZUZ1bmN0aW9uYWwpO1xuY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgcmVjdGFuZ2xlOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0UmVjdGFuZ2xlQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucmVjdGFuZ2xlICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgcmVjdGFuZ2xlID0gbmV3IGdvb2dsZS5tYXBzLlJlY3RhbmdsZShfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCB0aGlzLnByb3BzLm9wdGlvbnMpLCB7fSwge1xuICAgICAgbWFwOiB0aGlzLmNvbnRleHRcbiAgICB9KSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDksXG4gICAgICBldmVudE1hcDogZXZlbnRNYXAkOSxcbiAgICAgIHByZXZQcm9wczoge30sXG4gICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBpbnN0YW5jZTogcmVjdGFuZ2xlXG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRSZWN0YW5nbGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWN0YW5nbGVcbiAgICAgIH07XG4gICAgfSwgdGhpcy5zZXRSZWN0YW5nbGVDYWxsYmFjayk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnN0YXRlLnJlY3RhbmdsZSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkOSxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDksXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5yZWN0YW5nbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5yZWN0YW5nbGUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnJlY3RhbmdsZSk7XG4gICAgICB9XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnN0YXRlLnJlY3RhbmdsZS5zZXRNYXAobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFJlY3RhbmdsZSwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNihlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDYoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDYoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCQ4ID0ge1xuICBvbkNlbnRlckNoYW5nZWQ6ICdjZW50ZXJfY2hhbmdlZCcsXG4gIG9uUmFkaXVzQ2hhbmdlZDogJ3JhZGl1c19jaGFuZ2VkJyxcbiAgb25DbGljazogJ2NsaWNrJyxcbiAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgb25EcmFnOiAnZHJhZycsXG4gIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICBvbkRyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJ1xufTtcbnZhciB1cGRhdGVyTWFwJDggPSB7XG4gIGNlbnRlcihpbnN0YW5jZSwgY2VudGVyKSB7XG4gICAgaW5zdGFuY2Uuc2V0Q2VudGVyKGNlbnRlcik7XG4gIH0sXG4gIGRyYWdnYWJsZShpbnN0YW5jZSwgZHJhZ2dhYmxlKSB7XG4gICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gIH0sXG4gIGVkaXRhYmxlKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgfSxcbiAgbWFwKGluc3RhbmNlLCBtYXApIHtcbiAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgfSxcbiAgb3B0aW9ucyhpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gIH0sXG4gIHJhZGl1cyhpbnN0YW5jZSwgcmFkaXVzKSB7XG4gICAgaW5zdGFuY2Uuc2V0UmFkaXVzKHJhZGl1cyk7XG4gIH0sXG4gIHZpc2libGUoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICB9XG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge307XG5mdW5jdGlvbiBDaXJjbGVGdW5jdGlvbmFsKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBvcHRpb25zLFxuICAgIGNlbnRlcixcbiAgICByYWRpdXMsXG4gICAgZHJhZ2dhYmxlLFxuICAgIGVkaXRhYmxlLFxuICAgIHZpc2libGUsXG4gICAgb25EYmxDbGljayxcbiAgICBvbkRyYWdFbmQsXG4gICAgb25EcmFnU3RhcnQsXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Nb3VzZU1vdmUsXG4gICAgb25Nb3VzZU91dCxcbiAgICBvbk1vdXNlT3ZlcixcbiAgICBvbk1vdXNlVXAsXG4gICAgb25SaWdodENsaWNrLFxuICAgIG9uQ2xpY2ssXG4gICAgb25EcmFnLFxuICAgIG9uQ2VudGVyQ2hhbmdlZCxcbiAgICBvblJhZGl1c0NoYW5nZWQsXG4gICAgb25Mb2FkLFxuICAgIG9uVW5tb3VudFxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBbaW5zdGFuY2UsIHNldEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RibGNsaWNrTGlzdGVuZXIsIHNldERibGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ2VuZExpc3RlbmVyLCBzZXREcmFnZW5kTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbZHJhZ3N0YXJ0TGlzdGVuZXIsIHNldERyYWdzdGFydExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlZG93bkxpc3RlbmVyLCBzZXRNb3VzZWRvd25MaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW1vdmVMaXN0ZW5lciwgc2V0TW91c2Vtb3ZlTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2VvdXRMaXN0ZW5lciwgc2V0TW91c2VvdXRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW92ZXJMaXN0ZW5lciwgc2V0TW91c2VvdmVyTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2V1cExpc3RlbmVyLCBzZXRNb3VzZXVwTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbcmlnaHRjbGlja0xpc3RlbmVyLCBzZXRSaWdodGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbY2xpY2tMaXN0ZW5lciwgc2V0Q2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtkcmFnTGlzdGVuZXIsIHNldERyYWdMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjZW50ZXJDaGFuZ2VkTGlzdGVuZXIsIHNldENlbnRlckNoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtyYWRpdXNDaGFuZ2VkTGlzdGVuZXIsIHNldFJhZGl1c0NoYW5nZWRMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBlZGl0YWJsZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIHZpc2libGVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCByYWRpdXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGNlbnRlciAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH1cbiAgfSwgW2luc3RhbmNlLCBjZW50ZXJdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EYmxDbGljaykge1xuICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25EYmxDbGlja10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdFbmQpIHtcbiAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICB9XG4gIH0sIFtvbkRyYWdFbmRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgfVxuICB9LCBbb25EcmFnU3RhcnRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZURvd25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU1vdmUpIHtcbiAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU91dF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3Zlcikge1xuICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlVXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25SaWdodENsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2spIHtcbiAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnKSB7XG4gICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgfVxuICB9LCBbb25EcmFnXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2VudGVyQ2hhbmdlZCkge1xuICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjZW50ZXJDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2VudGVyQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2VudGVyX2NoYW5nZWQnLCBvbkNlbnRlckNoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvbkNsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uUmFkaXVzQ2hhbmdlZCkge1xuICAgICAgaWYgKHJhZGl1c0NoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyYWRpdXNDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0UmFkaXVzQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmFkaXVzX2NoYW5nZWQnLCBvblJhZGl1c0NoYW5nZWQpKTtcbiAgICB9XG4gIH0sIFtvblJhZGl1c0NoYW5nZWRdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zKSwge30sIHtcbiAgICAgIG1hcFxuICAgIH0pKTtcbiAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNpcmNsZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjZW50ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjaXJjbGUuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJykge1xuICAgICAgY2lyY2xlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjaXJjbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNpcmNsZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY2lyY2xlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgIH1cbiAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICB9XG4gICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgIH1cbiAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlTW92ZSkge1xuICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgfVxuICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gICAgaWYgKG9uTW91c2VVcCkge1xuICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICB9XG4gICAgaWYgKG9uUmlnaHRDbGljaykge1xuICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICB9XG4gICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgfVxuICAgIGlmIChvbkRyYWcpIHtcbiAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdkcmFnJywgb25EcmFnKSk7XG4gICAgfVxuICAgIGlmIChvbkNlbnRlckNoYW5nZWQpIHtcbiAgICAgIHNldENlbnRlckNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdjZW50ZXJfY2hhbmdlZCcsIG9uQ2VudGVyQ2hhbmdlZCkpO1xuICAgIH1cbiAgICBpZiAob25SYWRpdXNDaGFuZ2VkKSB7XG4gICAgICBzZXRSYWRpdXNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAncmFkaXVzX2NoYW5nZWQnLCBvblJhZGl1c0NoYW5nZWQpKTtcbiAgICB9XG4gICAgc2V0SW5zdGFuY2UoY2lyY2xlKTtcbiAgICBpZiAob25Mb2FkKSB7XG4gICAgICBvbkxvYWQoY2lyY2xlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAoY2VudGVyQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAocmFkaXVzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJhZGl1c0NoYW5nZWRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIG9uVW5tb3VudChjaXJjbGUpO1xuICAgICAgfVxuICAgICAgY2lyY2xlLnNldE1hcChudWxsKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBudWxsO1xufVxudmFyIENpcmNsZUYgPSBtZW1vKENpcmNsZUZ1bmN0aW9uYWwpO1xuY2xhc3MgQ2lyY2xlIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgY2lyY2xlOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0Q2lyY2xlQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuY2lyY2xlICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuY2lyY2xlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCB0aGlzLnByb3BzLm9wdGlvbnMpLCB7fSwge1xuICAgICAgbWFwOiB0aGlzLmNvbnRleHRcbiAgICB9KSk7XG4gICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICBldmVudE1hcDogZXZlbnRNYXAkOCxcbiAgICAgIHByZXZQcm9wczoge30sXG4gICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBpbnN0YW5jZTogY2lyY2xlXG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRDaXJjbGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaXJjbGVcbiAgICAgIH07XG4gICAgfSwgdGhpcy5zZXRDaXJjbGVDYWxsYmFjayk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkOCxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDgsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5jaXJjbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5jaXJjbGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSRjaXJjbGU7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5jaXJjbGUpO1xuICAgICAgfVxuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgKF90aGlzJHN0YXRlJGNpcmNsZSA9IHRoaXMuc3RhdGUuY2lyY2xlKSA9PT0gbnVsbCB8fCBfdGhpcyRzdGF0ZSRjaXJjbGUgPT09IHZvaWQgMCB8fCBfdGhpcyRzdGF0ZSRjaXJjbGUuc2V0TWFwKG51bGwpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShDaXJjbGUsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIG93bktleXMkNShlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyQ1KE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyQ1KE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZXZlbnRNYXAkNyA9IHtcbiAgb25DbGljazogJ2NsaWNrJyxcbiAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgb25BZGRGZWF0dXJlOiAnYWRkZmVhdHVyZScsXG4gIG9uUmVtb3ZlRmVhdHVyZTogJ3JlbW92ZWZlYXR1cmUnLFxuICBvblJlbW92ZVByb3BlcnR5OiAncmVtb3ZlcHJvcGVydHknLFxuICBvblNldEdlb21ldHJ5OiAnc2V0Z2VvbWV0cnknLFxuICBvblNldFByb3BlcnR5OiAnc2V0cHJvcGVydHknXG59O1xudmFyIHVwZGF0ZXJNYXAkNyA9IHtcbiAgYWRkKGluc3RhbmNlLCBmZWF0dXJlKSB7XG4gICAgaW5zdGFuY2UuYWRkKGZlYXR1cmUpO1xuICB9LFxuICBhZGRnZW9qc29uKGluc3RhbmNlLCBnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgaW5zdGFuY2UuYWRkR2VvSnNvbihnZW9qc29uLCBvcHRpb25zKTtcbiAgfSxcbiAgY29udGFpbnMoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICBpbnN0YW5jZS5jb250YWlucyhmZWF0dXJlKTtcbiAgfSxcbiAgZm9yZWFjaChpbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICBpbnN0YW5jZS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgfSxcbiAgbG9hZGdlb2pzb24oaW5zdGFuY2UsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpbnN0YW5jZS5sb2FkR2VvSnNvbih1cmwsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgfSxcbiAgb3ZlcnJpZGVzdHlsZShpbnN0YW5jZSwgZmVhdHVyZSwgc3R5bGUpIHtcbiAgICBpbnN0YW5jZS5vdmVycmlkZVN0eWxlKGZlYXR1cmUsIHN0eWxlKTtcbiAgfSxcbiAgcmVtb3ZlKGluc3RhbmNlLCBmZWF0dXJlKSB7XG4gICAgaW5zdGFuY2UucmVtb3ZlKGZlYXR1cmUpO1xuICB9LFxuICByZXZlcnRzdHlsZShpbnN0YW5jZSwgZmVhdHVyZSkge1xuICAgIGluc3RhbmNlLnJldmVydFN0eWxlKGZlYXR1cmUpO1xuICB9LFxuICBjb250cm9scG9zaXRpb24oaW5zdGFuY2UsIGNvbnRyb2xQb3NpdGlvbikge1xuICAgIGluc3RhbmNlLnNldENvbnRyb2xQb3NpdGlvbihjb250cm9sUG9zaXRpb24pO1xuICB9LFxuICBjb250cm9scyhpbnN0YW5jZSwgY29udHJvbHMpIHtcbiAgICBpbnN0YW5jZS5zZXRDb250cm9scyhjb250cm9scyk7XG4gIH0sXG4gIGRyYXdpbmdtb2RlKGluc3RhbmNlLCBtb2RlKSB7XG4gICAgaW5zdGFuY2Uuc2V0RHJhd2luZ01vZGUobW9kZSk7XG4gIH0sXG4gIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gIH0sXG4gIHN0eWxlKGluc3RhbmNlLCBzdHlsZSkge1xuICAgIGluc3RhbmNlLnNldFN0eWxlKHN0eWxlKTtcbiAgfSxcbiAgdG9nZW9qc29uKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgIGluc3RhbmNlLnRvR2VvSnNvbihjYWxsYmFjayk7XG4gIH1cbn07XG5mdW5jdGlvbiBEYXRhRnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgb3B0aW9ucyxcbiAgICBvbkNsaWNrLFxuICAgIG9uRGJsQ2xpY2ssXG4gICAgb25Nb3VzZURvd24sXG4gICAgb25Nb3VzZU1vdmUsXG4gICAgb25Nb3VzZU91dCxcbiAgICBvbk1vdXNlT3ZlcixcbiAgICBvbk1vdXNlVXAsXG4gICAgb25SaWdodENsaWNrLFxuICAgIG9uQWRkRmVhdHVyZSxcbiAgICBvblJlbW92ZUZlYXR1cmUsXG4gICAgb25SZW1vdmVQcm9wZXJ0eSxcbiAgICBvblNldEdlb21ldHJ5LFxuICAgIG9uU2V0UHJvcGVydHksXG4gICAgb25Mb2FkLFxuICAgIG9uVW5tb3VudFxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBbaW5zdGFuY2UsIHNldEluc3RhbmNlXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2RibGNsaWNrTGlzdGVuZXIsIHNldERibGNsaWNrTGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbbW91c2Vkb3duTGlzdGVuZXIsIHNldE1vdXNlZG93bkxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlbW92ZUxpc3RlbmVyLCBzZXRNb3VzZW1vdmVMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZW91dExpc3RlbmVyLCBzZXRNb3VzZW91dExpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW21vdXNlb3Zlckxpc3RlbmVyLCBzZXRNb3VzZW92ZXJMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFttb3VzZXVwTGlzdGVuZXIsIHNldE1vdXNldXBMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtyaWdodGNsaWNrTGlzdGVuZXIsIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtjbGlja0xpc3RlbmVyLCBzZXRDbGlja0xpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW2FkZEZlYXR1cmVMaXN0ZW5lciwgc2V0QWRkRmVhdHVyZUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3JlbW92ZUZlYXR1cmVMaXN0ZW5lciwgc2V0UmVtb3ZlRmVhdHVyZUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICB2YXIgW3JlbW92ZVByb3BlcnR5TGlzdGVuZXIsIHNldFJlbW92ZVByb3BlcnR5TGlzdGVuZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHZhciBbc2V0R2VvbWV0cnlMaXN0ZW5lciwgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdmFyIFtzZXRQcm9wZXJ0eUxpc3RlbmVyLCBzZXRTZXRQcm9wZXJ0eUxpc3RlbmVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgIH1cbiAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZURvd25dKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU1vdmUpIHtcbiAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgfVxuICB9LCBbb25Nb3VzZU91dF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3Zlcikge1xuICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICB9XG4gIH0sIFtvbk1vdXNlVXBdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgfVxuICB9LCBbb25SaWdodENsaWNrXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2spIHtcbiAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgIH1cbiAgfSwgW29uQ2xpY2tdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25BZGRGZWF0dXJlKSB7XG4gICAgICBpZiAoYWRkRmVhdHVyZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRBZGRGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdhZGRmZWF0dXJlJywgb25BZGRGZWF0dXJlKSk7XG4gICAgfVxuICB9LCBbb25BZGRGZWF0dXJlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uUmVtb3ZlRmVhdHVyZSkge1xuICAgICAgaWYgKHJlbW92ZUZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZW1vdmVGZWF0dXJlTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0UmVtb3ZlRmVhdHVyZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmVtb3ZlZmVhdHVyZScsIG9uUmVtb3ZlRmVhdHVyZSkpO1xuICAgIH1cbiAgfSwgW29uUmVtb3ZlRmVhdHVyZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAmJiBvblJlbW92ZVByb3BlcnR5KSB7XG4gICAgICBpZiAocmVtb3ZlUHJvcGVydHlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZW1vdmVQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHNldFJlbW92ZVByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZW1vdmVwcm9wZXJ0eScsIG9uUmVtb3ZlUHJvcGVydHkpKTtcbiAgICB9XG4gIH0sIFtvblJlbW92ZVByb3BlcnR5XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluc3RhbmNlICYmIG9uU2V0R2VvbWV0cnkpIHtcbiAgICAgIGlmIChzZXRHZW9tZXRyeUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3NldGdlb21ldHJ5Jywgb25TZXRHZW9tZXRyeSkpO1xuICAgIH1cbiAgfSwgW29uU2V0R2VvbWV0cnldKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5zdGFuY2UgJiYgb25TZXRQcm9wZXJ0eSkge1xuICAgICAgaWYgKHNldFByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoc2V0UHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBzZXRTZXRQcm9wZXJ0eUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnc2V0cHJvcGVydHknLCBvblNldFByb3BlcnR5KSk7XG4gICAgfVxuICB9LCBbb25TZXRQcm9wZXJ0eV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICAgIHZhciBkYXRhID0gbmV3IGdvb2dsZS5tYXBzLkRhdGEoX29iamVjdFNwcmVhZCQ1KF9vYmplY3RTcHJlYWQkNSh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIG1hcFxuICAgICAgfSkpO1xuICAgICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICB9XG4gICAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICB9XG4gICAgICBpZiAob25Nb3VzZU91dCkge1xuICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICB9XG4gICAgICBpZiAob25SaWdodENsaWNrKSB7XG4gICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgfVxuICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICB9XG4gICAgICBpZiAob25BZGRGZWF0dXJlKSB7XG4gICAgICAgIHNldEFkZEZlYXR1cmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnYWRkZmVhdHVyZScsIG9uQWRkRmVhdHVyZSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9uUmVtb3ZlRmVhdHVyZSkge1xuICAgICAgICBzZXRSZW1vdmVGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JlbW92ZWZlYXR1cmUnLCBvblJlbW92ZUZlYXR1cmUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblJlbW92ZVByb3BlcnR5KSB7XG4gICAgICAgIHNldFJlbW92ZVByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JlbW92ZXByb3BlcnR5Jywgb25SZW1vdmVQcm9wZXJ0eSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9uU2V0R2VvbWV0cnkpIHtcbiAgICAgICAgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnc2V0Z2VvbWV0cnknLCBvblNldEdlb21ldHJ5KSk7XG4gICAgICB9XG4gICAgICBpZiAob25TZXRQcm9wZXJ0eSkge1xuICAgICAgICBzZXRTZXRQcm9wZXJ0eUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdzZXRwcm9wZXJ0eScsIG9uU2V0UHJvcGVydHkpKTtcbiAgICAgIH1cbiAgICAgIHNldEluc3RhbmNlKGRhdGEpO1xuICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICBvbkxvYWQoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZEZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZUZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlbW92ZUZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZVByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZW1vdmVQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0R2VvbWV0cnlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRQcm9wZXJ0eUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoc2V0UHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgRGF0YUYgPSBtZW1vKERhdGFGdW5jdGlvbmFsKTtcbmNsYXNzIERhdGEgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBkYXRhOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0RGF0YUNhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGF0YSA9IG5ldyBnb29nbGUubWFwcy5EYXRhKF9vYmplY3RTcHJlYWQkNShfb2JqZWN0U3ByZWFkJDUoe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHt9LCB7XG4gICAgICAgIG1hcDogdGhpcy5jb250ZXh0XG4gICAgICB9KSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ3LFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNyxcbiAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogZGF0YVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzLnNldERhdGFDYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ3LFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNyxcbiAgICAgICAgcHJldlByb3BzLFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kYXRhICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5kYXRhLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoRGF0YSwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDQoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDQoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCQ2ID0ge1xuICBvbkNsaWNrOiAnY2xpY2snLFxuICBvbkRlZmF1bHRWaWV3cG9ydENoYW5nZWQ6ICdkZWZhdWx0dmlld3BvcnRfY2hhbmdlZCcsXG4gIG9uU3RhdHVzQ2hhbmdlZDogJ3N0YXR1c19jaGFuZ2VkJ1xufTtcbnZhciB1cGRhdGVyTWFwJDYgPSB7XG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICB1cmwoaW5zdGFuY2UsIHVybCkge1xuICAgIGluc3RhbmNlLnNldFVybCh1cmwpO1xuICB9LFxuICB6SW5kZXgoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgIGluc3RhbmNlLnNldFpJbmRleCh6SW5kZXgpO1xuICB9XG59O1xuY2xhc3MgS21sTGF5ZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBrbWxMYXllcjogbnVsbFxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldEttbExheWVyQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5rbWxMYXllcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIGttbExheWVyID0gbmV3IGdvb2dsZS5tYXBzLkttbExheWVyKF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHt9LCB7XG4gICAgICBtYXA6IHRoaXMuY29udGV4dFxuICAgIH0pKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNixcbiAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ2LFxuICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiBrbWxMYXllclxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG1sTGF5ZXIoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrbWxMYXllclxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldEttbExheWVyQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5rbWxMYXllciAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNixcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDYsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5rbWxMYXllclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmttbExheWVyICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5rbWxMYXllcik7XG4gICAgICB9XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnN0YXRlLmttbExheWVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoS21sTGF5ZXIsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIGdldE9mZnNldE92ZXJyaWRlKGNvbnRhaW5lckVsZW1lbnQsIGdldFBpeGVsUG9zaXRpb25PZmZzZXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldChjb250YWluZXJFbGVtZW50Lm9mZnNldFdpZHRoLCBjb250YWluZXJFbGVtZW50Lm9mZnNldEhlaWdodCkgOiB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gY3JlYXRlTGF0TG5nKGluc3QsIFR5cGUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlKGluc3QubGF0LCBpbnN0LmxuZyk7XG59XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gY3JlYXRlTGF0TG5nQm91bmRzKGluc3QsIFR5cGUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoaW5zdC5uZS5sYXQsIGluc3QubmUubG5nKSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhpbnN0LnN3LmxhdCwgaW5zdC5zdy5sbmcpKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBlbnN1cmVPZlR5cGUoaW5zdCxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50eXBlLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZhY3Rvcnlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgcmV0dXJuIGluc3QgaW5zdGFuY2VvZiB0eXBlID8gaW5zdCA6IGZhY3RvcnkoaW5zdCwgdHlwZSk7XG59XG5mdW5jdGlvbiBlbnN1cmVPZlR5cGVCb3VuZHMoaW5zdCxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG50eXBlLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZhY3Rvcnlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgcmV0dXJuIGluc3QgaW5zdGFuY2VvZiB0eXBlID8gaW5zdCA6IGZhY3RvcnkoaW5zdCwgdHlwZSk7XG59XG5mdW5jdGlvbiBnZXRMYXlvdXRTdHlsZXNCeUJvdW5kcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIGJvdW5kcykge1xuICB2YXIgbmUgPSBtYXBDYW52YXNQcm9qZWN0aW9uICYmIG1hcENhbnZhc1Byb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcbiAgdmFyIHN3ID0gbWFwQ2FudmFzUHJvamVjdGlvbiAmJiBtYXBDYW52YXNQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSk7XG4gIGlmIChuZSAmJiBzdykge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBcIlwiLmNvbmNhdChzdy54ICsgb2Zmc2V0LngsIFwicHhcIiksXG4gICAgICB0b3A6IFwiXCIuY29uY2F0KG5lLnkgKyBvZmZzZXQueSwgXCJweFwiKSxcbiAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChuZS54IC0gc3cueCAtIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChzdy55IC0gbmUueSAtIG9mZnNldC55LCBcInB4XCIpXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6ICctOTk5OXB4JyxcbiAgICB0b3A6ICctOTk5OXB4J1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0TGF5b3V0U3R5bGVzQnlQb3NpdGlvbihtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIHBvc2l0aW9uKSB7XG4gIHZhciBwb2ludCA9IG1hcENhbnZhc1Byb2plY3Rpb24gJiYgbWFwQ2FudmFzUHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChwb3NpdGlvbik7XG4gIGlmIChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBwb2ludDtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogXCJcIi5jb25jYXQoeCArIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgdG9wOiBcIlwiLmNvbmNhdCh5ICsgb2Zmc2V0LnksIFwicHhcIilcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdDogJy05OTk5cHgnLFxuICAgIHRvcDogJy05OTk5cHgnXG4gIH07XG59XG5mdW5jdGlvbiBnZXRMYXlvdXRTdHlsZXMobWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCBib3VuZHMsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBib3VuZHMgIT09IHVuZGVmaW5lZCA/IGdldExheW91dFN0eWxlc0J5Qm91bmRzKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgZW5zdXJlT2ZUeXBlQm91bmRzKGJvdW5kcywgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzLCBjcmVhdGVMYXRMbmdCb3VuZHMpKSA6IGdldExheW91dFN0eWxlc0J5UG9zaXRpb24obWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCBlbnN1cmVPZlR5cGUocG9zaXRpb24sIGdvb2dsZS5tYXBzLkxhdExuZywgY3JlYXRlTGF0TG5nKSk7XG59XG5mdW5jdGlvbiBhcmVQb3NpdGlvbnNFcXVhbChjdXJyZW50UG9zaXRpb24sIHByZXZpb3VzUG9zaXRpb24pIHtcbiAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbi5sZWZ0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmxlZnQgJiYgY3VycmVudFBvc2l0aW9uLnRvcCA9PT0gcHJldmlvdXNQb3NpdGlvbi50b3AgJiYgY3VycmVudFBvc2l0aW9uLndpZHRoID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodCAmJiBjdXJyZW50UG9zaXRpb24uaGVpZ2h0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXkoY29udGFpbmVyLCBwYW5lLCBwb3NpdGlvbiwgYm91bmRzLCBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0KSB7XG4gIGNsYXNzIE92ZXJsYXkgZXh0ZW5kcyBnb29nbGUubWFwcy5PdmVybGF5VmlldyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBwYW5lLCBwb3NpdGlvbiwgYm91bmRzKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLnBhbmUgPSBwYW5lO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XG4gICAgfVxuICAgIG9uQWRkKCkge1xuICAgICAgdmFyIF90aGlzJGdldFBhbmVzO1xuICAgICAgdmFyIHBhbmUgPSAoX3RoaXMkZ2V0UGFuZXMgPSB0aGlzLmdldFBhbmVzKCkpID09PSBudWxsIHx8IF90aGlzJGdldFBhbmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRnZXRQYW5lc1t0aGlzLnBhbmVdO1xuICAgICAgcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgfHwgcGFuZS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICB2YXIgcHJvamVjdGlvbiA9IHRoaXMuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgdmFyIG9mZnNldCA9IF9vYmplY3RTcHJlYWQkMyh7fSwgdGhpcy5jb250YWluZXIgPyBnZXRPZmZzZXRPdmVycmlkZSh0aGlzLmNvbnRhaW5lciwgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCkgOiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0pO1xuICAgICAgdmFyIGxheW91dFN0eWxlcyA9IGdldExheW91dFN0eWxlcyhwcm9qZWN0aW9uLCBvZmZzZXQsIHRoaXMuYm91bmRzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgIGZvciAodmFyIFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhsYXlvdXRTdHlsZXMpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIG9uUmVtb3ZlKCkge1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgT3ZlcmxheShjb250YWluZXIsIHBhbmUsIHBvc2l0aW9uLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzJDIoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMkMihPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMkMihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gY29udmVydFRvTGF0TG5nU3RyaW5nKGxhdExuZ0xpa2UpIHtcbiAgaWYgKCFsYXRMbmdMaWtlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXRMbmcgPSBsYXRMbmdMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nID8gbGF0TG5nTGlrZSA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0TG5nTGlrZS5sYXQsIGxhdExuZ0xpa2UubG5nKTtcbiAgcmV0dXJuIGxhdExuZyArICcnO1xufVxuZnVuY3Rpb24gY29udmVydFRvTGF0TG5nQm91bmRzU3RyaW5nKGxhdExuZ0JvdW5kc0xpa2UpIHtcbiAgaWYgKCFsYXRMbmdCb3VuZHNMaWtlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXRMbmdCb3VuZHMgPSBsYXRMbmdCb3VuZHNMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzID8gbGF0TG5nQm91bmRzTGlrZSA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmdCb3VuZHNMaWtlLnNvdXRoLCBsYXRMbmdCb3VuZHNMaWtlLmVhc3QpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdExuZ0JvdW5kc0xpa2Uubm9ydGgsIGxhdExuZ0JvdW5kc0xpa2Uud2VzdCkpO1xuICByZXR1cm4gbGF0TG5nQm91bmRzICsgJyc7XG59XG52YXIgRkxPQVRfUEFORSA9IFwiZmxvYXRQYW5lXCI7XG52YXIgTUFQX1BBTkUgPSBcIm1hcFBhbmVcIjtcbnZhciBNQVJLRVJfTEFZRVIgPSBcIm1hcmtlckxheWVyXCI7XG52YXIgT1ZFUkxBWV9MQVlFUiA9IFwib3ZlcmxheUxheWVyXCI7XG52YXIgT1ZFUkxBWV9NT1VTRV9UQVJHRVQgPSBcIm92ZXJsYXlNb3VzZVRhcmdldFwiO1xuZnVuY3Rpb24gT3ZlcmxheVZpZXdGdW5jdGlvbmFsKF9yZWYpIHtcbiAgdmFyIHtcbiAgICBwb3NpdGlvbixcbiAgICBib3VuZHMsXG4gICAgbWFwUGFuZU5hbWUsXG4gICAgekluZGV4LFxuICAgIG9uTG9hZCxcbiAgICBvblVubW91bnQsXG4gICAgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCxcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gIHZhciBjb250YWluZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByZXR1cm4gZGl2O1xuICB9LCBbXSk7XG4gIHZhciBvdmVybGF5ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZU92ZXJsYXkoY29udGFpbmVyLCBtYXBQYW5lTmFtZSwgcG9zaXRpb24sIGJvdW5kcywgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCk7XG4gIH0sIFtjb250YWluZXIsIG1hcFBhbmVOYW1lLCBwb3NpdGlvbiwgYm91bmRzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgb25Mb2FkID09PSBudWxsIHx8IG9uTG9hZCA9PT0gdm9pZCAwIHx8IG9uTG9hZChvdmVybGF5KTtcbiAgICBvdmVybGF5ID09PSBudWxsIHx8IG92ZXJsYXkgPT09IHZvaWQgMCB8fCBvdmVybGF5LnNldE1hcChtYXApO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBvblVubW91bnQgPT09IG51bGwgfHwgb25Vbm1vdW50ID09PSB2b2lkIDAgfHwgb25Vbm1vdW50KG92ZXJsYXkpO1xuICAgICAgb3ZlcmxheSA9PT0gbnVsbCB8fCBvdmVybGF5ID09PSB2b2lkIDAgfHwgb3ZlcmxheS5zZXRNYXAobnVsbCk7XG4gICAgfTtcbiAgfSwgW21hcCwgb3ZlcmxheV0pO1xuICAvLyB0byBtb3ZlIHRoZSBjb250YWluZXIgdG8gdGhlIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gXCJcIi5jb25jYXQoekluZGV4KTtcbiAgfSwgW3pJbmRleCwgY29udGFpbmVyXSk7XG4gIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcik7XG59XG52YXIgT3ZlcmxheVZpZXdGID0gbWVtbyhPdmVybGF5Vmlld0Z1bmN0aW9uYWwpO1xuY2xhc3MgT3ZlcmxheVZpZXcgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgcGFuZUVsOiBudWxsLFxuICAgICAgY29udGFpbmVyU3R5bGU6IHtcbiAgICAgICAgLy8gc2V0IGluaXRpYWwgcG9zaXRpb25cbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1cGRhdGVQYW5lXCIsICgpID0+IHtcbiAgICAgIHZhciBtYXBQYW5lTmFtZSA9IHRoaXMucHJvcHMubWFwUGFuZU5hbWU7XG4gICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC8zLmV4cC9yZWZlcmVuY2UjTWFwUGFuZXNcbiAgICAgIHZhciBtYXBQYW5lcyA9IHRoaXMub3ZlcmxheVZpZXcuZ2V0UGFuZXMoKTtcbiAgICAgIGludmFyaWFudCghIW1hcFBhbmVOYW1lLCBcIk92ZXJsYXlWaWV3IHJlcXVpcmVzIHByb3BzLm1hcFBhbmVOYW1lIGJ1dCBnb3QgJXNcIiwgbWFwUGFuZU5hbWUpO1xuICAgICAgaWYgKG1hcFBhbmVzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHBhbmVFbDogbWFwUGFuZXNbbWFwUGFuZU5hbWVdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgcGFuZUVsOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uQWRkXCIsICgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvbkxvYWQsIF90aGlzJHByb3BzO1xuICAgICAgdGhpcy51cGRhdGVQYW5lKCk7XG4gICAgICAoX3RoaXMkcHJvcHMkb25Mb2FkID0gKF90aGlzJHByb3BzID0gdGhpcy5wcm9wcykub25Mb2FkKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyRvbkxvYWQgPT09IHZvaWQgMCB8fCBfdGhpcyRwcm9wcyRvbkxvYWQuY2FsbChfdGhpcyRwcm9wcywgdGhpcy5vdmVybGF5Vmlldyk7XG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib25Qb3NpdGlvbkVsZW1lbnRcIiwgKCkgPT4ge1xuICAgICAgdmFyIG1hcENhbnZhc1Byb2plY3Rpb24gPSB0aGlzLm92ZXJsYXlWaWV3LmdldFByb2plY3Rpb24oKTtcbiAgICAgIHZhciBvZmZzZXQgPSBfb2JqZWN0U3ByZWFkJDIoe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB0aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50ID8gZ2V0T2Zmc2V0T3ZlcnJpZGUodGhpcy5jb250YWluZXJSZWYuY3VycmVudCwgdGhpcy5wcm9wcy5nZXRQaXhlbFBvc2l0aW9uT2Zmc2V0KSA6IHt9KTtcbiAgICAgIHZhciBsYXlvdXRTdHlsZXMgPSBnZXRMYXlvdXRTdHlsZXMobWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCB0aGlzLnByb3BzLmJvdW5kcywgdGhpcy5wcm9wcy5wb3NpdGlvbik7XG4gICAgICBpZiAoIWFyZVBvc2l0aW9uc0VxdWFsKGxheW91dFN0eWxlcywge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgbGVmdDogdGhpcy5zdGF0ZS5jb250YWluZXJTdHlsZS5sZWZ0LFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdG9wOiB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLnRvcCxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpZHRoOiB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLndpZHRoLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLmhlaWdodFxuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIF9sYXlvdXRTdHlsZXMkdG9wLCBfbGF5b3V0U3R5bGVzJGxlZnQsIF9sYXlvdXRTdHlsZXMkd2lkdGgsIF9sYXlvdXRTdHlsZXMkaGVpZ2h0O1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBjb250YWluZXJTdHlsZToge1xuICAgICAgICAgICAgdG9wOiAoX2xheW91dFN0eWxlcyR0b3AgPSBsYXlvdXRTdHlsZXMudG9wKSAhPT0gbnVsbCAmJiBfbGF5b3V0U3R5bGVzJHRvcCAhPT0gdm9pZCAwID8gX2xheW91dFN0eWxlcyR0b3AgOiAwLFxuICAgICAgICAgICAgbGVmdDogKF9sYXlvdXRTdHlsZXMkbGVmdCA9IGxheW91dFN0eWxlcy5sZWZ0KSAhPT0gbnVsbCAmJiBfbGF5b3V0U3R5bGVzJGxlZnQgIT09IHZvaWQgMCA/IF9sYXlvdXRTdHlsZXMkbGVmdCA6IDAsXG4gICAgICAgICAgICB3aWR0aDogKF9sYXlvdXRTdHlsZXMkd2lkdGggPSBsYXlvdXRTdHlsZXMud2lkdGgpICE9PSBudWxsICYmIF9sYXlvdXRTdHlsZXMkd2lkdGggIT09IHZvaWQgMCA/IF9sYXlvdXRTdHlsZXMkd2lkdGggOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAoX2xheW91dFN0eWxlcyRoZWlnaHQgPSBsYXlvdXRTdHlsZXMuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfbGF5b3V0U3R5bGVzJGhlaWdodCAhPT0gdm9pZCAwID8gX2xheW91dFN0eWxlcyRoZWlnaHQgOiAwLFxuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vblBvc2l0aW9uRWxlbWVudCgpO1xuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9uUmVtb3ZlXCIsICgpID0+IHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblVubW91bnQsIF90aGlzJHByb3BzMjtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgcGFuZUVsOiBudWxsXG4gICAgICB9KSk7XG4gICAgICAoX3RoaXMkcHJvcHMkb25Vbm1vdW50ID0gKF90aGlzJHByb3BzMiA9IHRoaXMucHJvcHMpLm9uVW5tb3VudCkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMkb25Vbm1vdW50ID09PSB2b2lkIDAgfHwgX3RoaXMkcHJvcHMkb25Vbm1vdW50LmNhbGwoX3RoaXMkcHJvcHMyLCB0aGlzLm92ZXJsYXlWaWV3KTtcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgIC8vIFlvdSBtdXN0IGltcGxlbWVudCB0aHJlZSBtZXRob2RzOiBvbkFkZCgpLCBkcmF3KCksIGFuZCBvblJlbW92ZSgpLlxuICAgIHZhciBvdmVybGF5VmlldyA9IG5ldyBnb29nbGUubWFwcy5PdmVybGF5VmlldygpO1xuICAgIG92ZXJsYXlWaWV3Lm9uQWRkID0gdGhpcy5vbkFkZDtcbiAgICBvdmVybGF5Vmlldy5kcmF3ID0gdGhpcy5kcmF3O1xuICAgIG92ZXJsYXlWaWV3Lm9uUmVtb3ZlID0gdGhpcy5vblJlbW92ZTtcbiAgICB0aGlzLm92ZXJsYXlWaWV3ID0gb3ZlcmxheVZpZXc7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5vdmVybGF5Vmlldy5zZXRNYXAodGhpcy5jb250ZXh0KTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgdmFyIHByZXZQb3NpdGlvblN0cmluZyA9IGNvbnZlcnRUb0xhdExuZ1N0cmluZyhwcmV2UHJvcHMucG9zaXRpb24pO1xuICAgIHZhciBwb3NpdGlvblN0cmluZyA9IGNvbnZlcnRUb0xhdExuZ1N0cmluZyh0aGlzLnByb3BzLnBvc2l0aW9uKTtcbiAgICB2YXIgcHJldkJvdW5kc1N0cmluZyA9IGNvbnZlcnRUb0xhdExuZ0JvdW5kc1N0cmluZyhwcmV2UHJvcHMuYm91bmRzKTtcbiAgICB2YXIgYm91bmRzU3RyaW5nID0gY29udmVydFRvTGF0TG5nQm91bmRzU3RyaW5nKHRoaXMucHJvcHMuYm91bmRzKTtcbiAgICBpZiAocHJldlBvc2l0aW9uU3RyaW5nICE9PSBwb3NpdGlvblN0cmluZyB8fCBwcmV2Qm91bmRzU3RyaW5nICE9PSBib3VuZHNTdHJpbmcpIHtcbiAgICAgIHRoaXMub3ZlcmxheVZpZXcuZHJhdygpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLm1hcFBhbmVOYW1lICE9PSB0aGlzLnByb3BzLm1hcFBhbmVOYW1lKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhbmUoKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5vdmVybGF5Vmlldy5zZXRNYXAobnVsbCk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBwYW5lRWwgPSB0aGlzLnN0YXRlLnBhbmVFbDtcbiAgICBpZiAocGFuZUVsKSB7XG4gICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKGpzeChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogdGhpcy5jb250YWluZXJSZWYsXG4gICAgICAgIHN0eWxlOiB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLFxuICAgICAgICBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgICAgfSksIHBhbmVFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KE92ZXJsYXlWaWV3LCBcIkZMT0FUX1BBTkVcIiwgXCJmbG9hdFBhbmVcIik7XG5fZGVmaW5lUHJvcGVydHkoT3ZlcmxheVZpZXcsIFwiTUFQX1BBTkVcIiwgXCJtYXBQYW5lXCIpO1xuX2RlZmluZVByb3BlcnR5KE92ZXJsYXlWaWV3LCBcIk1BUktFUl9MQVlFUlwiLCBcIm1hcmtlckxheWVyXCIpO1xuX2RlZmluZVByb3BlcnR5KE92ZXJsYXlWaWV3LCBcIk9WRVJMQVlfTEFZRVJcIiwgXCJvdmVybGF5TGF5ZXJcIik7XG5fZGVmaW5lUHJvcGVydHkoT3ZlcmxheVZpZXcsIFwiT1ZFUkxBWV9NT1VTRV9UQVJHRVRcIiwgXCJvdmVybGF5TW91c2VUYXJnZXRcIik7XG5fZGVmaW5lUHJvcGVydHkoT3ZlcmxheVZpZXcsIFwiY29udGV4dFR5cGVcIiwgTWFwQ29udGV4dCk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQxKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMShlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzJDEoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzJDEoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbnZhciBldmVudE1hcCQ1ID0ge1xuICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICBvbkNsaWNrOiAnY2xpY2snXG59O1xudmFyIHVwZGF0ZXJNYXAkNSA9IHtcbiAgb3BhY2l0eShpbnN0YW5jZSwgb3BhY2l0eSkge1xuICAgIGluc3RhbmNlLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gIH1cbn07XG5mdW5jdGlvbiBHcm91bmRPdmVybGF5RnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgdXJsLFxuICAgIGJvdW5kcyxcbiAgICBvcHRpb25zLFxuICAgIHZpc2libGVcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgaW1hZ2VCb3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLnNvdXRoLCBib3VuZHMud2VzdCksIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLm5vcnRoLCBib3VuZHMuZWFzdCkpO1xuICB2YXIgZ3JvdW5kT3ZlcmxheSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuR3JvdW5kT3ZlcmxheSh1cmwsIGltYWdlQm91bmRzLCBvcHRpb25zKTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICBncm91bmRPdmVybGF5LnNldE1hcChtYXApO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJyAmJiBncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICBncm91bmRPdmVybGF5LnNldCgndXJsJywgdXJsKTtcbiAgICAgIGdyb3VuZE92ZXJsYXkuc2V0TWFwKG1hcCk7XG4gICAgfVxuICB9LCBbZ3JvdW5kT3ZlcmxheSwgdXJsXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICBncm91bmRPdmVybGF5LnNldE9wYWNpdHkodmlzaWJsZSA/IDEgOiAwKTtcbiAgICB9XG4gIH0sIFtncm91bmRPdmVybGF5LCB2aXNpYmxlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIG5ld0JvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuc291dGgsIGJvdW5kcy53ZXN0KSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMubm9ydGgsIGJvdW5kcy5lYXN0KSk7XG4gICAgaWYgKHR5cGVvZiBib3VuZHMgIT09ICd1bmRlZmluZWQnICYmIGdyb3VuZE92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgIGdyb3VuZE92ZXJsYXkuc2V0KCdib3VuZHMnLCBuZXdCb3VuZHMpO1xuICAgICAgZ3JvdW5kT3ZlcmxheS5zZXRNYXAobWFwKTtcbiAgICB9XG4gIH0sIFtncm91bmRPdmVybGF5LCBib3VuZHNdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgR3JvdW5kT3ZlcmxheUYgPSBtZW1vKEdyb3VuZE92ZXJsYXlGdW5jdGlvbmFsKTtcbmNsYXNzIEdyb3VuZE92ZXJsYXkgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBncm91bmRPdmVybGF5OiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0R3JvdW5kT3ZlcmxheUNhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQoISF0aGlzLnByb3BzLnVybCB8fCAhIXRoaXMucHJvcHMuYm91bmRzLCBcIkZvciBHcm91bmRPdmVybGF5LCB1cmwgYW5kIGJvdW5kcyBhcmUgcGFzc2VkIGluIHRvIGNvbnN0cnVjdG9yIGFuZCBhcmUgaW1tdXRhYmxlIGFmdGVyIGluc3RhbnRpYXRlZC4gVGhpcyBpcyB0aGUgYmVoYXZpb3Igb2YgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgdjMgKCBTZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dyb3VuZE92ZXJsYXkpIEhlbmNlLCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgdHdvIHByb3BzIHByb3ZpZGVkIGJ5IGByZWFjdC1nb29nbGUtbWFwcy1hcGlgLCB1cmwgYW5kIGJvdW5kcy4gSW4gc29tZSBjYXNlcywgeW91J2xsIG5lZWQgdGhlIEdyb3VuZE92ZXJsYXkgY29tcG9uZW50IHRvIHJlZmxlY3QgdGhlIGNoYW5nZXMgb2YgdXJsIGFuZCBib3VuZHMuIFlvdSBjYW4gbGV2ZXJhZ2UgdGhlIFJlYWN0J3Mga2V5IHByb3BlcnR5IHRvIHJlbW91bnQgdGhlIGNvbXBvbmVudC4gVHlwaWNhbGx5LCBqdXN0IGBrZXk9e3VybH1gIHdvdWxkIHNlcnZlIHlvdXIgbmVlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90b21jaGVudHcvcmVhY3QtZ29vZ2xlLW1hcHMvaXNzdWVzLzY1NVwiKTtcbiAgICB2YXIgZ3JvdW5kT3ZlcmxheSA9IG5ldyBnb29nbGUubWFwcy5Hcm91bmRPdmVybGF5KHRoaXMucHJvcHMudXJsLCB0aGlzLnByb3BzLmJvdW5kcywgX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgdGhpcy5wcm9wcy5vcHRpb25zKSwge30sIHtcbiAgICAgIG1hcDogdGhpcy5jb250ZXh0XG4gICAgfSkpO1xuICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ1LFxuICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDUsXG4gICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgaW5zdGFuY2U6IGdyb3VuZE92ZXJsYXlcbiAgICB9KTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldEdyb3VuZE92ZXJsYXkoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBncm91bmRPdmVybGF5XG4gICAgICB9O1xuICAgIH0sIHRoaXMuc2V0R3JvdW5kT3ZlcmxheUNhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNSxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDUsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkuc2V0TWFwKG51bGwpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbl9kZWZpbmVQcm9wZXJ0eShHcm91bmRPdmVybGF5LCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIG9uTG9hZDogbm9vcFxufSk7XG5fZGVmaW5lUHJvcGVydHkoR3JvdW5kT3ZlcmxheSwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG52YXIgZXZlbnRNYXAkNCA9IHt9O1xudmFyIHVwZGF0ZXJNYXAkNCA9IHtcbiAgZGF0YShpbnN0YW5jZSwgZGF0YSkge1xuICAgIGluc3RhbmNlLnNldERhdGEoZGF0YSk7XG4gIH0sXG4gIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG59O1xuZnVuY3Rpb24gSGVhdG1hcExheWVyRnVuY3Rpb25hbChfcmVmKSB7XG4gIHZhciB7XG4gICAgZGF0YSxcbiAgICBvbkxvYWQsXG4gICAgb25Vbm1vdW50LFxuICAgIG9wdGlvbnNcbiAgfSA9IF9yZWY7XG4gIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICB2YXIgW2luc3RhbmNlLCBzZXRJbnN0YW5jZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24pIHtcbiAgICAgIGludmFyaWFudCghIWdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24sICdEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1tcInZpc3VhbGl6YXRpb25cIl19IGluIHVzZUpzQXBpU2NyaXB0PyAlcycsIGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24pO1xuICAgIH1cbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGludmFyaWFudCghIWRhdGEsICdkYXRhIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIEhlYXRtYXBMYXllciAlcycsIGRhdGEpO1xuICB9LCBbZGF0YV0pO1xuICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfVxuICB9LCBbbWFwXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgaGVhdG1hcExheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uSGVhdG1hcExheWVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBkYXRhLFxuICAgICAgbWFwXG4gICAgfSkpO1xuICAgIHNldEluc3RhbmNlKGhlYXRtYXBMYXllcik7XG4gICAgaWYgKG9uTG9hZCkge1xuICAgICAgb25Mb2FkKGhlYXRtYXBMYXllcik7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG51bGw7XG59XG52YXIgSGVhdG1hcExheWVyRiA9IG1lbW8oSGVhdG1hcExheWVyRnVuY3Rpb25hbCk7XG5jbGFzcyBIZWF0bWFwTGF5ZXIgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBoZWF0bWFwTGF5ZXI6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRIZWF0bWFwTGF5ZXJDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGludmFyaWFudCghIWdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24sICdEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1tcInZpc3VhbGl6YXRpb25cIl19IHRvIDxMb2FkU2NyaXB0IC8+PyAlcycsIGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24pO1xuICAgIGludmFyaWFudCghIXRoaXMucHJvcHMuZGF0YSwgJ2RhdGEgcHJvcGVydHkgaXMgcmVxdWlyZWQgaW4gSGVhdG1hcExheWVyICVzJywgdGhpcy5wcm9wcy5kYXRhKTtcbiAgICB2YXIgaGVhdG1hcExheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uSGVhdG1hcExheWVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5wcm9wcy5vcHRpb25zKSwge30sIHtcbiAgICAgIGRhdGE6IHRoaXMucHJvcHMuZGF0YSxcbiAgICAgIG1hcDogdGhpcy5jb250ZXh0XG4gICAgfSkpO1xuICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ0LFxuICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDQsXG4gICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgaW5zdGFuY2U6IGhlYXRtYXBMYXllclxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0SGVhdG1hcExheWVyKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhdG1hcExheWVyXG4gICAgICB9O1xuICAgIH0sIHRoaXMuc2V0SGVhdG1hcExheWVyQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDQsXG4gICAgICBldmVudE1hcDogZXZlbnRNYXAkNCxcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmhlYXRtYXBMYXllclxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmhlYXRtYXBMYXllciAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuaGVhdG1hcExheWVyKTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIHRoaXMuc3RhdGUuaGVhdG1hcExheWVyLnNldE1hcChudWxsKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoSGVhdG1hcExheWVyLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG52YXIgZXZlbnRNYXAkMyA9IHtcbiAgb25DbG9zZUNsaWNrOiAnY2xvc2VjbGljaycsXG4gIG9uUGFub0NoYW5nZWQ6ICdwYW5vX2NoYW5nZWQnLFxuICBvblBvc2l0aW9uQ2hhbmdlZDogJ3Bvc2l0aW9uX2NoYW5nZWQnLFxuICBvblBvdkNoYW5nZWQ6ICdwb3ZfY2hhbmdlZCcsXG4gIG9uUmVzaXplOiAncmVzaXplJyxcbiAgb25TdGF0dXNDaGFuZ2VkOiAnc3RhdHVzX2NoYW5nZWQnLFxuICBvblZpc2libGVDaGFuZ2VkOiAndmlzaWJsZV9jaGFuZ2VkJyxcbiAgb25ab29tQ2hhbmdlZDogJ3pvb21fY2hhbmdlZCdcbn07XG52YXIgdXBkYXRlck1hcCQzID0ge1xuICByZWdpc3RlcihpbnN0YW5jZSwgcHJvdmlkZXIsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5yZWdpc3RlclBhbm9Qcm92aWRlcihwcm92aWRlciwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbmtzKGluc3RhbmNlLCBsaW5rcykge1xuICAgIGluc3RhbmNlLnNldExpbmtzKGxpbmtzKTtcbiAgfSxcbiAgbW90aW9uVHJhY2tpbmcoaW5zdGFuY2UsIG1vdGlvblRyYWNraW5nKSB7XG4gICAgaW5zdGFuY2Uuc2V0TW90aW9uVHJhY2tpbmcobW90aW9uVHJhY2tpbmcpO1xuICB9LFxuICBvcHRpb25zKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfSxcbiAgcGFubyhpbnN0YW5jZSwgcGFubykge1xuICAgIGluc3RhbmNlLnNldFBhbm8ocGFubyk7XG4gIH0sXG4gIHBvc2l0aW9uKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgfSxcbiAgcG92KGluc3RhbmNlLCBwb3YpIHtcbiAgICBpbnN0YW5jZS5zZXRQb3YocG92KTtcbiAgfSxcbiAgdmlzaWJsZShpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gIH0sXG4gIHpvb20oaW5zdGFuY2UsIHpvb20pIHtcbiAgICBpbnN0YW5jZS5zZXRab29tKHpvb20pO1xuICB9XG59O1xuY2xhc3MgU3RyZWV0Vmlld1Bhbm9yYW1hIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgc3RyZWV0Vmlld1Bhbm9yYW1hOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0U3RyZWV0Vmlld1Bhbm9yYW1hQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hICE9PSBudWxsICYmIHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMkY29udGV4dCRnZXRTdHJlLCBfdGhpcyRjb250ZXh0O1xuICAgIHZhciBzdHJlZXRWaWV3UGFub3JhbWEgPSAoX3RoaXMkY29udGV4dCRnZXRTdHJlID0gKF90aGlzJGNvbnRleHQgPSB0aGlzLmNvbnRleHQpID09PSBudWxsIHx8IF90aGlzJGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRleHQuZ2V0U3RyZWV0VmlldygpKSAhPT0gbnVsbCAmJiBfdGhpcyRjb250ZXh0JGdldFN0cmUgIT09IHZvaWQgMCA/IF90aGlzJGNvbnRleHQkZ2V0U3RyZSA6IG51bGw7XG4gICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDMsXG4gICAgICBldmVudE1hcDogZXZlbnRNYXAkMyxcbiAgICAgIHByZXZQcm9wczoge30sXG4gICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICBpbnN0YW5jZTogc3RyZWV0Vmlld1Bhbm9yYW1hXG4gICAgfSk7XG4gICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlZXRWaWV3UGFub3JhbWFcbiAgICAgIH07XG4gICAgfSwgdGhpcy5zZXRTdHJlZXRWaWV3UGFub3JhbWFDYWxsYmFjayk7XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMyxcbiAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDMsXG4gICAgICAgIHByZXZQcm9wcyxcbiAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEgIT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSk7XG4gICAgICB9XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYS5zZXRWaXNpYmxlKGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoU3RyZWV0Vmlld1Bhbm9yYW1hLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG5jbGFzcyBTdHJlZXRWaWV3U2VydmljZSBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIHN0cmVldFZpZXdTZXJ2aWNlOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0U3RyZWV0Vmlld1NlcnZpY2VDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgc3RyZWV0Vmlld1NlcnZpY2UgPSBuZXcgZ29vZ2xlLm1hcHMuU3RyZWV0Vmlld1NlcnZpY2UoKTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFN0cmVldFZpZXdTZXJ2aWNlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWV0Vmlld1NlcnZpY2VcbiAgICAgIH07XG4gICAgfSwgdGhpcy5zZXRTdHJlZXRWaWV3U2VydmljZUNhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuX2RlZmluZVByb3BlcnR5KFN0cmVldFZpZXdTZXJ2aWNlLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG5jbGFzcyBEaXJlY3Rpb25zU2VydmljZSBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIGRpcmVjdGlvbnNTZXJ2aWNlOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0RGlyZWN0aW9uc1NlcnZpY2VDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmRpcmVjdGlvbnNTZXJ2aWNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpbnZhcmlhbnQoISF0aGlzLnByb3BzLm9wdGlvbnMsICdEaXJlY3Rpb25zU2VydmljZSBleHBlY3RlZCBvcHRpb25zIG9iamVjdCBhcyBwYXJhbWV0ZXIsIGJ1dCBnb3QgJXMnLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgIHZhciBkaXJlY3Rpb25zU2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RGlyZWN0aW9uc1NlcnZpY2UoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXJlY3Rpb25zU2VydmljZVxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldERpcmVjdGlvbnNTZXJ2aWNlQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZS5yb3V0ZSh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIGV2ZW50TWFwJDIgPSB7XG4gIG9uRGlyZWN0aW9uc0NoYW5nZWQ6ICdkaXJlY3Rpb25zX2NoYW5nZWQnXG59O1xudmFyIHVwZGF0ZXJNYXAkMiA9IHtcbiAgZGlyZWN0aW9ucyhpbnN0YW5jZSwgZGlyZWN0aW9ucykge1xuICAgIGluc3RhbmNlLnNldERpcmVjdGlvbnMoZGlyZWN0aW9ucyk7XG4gIH0sXG4gIG1hcChpbnN0YW5jZSwgbWFwKSB7XG4gICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICBwYW5lbChpbnN0YW5jZSwgcGFuZWwpIHtcbiAgICBpbnN0YW5jZS5zZXRQYW5lbChwYW5lbCk7XG4gIH0sXG4gIHJvdXRlSW5kZXgoaW5zdGFuY2UsIHJvdXRlSW5kZXgpIHtcbiAgICBpbnN0YW5jZS5zZXRSb3V0ZUluZGV4KHJvdXRlSW5kZXgpO1xuICB9XG59O1xuY2xhc3MgRGlyZWN0aW9uc1JlbmRlcmVyIGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJlZEV2ZW50c1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdGVcIiwge1xuICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyOiBudWxsXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0RGlyZWN0aW9uc1JlbmRlcmVyQ2FsbGJhY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcCh0aGlzLmNvbnRleHQpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgZGlyZWN0aW9uc1JlbmRlcmVyID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZW5kZXJlcih0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQyLFxuICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDIsXG4gICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgaW5zdGFuY2U6IGRpcmVjdGlvbnNSZW5kZXJlclxuICAgIH0pO1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0RGlyZWN0aW9uc1JlbmRlcmVyKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyXG4gICAgICB9O1xuICAgIH0sIHRoaXMuc2V0RGlyZWN0aW9uc1JlbmRlcmVyQ2FsbGJhY2spO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDIsXG4gICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQyLFxuICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIpO1xuICAgICAgfVxuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoRGlyZWN0aW9uc1JlbmRlcmVyLCBcImNvbnRleHRUeXBlXCIsIE1hcENvbnRleHQpO1xuXG5jbGFzcyBEaXN0YW5jZU1hdHJpeFNlcnZpY2UgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBkaXN0YW5jZU1hdHJpeFNlcnZpY2U6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXREaXN0YW5jZU1hdHJpeFNlcnZpY2VDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGludmFyaWFudCghIXRoaXMucHJvcHMub3B0aW9ucywgJ0Rpc3RhbmNlTWF0cml4U2VydmljZSBleHBlY3RlZCBvcHRpb25zIG9iamVjdCBhcyBwYXJhbWV0ZXIsIGJ1dCBnbyAlcycsIHRoaXMucHJvcHMub3B0aW9ucyk7XG4gICAgdmFyIGRpc3RhbmNlTWF0cml4U2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXN0YW5jZU1hdHJpeFNlcnZpY2UoKTtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERpc3RhbmNlTWF0cml4U2VydmljZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZVxuICAgICAgfTtcbiAgICB9LCB0aGlzLnNldERpc3RhbmNlTWF0cml4U2VydmljZUNhbGxiYWNrKTtcbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlLmRpc3RhbmNlTWF0cml4U2VydmljZS5nZXREaXN0YW5jZU1hdHJpeCh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBldmVudE1hcCQxID0ge1xuICBvblBsYWNlc0NoYW5nZWQ6ICdwbGFjZXNfY2hhbmdlZCdcbn07XG52YXIgdXBkYXRlck1hcCQxID0ge1xuICBib3VuZHMoaW5zdGFuY2UsIGJvdW5kcykge1xuICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICB9XG59O1xuY2xhc3MgU3RhbmRhbG9uZVNlYXJjaEJveCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlZ2lzdGVyZWRFdmVudHNcIiwgW10pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRhaW5lckVsZW1lbnRcIiwgY3JlYXRlUmVmKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXRlXCIsIHtcbiAgICAgIHNlYXJjaEJveDogbnVsbFxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFNlYXJjaEJveENhbGxiYWNrXCIsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnNlYXJjaEJveCAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICB0aGlzLnByb3BzLm9uTG9hZCh0aGlzLnN0YXRlLnNlYXJjaEJveCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaW52YXJpYW50KCEhZ29vZ2xlLm1hcHMucGxhY2VzLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBsaWJyYXJpZXM9e1tcInBsYWNlc1wiXX0gcHJvcCB0byA8TG9hZFNjcmlwdCAvPiBjb21wb25lbnQgJXMnLCBnb29nbGUubWFwcy5wbGFjZXMpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lckVsZW1lbnQgIT09IG51bGwgJiYgdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuY29udGFpbmVyRWxlbWVudC5jdXJyZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHNlYXJjaEJveCA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuU2VhcmNoQm94KGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDEsXG4gICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgaW5zdGFuY2U6IHNlYXJjaEJveFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRTZWFyY2hCb3goKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlYXJjaEJveFxuICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0U2VhcmNoQm94Q2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsKSB7XG4gICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQxLFxuICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMSxcbiAgICAgICAgcHJldlByb3BzLFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnNlYXJjaEJveFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnNlYXJjaEJveCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuc2VhcmNoQm94KTtcbiAgICAgIH1cbiAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiBqc3goXCJkaXZcIiwge1xuICAgICAgcmVmOiB0aGlzLmNvbnRhaW5lckVsZW1lbnQsXG4gICAgICBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgIH0pO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoU3RhbmRhbG9uZVNlYXJjaEJveCwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxudmFyIGV2ZW50TWFwID0ge1xuICBvblBsYWNlQ2hhbmdlZDogJ3BsYWNlX2NoYW5nZWQnXG59O1xudmFyIHVwZGF0ZXJNYXAgPSB7XG4gIGJvdW5kcyhpbnN0YW5jZSwgYm91bmRzKSB7XG4gICAgaW5zdGFuY2Uuc2V0Qm91bmRzKGJvdW5kcyk7XG4gIH0sXG4gIHJlc3RyaWN0aW9ucyhpbnN0YW5jZSwgcmVzdHJpY3Rpb25zKSB7XG4gICAgaW5zdGFuY2Uuc2V0Q29tcG9uZW50UmVzdHJpY3Rpb25zKHJlc3RyaWN0aW9ucyk7XG4gIH0sXG4gIGZpZWxkcyhpbnN0YW5jZSwgZmllbGRzKSB7XG4gICAgaW5zdGFuY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gIH0sXG4gIG9wdGlvbnMoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9LFxuICB0eXBlcyhpbnN0YW5jZSwgdHlwZXMpIHtcbiAgICBpbnN0YW5jZS5zZXRUeXBlcyh0eXBlcyk7XG4gIH1cbn07XG5jbGFzcyBBdXRvY29tcGxldGUgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZWdpc3RlcmVkRXZlbnRzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250YWluZXJFbGVtZW50XCIsIGNyZWF0ZVJlZigpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBhdXRvY29tcGxldGU6IG51bGxcbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRBdXRvY29tcGxldGVDYWxsYmFja1wiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5hdXRvY29tcGxldGUgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQodGhpcy5zdGF0ZS5hdXRvY29tcGxldGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHZhciBfdGhpcyRjb250YWluZXJFbGVtZW47XG4gICAgaW52YXJpYW50KCEhZ29vZ2xlLm1hcHMucGxhY2VzLCAnWW91IG5lZWQgdG8gcHJvdmlkZSBsaWJyYXJpZXM9e1tcInBsYWNlc1wiXX0gcHJvcCB0byA8TG9hZFNjcmlwdCAvPiBjb21wb25lbnQgJXMnLCBnb29nbGUubWFwcy5wbGFjZXMpO1xuICAgIC8vIFRPRE86IHdoeSBjdXJyZW50IGNvdWxkIGJlIGVxdWFsIG51bGw/XG4gICAgdmFyIGlucHV0ID0gKF90aGlzJGNvbnRhaW5lckVsZW1lbiA9IHRoaXMuY29udGFpbmVyRWxlbWVudC5jdXJyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRjb250YWluZXJFbGVtZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGNvbnRhaW5lckVsZW1lbi5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgdmFyIGF1dG9jb21wbGV0ZSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgIHVwZGF0ZXJNYXAsXG4gICAgICAgIGV2ZW50TWFwLFxuICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgIGluc3RhbmNlOiBhdXRvY29tcGxldGVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXV0b2NvbXBsZXRlXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzLnNldEF1dG9jb21wbGV0ZUNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgIHVwZGF0ZXJNYXAsXG4gICAgICBldmVudE1hcCxcbiAgICAgIHByZXZQcm9wcyxcbiAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZVxuICAgIH0pO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIGpzeChcImRpdlwiLCB7XG4gICAgICByZWY6IHRoaXMuY29udGFpbmVyRWxlbWVudCxcbiAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgIH0pO1xuICB9XG59XG5fZGVmaW5lUHJvcGVydHkoQXV0b2NvbXBsZXRlLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gIGNsYXNzTmFtZTogJydcbn0pO1xuX2RlZmluZVByb3BlcnR5KEF1dG9jb21wbGV0ZSwgXCJjb250ZXh0VHlwZVwiLCBNYXBDb250ZXh0KTtcblxuZXhwb3J0IHsgQXV0b2NvbXBsZXRlLCBCaWN5Y2xpbmdMYXllciwgQmljeWNsaW5nTGF5ZXJGLCBDaXJjbGUsIENpcmNsZUYsIERhdGEsIERhdGFGLCBEaXJlY3Rpb25zUmVuZGVyZXIsIERpcmVjdGlvbnNTZXJ2aWNlLCBEaXN0YW5jZU1hdHJpeFNlcnZpY2UsIERyYXdpbmdNYW5hZ2VyLCBEcmF3aW5nTWFuYWdlckYsIEZMT0FUX1BBTkUsIEdvb2dsZU1hcCwgaW5kZXhfZXNtIGFzIEdvb2dsZU1hcHNNYXJrZXJDbHVzdGVyZXIsIEdvb2dsZU1hcmtlckNsdXN0ZXJlciQxIGFzIEdvb2dsZU1hcmtlckNsdXN0ZXJlciwgR3JvdW5kT3ZlcmxheSwgR3JvdW5kT3ZlcmxheUYsIEhlYXRtYXBMYXllciwgSGVhdG1hcExheWVyRiwgSW5mb0JveENvbXBvbmVudCBhcyBJbmZvQm94LCBJbmZvQm94RiwgSW5mb1dpbmRvdywgSW5mb1dpbmRvd0YsIEttbExheWVyLCBMb2FkU2NyaXB0LCBMb2FkU2NyaXB0TmV4dCQxIGFzIExvYWRTY3JpcHROZXh0LCBNQVBfUEFORSwgTUFSS0VSX0xBWUVSLCBNYXBDb250ZXh0LCBNYXJrZXIsIENsdXN0ZXJlckNvbXBvbmVudCBhcyBNYXJrZXJDbHVzdGVyZXIsIE1hcmtlckNsdXN0ZXJlckYsIE1hcmtlckYsIE9WRVJMQVlfTEFZRVIsIE9WRVJMQVlfTU9VU0VfVEFSR0VULCBPdmVybGF5VmlldywgT3ZlcmxheVZpZXdGLCBQb2x5Z29uLCBQb2x5Z29uRiwgUG9seWxpbmUsIFBvbHlsaW5lRiwgUmVjdGFuZ2xlLCBSZWN0YW5nbGVGLCBTdGFuZGFsb25lU2VhcmNoQm94LCBTdHJlZXRWaWV3UGFub3JhbWEsIFN0cmVldFZpZXdTZXJ2aWNlLCBUcmFmZmljTGF5ZXIsIFRyYWZmaWNMYXllckYsIFRyYW5zaXRMYXllciwgVHJhbnNpdExheWVyRiwgdXNlR29vZ2xlTWFwLCB1c2VKc0FwaUxvYWRlciwgdXNlTG9hZFNjcmlwdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-google-maps/api/dist/esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/NWZlMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxhQUFhLE9BQU8sY0FBYyxlQUFlLHFCQUFxQix1REFBdUQseUNBQXlDLGtDQUFrQyxVQUFVLE9BQU8sZ0JBQWdCLE9BQU8sV0FBVyxPQUFPLE9BQU8sb0JBQW9CLGNBQWMsZ0NBQWdDLGlEQUFpRCxHQUFHLDBCQUEwQixnQkFBZ0IsMkJBQTJCLG9CQUFvQixTQUFTLGdCQUFnQixhQUFhLEVBQUUsR0FBRyxjQUFjLGNBQWMsY0FBYyxjQUFjLGdCQUFnQixlQUFlLGNBQWMsRUFBRSxLQUFLLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxHQUFHLElBQUksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsY0FBYyxFQUFFLEVBQUUsRUFBRSxHQUFHLGNBQWMsR0FBRyxJQUFJLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLFdBQVcsRUFBRSxJQUFJLFlBQVksU0FBUyx3TUFBd00sU0FBUyx1QkFBdUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsR0FBRyxJQUFJLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSx1QkFBdUIsRUFBRSxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMkJBQTJCLEdBQUcsSUFBSSxNQUFNLEVBQUUsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsZ0JBQWdCLFNBQVMseUxBQXlMLGFBQWEsRUFBRSw4RUFBOEUsV0FBVyxzRUFBc0UscURBQXFELHlDQUF5QyxnR0FBZ0csNEVBQTRFLHVDQUF1QyxtM0JBQW0zQixPQUFPLEtBQUssMENBQTBDLE9BQU8sR0FBRyxNQUFNLG1DQUFtQyxNQUFNLGtDQUFrQyxNQUFNLGtDQUFrQyxNQUFNLGlDQUFpQyxjQUFjLHNCQUFzQixlQUFlLGVBQWUsY0FBYyxNQUFNLHlHQUF5RyxHQUFHLDBCQUEwQixzQ0FBc0MsNkJBQTZCLFNBQVMsWUFBWSxZQUFZLEdBQUcsSUFBSSxjQUFjLFNBQVMsK0NBQStDLFVBQVUsb0NBQW9DLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSwrQkFBK0Isb0JBQW9CLHdCQUF3Qix5Q0FBeUMsVUFBVSxTQUFTLE1BQU0sZ0VBQWdFLGVBQWUsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFNBQVMsMENBQTBDLFlBQVksMEJBQTBCLCtCQUErQiwwQkFBMEIsTUFBTSwwSkFBMEosR0FBRyxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsRUFBRSxVQUFVLFFBQVEsbUJBQW1CLGtCQUFrQixrQ0FBa0MsY0FBYyxNQUFNLEVBQUUsR0FBRywrQkFBK0Isb0JBQW9CLFNBQVMsdUtBQXVLLHNCQUFzQixXQUFXLFdBQVcsV0FBVyxXQUFXLFFBQVEsTUFBTSw0QkFBNEIsbUNBQW1DLHVDQUF1Qyx1Q0FBdUMsMkJBQTJCLGNBQWMsWUFBWSxpQkFBaUIsMENBQTBDLGtCQUFrQixrQkFBa0IsUUFBUSwyQ0FBMkMsSUFBSSxVQUFVLElBQUksWUFBWSxhQUFhLGVBQWUsVUFBVSxhQUFhLG9CQUFvQixPQUFPLFdBQVcsb0JBQW9CLE9BQU8sU0FBUyxlQUFlLHdCQUF3Qix5REFBeUQsd0VBQXdFLCtDQUErQyw0Q0FBNEMsY0FBYyxZQUFZLFdBQVcsb0JBQW9CLCtCQUErQiw2QkFBNkIsK0JBQStCLHdDQUF3QyxxQ0FBcUMsaUJBQWlCLE9BQU8sU0FBUyxVQUFVLEtBQUssMEJBQTBCLFNBQVMsK0JBQStCLFNBQVMsa0JBQWtCLGtCQUFrQixrQ0FBa0Msb0JBQW9CLE1BQU0sb0NBQW9DLEVBQUUsTUFBTSw2Q0FBNkMsRUFBRSxXQUFXLHVCQUF1QixpQ0FBaUMsTUFBTSxzQkFBc0IsUUFBUSxxREFBcUQsY0FBYyw0Q0FBNEMsaUJBQWlCLEVBQUUsRUFBRSxtRUFBbUUsaUJBQWlCLHFCQUFxQixTQUFTLGNBQWMsRUFBRSxHQUFHLEVBQUUsR0FBRyx3QkFBd0IsdUJBQXVCLE1BQU0sMkNBQTJDLEVBQUUscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVksbUNBQW1DLGFBQWEsT0FBTyxTQUFTLFlBQVksTUFBTSxxQ0FBcUMsVUFBVSxtQ0FBbUMsMEJBQTBCLFlBQVksMEJBQTBCLFlBQVksTUFBTSxvQkFBb0IsU0FBUyxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcsYUFBYSxzQkFBc0Isc0JBQXNCLEtBQUssMERBQTBELDZCQUE2QixXQUFXLFNBQVMsNkJBQTZCLFNBQVMsY0FBYyxNQUFNLGFBQWEsU0FBUyxhQUFhLFlBQVksMkJBQTJCLFNBQVMsa0JBQWtCLEdBQUcsU0FBUyxPQUFPLFFBQVEsTUFBTSxvQkFBb0IsRUFBRSxTQUFTLGlDQUFpQyxRQUFRLHFCQUFxQixjQUFjLFdBQVcsWUFBWSxTQUFTLHNCQUFzQixNQUFNLEtBQUssT0FBTyxtQkFBbUIsTUFBTSxvQkFBb0IsRUFBRSxVQUFVLDJEQUEyRCw2QkFBNkIseUJBQXlCLG9CQUFvQixhQUFhLG9CQUFvQixpQ0FBaUMsMkJBQTJCLDJCQUEyQixhQUFhLE1BQU0sWUFBWSxpQkFBaUIsSUFBSSxnQ0FBZ0MsV0FBVyxZQUFZLDJDQUEyQyxPQUFPLEVBQUUsRUFBRSw2Q0FBNkMsT0FBTyxFQUFFLEVBQUUsMkNBQTJDLE1BQU0sV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLDBCQUEwQixtQkFBbUIsV0FBVyxRQUFRLFFBQVEsRUFBRSxTQUFTLFlBQVksMEJBQTBCLHdCQUF3QixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxvQkFBb0IsTUFBTSxxQkFBcUIsRUFBRSxTQUFTLFlBQVksMENBQTBDLGtEQUFrRCxzQkFBc0IsNkJBQTZCLHNCQUFzQixTQUFTLE1BQU0sK0NBQStDLEVBQUUsb0JBQW9CLFNBQVMsWUFBWSxtREFBbUQsZ0RBQWdELGtEQUFrRCxPQUFPLEVBQUUsRUFBRSxLQUFLLHNCQUFzQixNQUFNLHVCQUF1QixFQUFFLFNBQVMsWUFBWSxrRUFBa0UsTUFBTSxnQ0FBZ0MsRUFBRSxFQUFFLEVBQUUsU0FBUyxtQkFBbUIsNEJBQTRCLGtEQUFrRCxNQUFNLGdDQUFnQyxFQUFFLEVBQUUsRUFBRSxTQUFTLHNCQUFzQix5QkFBeUIsaURBQWlELE1BQU0sRUFBRSxFQUFFLFdBQVcsUUFBUSxRQUFRLEVBQUUsa0RBQWtELFNBQVMsK0JBQStCLDJDQUEyQyw2QkFBNkIsWUFBWSxVQUFVLFNBQVMsWUFBWSxFQUFFLEVBQUUsRUFBRSxHQUFHLFFBQVEsR0FBRyxrQkFBa0IsU0FBUyxTQUFTLHFCQUFxQixvQkFBb0IsU0FBUyx5RkFBeUYsVUFBVSxRQUFRLFNBQVMsU0FBUyxHQUFHLHNCQUFzQix5QkFBeUIsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLFVBQVUsa0JBQWtCLGtCQUFrQixXQUFXLHFCQUFxQixLQUFLLEtBQUssUUFBUSx3QkFBd0IsTUFBTSx1QkFBdUIsdUJBQXVCLG1CQUFtQixpQkFBaUIsa0NBQWtDLHdDQUF3QyxzQ0FBc0MscUJBQXFCLEVBQUUsUUFBUSxFQUFFLFdBQVcsa0JBQWtCLDZCQUE2QixNQUFNLDhCQUE4QixFQUFFLG9CQUFvQixRQUFRLFNBQVMsWUFBWSxlQUFlLDJCQUEyQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSxRQUFRLHNCQUFzQixnQ0FBZ0MsYUFBYSxNQUFNLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLHdDQUF3QyxrQkFBa0IsY0FBYyxZQUFZLFFBQVEsSUFBSSxTQUFTLE1BQU0sOEJBQThCLEVBQUUsU0FBUyxZQUFZLCtCQUErQiw0QkFBNEIsc0JBQXNCLGNBQWMsWUFBWSxXQUFXLFlBQVksU0FBUyw0REFBNEQsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLE1BQU0sNEJBQTRCLEVBQUUsU0FBUyxZQUFZLHlCQUF5QixrREFBa0QsdUJBQXVCLFNBQVMsd0JBQXdCLFlBQVksUUFBUSxpRkFBaUYsT0FBTyxFQUFFLEVBQUUsTUFBTSw2QkFBNkIsRUFBRSxTQUFTLHFEQUFxRCxNQUFNLDhCQUE4QixFQUFFLFNBQVMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLFlBQVksa0NBQWtDLHFDQUFxQyx3QkFBd0IsVUFBVSxtQ0FBbUMsU0FBUyxVQUFVLFlBQVksOENBQThDLHNCQUFzQixTQUFTLHNDQUFzQyxNQUFNLDZCQUE2QixFQUFFLFNBQVMsNEVBQTRFLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxNQUFNLG9CQUFvQixFQUFFLFNBQVMsWUFBWSw4Q0FBOEMsTUFBTSx5Q0FBeUMsRUFBRSxTQUFTLE1BQU0sb0JBQW9CLEVBQUUsU0FBUyxZQUFZLHFCQUFxQixPQUFPLEVBQUUsRUFBRSw0QkFBNEIsTUFBTSxRQUFRLHFCQUFxQixNQUFNLG9CQUFvQixFQUFFLFNBQVMsNENBQTRDLGNBQWMsWUFBWSxXQUFXLFdBQVcsaUJBQWlCLGdCQUFnQixXQUFXLFNBQVMsa0JBQWtCLDBDQUEwQyxzQkFBc0IsU0FBUyxvQkFBb0Isd0JBQXdCLFdBQVcsU0FBUyxlQUFlLGVBQWUseUNBQXlDLGtEQUFrRCwwQ0FBMEMsTUFBTSw4QkFBOEIsRUFBRSxTQUFTLHlEQUF5RCxzREFBc0QsaUNBQWlDLE1BQU0sOEJBQThCLEVBQUUsU0FBUyw0QkFBNEIscUJBQXFCLGVBQWUsTUFBTSxhQUFhLGlCQUFpQiwwQkFBMEIsa0JBQWtCLFdBQVcscUJBQXFCLGtCQUFrQixnQkFBZ0IsV0FBVyxTQUFTLHFEQUFxRCx1REFBdUQsZUFBZSxTQUFTLEVBQUUsa0JBQWtCLGlEQUFpRCxXQUFXLGdCQUFnQiw0QkFBNEIsV0FBVyxTQUFTLHNEQUFzRCw4QkFBOEIsdURBQXVELGVBQWUsU0FBUyxFQUFFLGtCQUFrQixZQUFZLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxXQUFXLDRCQUE0QixnQkFBZ0IsZUFBZSxNQUFNLGlDQUFpQyxFQUFFLFNBQVMsK0JBQStCLGtCQUFrQixXQUFXLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxFQUFFLEVBQUUsR0FBRyxrQkFBa0IsZ0JBQWdCLGVBQWUsTUFBTSxpQ0FBaUMsRUFBRSxTQUFTLDRDQUE0QyxrQkFBa0IscUJBQXFCLFdBQVcsbUJBQW1CLGdCQUFnQixXQUFXLFNBQVMsU0FBUyw4QkFBOEIsa0JBQWtCLGVBQWUscUNBQXFDLG9CQUFvQixRQUFRLFNBQVMsOERBQThELFdBQVcsUUFBUSxTQUFTLHdEQUF3RCxtQkFBbUIsWUFBWSxZQUFZLHNCQUFzQixZQUFZLFlBQVksS0FBSyxZQUFZLFlBQVksY0FBYyxZQUFZLGFBQWEsUUFBUSxvQkFBb0IsNkVBQTZFLG9DQUFvQyxzQkFBc0Isa0JBQWtCLDZFQUE2RSxvQ0FBb0Msb0JBQW9CLGtCQUFrQix5RUFBeUUsSUFBSSxpQ0FBaUMsR0FBRyxvQkFBb0Isa0VBQWtFLE1BQU0sc0NBQXNDLEVBQUUsR0FBRyxFQUFFLHVCQUF1QixZQUFZLHlCQUF5QiwwQ0FBMEMsYUFBYSxxQkFBcUIsVUFBVSx3QkFBd0IsU0FBUyxNQUFNLGdFQUFnRSxpQkFBaUIsUUFBUSx1Q0FBdUMsRUFBRSxvQ0FBb0MsRUFBRSxHQUFHLFVBQVUsTUFBTSwrR0FBK0csd0JBQXdCLGtCQUFrQixrQkFBa0IsMEJBQTBCLFNBQVMseUJBQXlCLDRCQUE0QixjQUFjLE1BQU0sRUFBRSxHQUFHLG1CQUFtQixnQ0FBZ0MsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFLFVBQVUsU0FBUyxpQkFBaUIsVUFBVSxpQkFBaUIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1CQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSw4QkFBOEIsdUJBQXVCLEVBQUUsRUFBRSxZQUFZLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHlCQUF5QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLHdCQUF3QixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFTLGlDQUFpQyxhQUFhLHFCQUFxQixhQUFhLG1CQUFtQiw0QkFBNEIsZ0JBQWdCLDhCQUE4QixNQUFNLEVBQUUsR0FBRyxVQUFVLGdCQUFnQixlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsNERBQTRELGdDQUFnQyxxQkFBcUIscUNBQXFDLHVCQUF1QixrQkFBa0IsYUFBYSxjQUFjLGNBQWMsb0JBQW9CLHVDQUF1QyxvQ0FBb0MsaUVBQWlFLGNBQWMsa0JBQWtCLG9FQUFvRSxnQkFBZ0IsZUFBZSx3QkFBd0IsYUFBYSxTQUFTLDZDQUE2QyxrQ0FBa0MsNEJBQTRCLE1BQU0sMkJBQTJCLHVCQUF1QixlQUFlLEVBQUUsU0FBUyxtRUFBbUUsbUNBQW1DLGNBQWMsY0FBYyxnQkFBZ0IsaUJBQWlCLGlCQUFpQixtQ0FBbUMsY0FBYyxnQkFBZ0IsaUJBQWlCLGtDQUFrQyxhQUFhLGlCQUFpQixNQUFNLGdCQUFnQixnQkFBZ0IsdUJBQXVCLGVBQWUsR0FBRyxJQUFJLHdCQUF3QixxREFBcUQsV0FBVyxPQUFPLHlCQUF5QixjQUFjLDRDQUE0QyxZQUFZLGtCQUFrQixjQUFjLFdBQVcsUUFBUSxnQ0FBZ0MsMENBQTBDLCtCQUErQixLQUFLLGFBQWEsT0FBTyxzQ0FBc0MsOEJBQThCLG9EQUFvRCw4QkFBOEIsNkNBQTZDLHdCQUF3Qiw0REFBNEQsWUFBWSxxQkFBcUIsR0FBRyw2QkFBNkIsNENBQTRDLGFBQWEsZ0JBQWdCLGNBQWMsMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxTQUFTLEdBQUcsRUFBRSxFQUFFLHdCQUF3QixTQUFTLEVBQUUsTUFBTSwrQkFBK0IsYUFBYSxVQUFVLFVBQVUsd0JBQXdCLG9CQUFvQiw0QkFBNEIsbURBQW1ELE9BQU8sOEJBQThCLGtEQUFrRCwwQkFBMEIsY0FBYyxTQUFTLHFDQUFxQywwQkFBMEIsSUFBSSxjQUFjLGdEQUFnRCxTQUFTLDZCQUE2QixhQUFhLHNCQUFzQixvQkFBb0IsZUFBZSxjQUFjLE1BQU0sK1NBQStTLFFBQVEsc0NBQXNDLGdCQUFnQixzQkFBc0Isa0NBQWtDLG1CQUFtQixjQUFjLG1CQUFtQiwyQ0FBMkMsV0FBVyxXQUFXLFdBQVcsUUFBUSxTQUFTLFFBQVEsUUFBUSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLFFBQVEsTUFBTSxNQUFNLE9BQU8sK0JBQStCLG1CQUFtQixpQ0FBaUMsbUJBQW1CLElBQUksMEJBQTBCLFdBQVcsWUFBWSxNQUFNLFVBQVUscUJBQXFCLFlBQVksVUFBVSxPQUFPLFNBQVMsb0JBQW9CLElBQUksbUNBQW1DLFVBQVUscUJBQXFCLFVBQVUsU0FBUyxVQUFVLElBQUksU0FBUyx1Q0FBdUMsaUJBQWlCLGdCQUFnQixPQUFPLGFBQWEsU0FBUyxNQUFNLG9CQUFvQixpQkFBaUIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxJQUFJLFVBQVUsUUFBUSxpQkFBaUIsT0FBTyxRQUFRLGFBQWEsU0FBUyxNQUFNLFVBQVUsVUFBVSxVQUFVLEdBQUcsK0JBQStCLHFCQUFxQixtQkFBbUIsS0FBSyxTQUFTLE1BQU0sU0FBUyxtQkFBbUIsMENBQTBDLHlCQUF5QixnQkFBZ0IsbUJBQW1CLE9BQU8saUJBQWlCLE9BQU8sYUFBYSxtQ0FBbUMsVUFBVSxxQkFBcUIsWUFBWSxTQUFTLFVBQVUsZ0JBQWdCLE9BQU8sT0FBTyxTQUFTLE9BQU8sVUFBVSw2QkFBNkIsZ0JBQWdCLE9BQU8sYUFBYSxTQUFTLE1BQU0sVUFBVSxnQkFBZ0IsT0FBTyxhQUFhLFNBQVMsTUFBTSxVQUFVLG1DQUFtQyxVQUFVLHFCQUFxQixVQUFVLFNBQVMsVUFBVSxtQkFBbUIsZ0JBQWdCLE9BQU8sT0FBTyxhQUFhLFNBQVMsTUFBTSxvQ0FBb0MsaUJBQWlCLElBQUksU0FBUyw0QkFBNEIsZ0JBQWdCLGFBQWEsbUNBQW1DLFVBQVUscUJBQXFCLFlBQVksU0FBUyxVQUFVLE9BQU8sT0FBTyxTQUFTLE1BQU0sYUFBYSxPQUFPLGFBQWEsU0FBUyxPQUFPLG1CQUFtQixRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsUUFBUSxlQUFlLGFBQWEsS0FBSyxxQkFBcUIsZUFBZSxhQUFhLGtCQUFrQixLQUFLLElBQUksS0FBSyxJQUFJLDhCQUE4Qiw4Q0FBOEMsaUJBQWlCLHNCQUFzQiw4QkFBOEIsZ0JBQWdCLDBCQUEwQixTQUFTLDJIQUEySCxvQkFBb0IsYUFBYSx3QkFBd0IsVUFBVSxXQUFXLG9DQUFvQyxNQUFNLFlBQVksV0FBVyxLQUFLLGdCQUFnQixhQUFhLHFCQUFxQixhQUFhLGlCQUFpQixtQkFBbUIsYUFBYSxLQUFLLGFBQWEsWUFBWSx1QkFBdUIsa0JBQWtCLFVBQVUsSUFBSSxvQkFBb0IscUJBQXFCLFVBQVUsYUFBYSxzQkFBc0IscUJBQXFCLGlDQUFpQyxZQUFZLFVBQVUsVUFBVSxlQUFlLGNBQWMsTUFBTSw4RkFBOEYsUUFBUSwrREFBK0QsNkJBQTZCLGtEQUFrRCxxQ0FBcUMscUNBQXFDLHVEQUF1RCx1QkFBdUIsMkJBQTJCLG1CQUFtQiw4Q0FBOEMsU0FBUyxhQUFhLElBQUksV0FBVyxHQUFHLHNCQUFzQixJQUFJLFFBQVEsdUJBQXVCLGFBQWEsY0FBYyxVQUFVLG9CQUFvQixLQUFLLElBQUksMEJBQTBCLDBCQUEwQixTQUFTLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFLHFCQUFxQixZQUFZLEVBQUUsT0FBTyxVQUFVLGVBQWUsVUFBVSxHQUFHLElBQUksK0JBQStCLHNCQUFzQixXQUFXLHFCQUFxQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanM/ODIyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgdD17MTcwOih0LGUsdSk9Pntjb25zdCBuPXUoNTEwKTtjb25zdCBpc1dpbmRvd3M9KCk9PntpZih0eXBlb2YgbmF2aWdhdG9yIT09XCJ1bmRlZmluZWRcIiYmbmF2aWdhdG9yLnBsYXRmb3JtKXtjb25zdCB0PW5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO3JldHVybiB0PT09XCJ3aW4zMlwifHx0PT09XCJ3aW5kb3dzXCJ9aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLnBsYXRmb3JtKXtyZXR1cm4gcHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIn1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIHBpY29tYXRjaCh0LGUsdT1mYWxzZSl7aWYoZSYmKGUud2luZG93cz09PW51bGx8fGUud2luZG93cz09PXVuZGVmaW5lZCkpe2U9ey4uLmUsd2luZG93czppc1dpbmRvd3MoKX19cmV0dXJuIG4odCxlLHUpfU9iamVjdC5hc3NpZ24ocGljb21hdGNoLG4pO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDE1NDp0PT57Y29uc3QgZT1cIlxcXFxcXFxcL1wiO2NvbnN0IHU9YFteJHtlfV1gO2NvbnN0IG49XCJcXFxcLlwiO2NvbnN0IG89XCJcXFxcK1wiO2NvbnN0IHM9XCJcXFxcP1wiO2NvbnN0IHI9XCJcXFxcL1wiO2NvbnN0IGE9XCIoPz0uKVwiO2NvbnN0IGk9XCJbXi9dXCI7Y29uc3QgYz1gKD86JHtyfXwkKWA7Y29uc3QgcD1gKD86Xnwke3J9KWA7Y29uc3QgbD1gJHtufXsxLDJ9JHtjfWA7Y29uc3QgZj1gKD8hJHtufSlgO2NvbnN0IEE9YCg/ISR7cH0ke2x9KWA7Y29uc3QgXz1gKD8hJHtufXswLDF9JHtjfSlgO2NvbnN0IFI9YCg/ISR7bH0pYDtjb25zdCBFPWBbXi4ke3J9XWA7Y29uc3QgaD1gJHtpfSo/YDtjb25zdCBnPVwiL1wiO2NvbnN0IGI9e0RPVF9MSVRFUkFMOm4sUExVU19MSVRFUkFMOm8sUU1BUktfTElURVJBTDpzLFNMQVNIX0xJVEVSQUw6cixPTkVfQ0hBUjphLFFNQVJLOmksRU5EX0FOQ0hPUjpjLERPVFNfU0xBU0g6bCxOT19ET1Q6ZixOT19ET1RTOkEsTk9fRE9UX1NMQVNIOl8sTk9fRE9UU19TTEFTSDpSLFFNQVJLX05PX0RPVDpFLFNUQVI6aCxTVEFSVF9BTkNIT1I6cCxTRVA6Z307Y29uc3QgQz17Li4uYixTTEFTSF9MSVRFUkFMOmBbJHtlfV1gLFFNQVJLOnUsU1RBUjpgJHt1fSo/YCxET1RTX1NMQVNIOmAke259ezEsMn0oPzpbJHtlfV18JClgLE5PX0RPVDpgKD8hJHtufSlgLE5PX0RPVFM6YCg/ISg/Ol58WyR7ZX1dKSR7bn17MSwyfSg/Olske2V9XXwkKSlgLE5PX0RPVF9TTEFTSDpgKD8hJHtufXswLDF9KD86WyR7ZX1dfCQpKWAsTk9fRE9UU19TTEFTSDpgKD8hJHtufXsxLDJ9KD86WyR7ZX1dfCQpKWAsUU1BUktfTk9fRE9UOmBbXi4ke2V9XWAsU1RBUlRfQU5DSE9SOmAoPzpefFske2V9XSlgLEVORF9BTkNIT1I6YCg/Olske2V9XXwkKWAsU0VQOlwiXFxcXFwifTtjb25zdCB5PXthbG51bTpcImEtekEtWjAtOVwiLGFscGhhOlwiYS16QS1aXCIsYXNjaWk6XCJcXFxceDAwLVxcXFx4N0ZcIixibGFuazpcIiBcXFxcdFwiLGNudHJsOlwiXFxcXHgwMC1cXFxceDFGXFxcXHg3RlwiLGRpZ2l0OlwiMC05XCIsZ3JhcGg6XCJcXFxceDIxLVxcXFx4N0VcIixsb3dlcjpcImEtelwiLHByaW50OlwiXFxcXHgyMC1cXFxceDdFIFwiLHB1bmN0OlwiXFxcXC0hXFxcIiMkJSYnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9flwiLHNwYWNlOlwiIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGZcIix1cHBlcjpcIkEtWlwiLHdvcmQ6XCJBLVphLXowLTlfXCIseGRpZ2l0OlwiQS1GYS1mMC05XCJ9O3QuZXhwb3J0cz17TUFYX0xFTkdUSDoxMDI0KjY0LFBPU0lYX1JFR0VYX1NPVVJDRTp5LFJFR0VYX0JBQ0tTTEFTSDovXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6L15bXkAhW1xcXS4sJCorP157fSgpfFxcXFwvXSsvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6L1stKis/Ll4ke30ofClbXFxdXS8sUkVHRVhfU1BFQ0lBTF9DSEFSU19CQUNLUkVGOi8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOi8oWy0qKz8uXiR7fSh8KVtcXF1dKS9nLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6Lyg/OlxcWy4qP1teXFxcXF1cXF18XFxcXCg/PS4pKS9nLFJFUExBQ0VNRU5UUzp7XCIqKipcIjpcIipcIixcIioqLyoqXCI6XCIqKlwiLFwiKiovKiovKipcIjpcIioqXCJ9LENIQVJfMDo0OCxDSEFSXzk6NTcsQ0hBUl9VUFBFUkNBU0VfQTo2NSxDSEFSX0xPV0VSQ0FTRV9BOjk3LENIQVJfVVBQRVJDQVNFX1o6OTAsQ0hBUl9MT1dFUkNBU0VfWjoxMjIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOjQwLENIQVJfUklHSFRfUEFSRU5USEVTRVM6NDEsQ0hBUl9BU1RFUklTSzo0MixDSEFSX0FNUEVSU0FORDozOCxDSEFSX0FUOjY0LENIQVJfQkFDS1dBUkRfU0xBU0g6OTIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46MTMsQ0hBUl9DSVJDVU1GTEVYX0FDQ0VOVDo5NCxDSEFSX0NPTE9OOjU4LENIQVJfQ09NTUE6NDQsQ0hBUl9ET1Q6NDYsQ0hBUl9ET1VCTEVfUVVPVEU6MzQsQ0hBUl9FUVVBTDo2MSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6MzMsQ0hBUl9GT1JNX0ZFRUQ6MTIsQ0hBUl9GT1JXQVJEX1NMQVNIOjQ3LENIQVJfR1JBVkVfQUNDRU5UOjk2LENIQVJfSEFTSDozNSxDSEFSX0hZUEhFTl9NSU5VUzo0NSxDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDo2MCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6MTIzLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDo5MSxDSEFSX0xJTkVfRkVFRDoxMCxDSEFSX05PX0JSRUFLX1NQQUNFOjE2MCxDSEFSX1BFUkNFTlQ6MzcsQ0hBUl9QTFVTOjQzLENIQVJfUVVFU1RJT05fTUFSSzo2MyxDSEFSX1JJR0hUX0FOR0xFX0JSQUNLRVQ6NjIsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRToxMjUsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDo5MyxDSEFSX1NFTUlDT0xPTjo1OSxDSEFSX1NJTkdMRV9RVU9URTozOSxDSEFSX1NQQUNFOjMyLENIQVJfVEFCOjksQ0hBUl9VTkRFUlNDT1JFOjk1LENIQVJfVkVSVElDQUxfTElORToxMjQsQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0U6NjUyNzksZXh0Z2xvYkNoYXJzKHQpe3JldHVybntcIiFcIjp7dHlwZTpcIm5lZ2F0ZVwiLG9wZW46XCIoPzooPyEoPzpcIixjbG9zZTpgKSkke3QuU1RBUn0pYH0sXCI/XCI6e3R5cGU6XCJxbWFya1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIik/XCJ9LFwiK1wiOnt0eXBlOlwicGx1c1wiLG9wZW46XCIoPzpcIixjbG9zZTpcIikrXCJ9LFwiKlwiOnt0eXBlOlwic3RhclwiLG9wZW46XCIoPzpcIixjbG9zZTpcIikqXCJ9LFwiQFwiOnt0eXBlOlwiYXRcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpXCJ9fX0sZ2xvYkNoYXJzKHQpe3JldHVybiB0PT09dHJ1ZT9DOmJ9fX0sNjk3Oih0LGUsdSk9Pntjb25zdCBuPXUoMTU0KTtjb25zdCBvPXUoOTYpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6cixSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzphLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjppLFJFUExBQ0VNRU5UUzpjfT1uO2NvbnN0IGV4cGFuZFJhbmdlPSh0LGUpPT57aWYodHlwZW9mIGUuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiBlLmV4cGFuZFJhbmdlKC4uLnQsZSl9dC5zb3J0KCk7Y29uc3QgdT1gWyR7dC5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cCh1KX1jYXRjaChlKXtyZXR1cm4gdC5tYXAoKHQ9Pm8uZXNjYXBlUmVnZXgodCkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHV9O2NvbnN0IHN5bnRheEVycm9yPSh0LGUpPT5gTWlzc2luZyAke3R9OiBcIiR7ZX1cIiAtIHVzZSBcIlxcXFxcXFxcJHtlfVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KHQsZSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX10PWNbdF18fHQ7Y29uc3QgdT17Li4uZX07Y29uc3QgcD10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7bGV0IGw9dC5sZW5ndGg7aWYobD5wKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3B9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnUucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgXz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgUj1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IEU9bi5leHRnbG9iQ2hhcnMoUik7Y29uc3R7RE9UX0xJVEVSQUw6aCxQTFVTX0xJVEVSQUw6ZyxTTEFTSF9MSVRFUkFMOmIsT05FX0NIQVI6QyxET1RTX1NMQVNIOnksTk9fRE9UOiQsTk9fRE9UX1NMQVNIOngsTk9fRE9UU19TTEFTSDpTLFFNQVJLOkgsUU1BUktfTk9fRE9UOnYsU1RBUjpkLFNUQVJUX0FOQ0hPUjpMfT1SO2NvbnN0IGdsb2JzdGFyPXQ9PmAoJHtffSg/Oig/ISR7TH0ke3QuZG90P3k6aH0pLikqPylgO2NvbnN0IFQ9dS5kb3Q/XCJcIjokO2NvbnN0IE89dS5kb3Q/SDp2O2xldCBrPXUuYmFzaD09PXRydWU/Z2xvYnN0YXIodSk6ZDtpZih1LmNhcHR1cmUpe2s9YCgke2t9KWB9aWYodHlwZW9mIHUubm9leHQ9PT1cImJvb2xlYW5cIil7dS5ub2V4dGdsb2I9dS5ub2V4dH1jb25zdCBtPXtpbnB1dDp0LGluZGV4Oi0xLHN0YXJ0OjAsZG90OnUuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O3Q9by5yZW1vdmVQcmVmaXgodCxtKTtsPXQubGVuZ3RoO2NvbnN0IHc9W107Y29uc3QgTj1bXTtjb25zdCBJPVtdO2xldCBCPWY7bGV0IEc7Y29uc3QgZW9zPSgpPT5tLmluZGV4PT09bC0xO2NvbnN0IEQ9bS5wZWVrPShlPTEpPT50W20uaW5kZXgrZV07Y29uc3QgTT1tLmFkdmFuY2U9KCk9PnRbKyttLmluZGV4XXx8XCJcIjtjb25zdCByZW1haW5pbmc9KCk9PnQuc2xpY2UobS5pbmRleCsxKTtjb25zdCBjb25zdW1lPSh0PVwiXCIsZT0wKT0+e20uY29uc3VtZWQrPXQ7bS5pbmRleCs9ZX07Y29uc3QgYXBwZW5kPXQ9PnttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtjb25zdW1lKHQudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgdD0xO3doaWxlKEQoKT09PVwiIVwiJiYoRCgyKSE9PVwiKFwifHxEKDMpPT09XCI/XCIpKXtNKCk7bS5zdGFydCsrO3QrK31pZih0JTI9PT0wKXtyZXR1cm4gZmFsc2V9bS5uZWdhdGVkPXRydWU7bS5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9dD0+e21bdF0rKztJLnB1c2godCl9O2NvbnN0IGRlY3JlbWVudD10PT57bVt0XS0tO0kucG9wKCl9O2NvbnN0IHB1c2g9dD0+e2lmKEIudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgZT1tLmJyYWNlcz4wJiYodC50eXBlPT09XCJjb21tYVwifHx0LnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHU9dC5leHRnbG9iPT09dHJ1ZXx8dy5sZW5ndGgmJih0LnR5cGU9PT1cInBpcGVcInx8dC50eXBlPT09XCJwYXJlblwiKTtpZih0LnR5cGUhPT1cInNsYXNoXCImJnQudHlwZSE9PVwicGFyZW5cIiYmIWUmJiF1KXttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cInN0YXJcIjtCLnZhbHVlPVwiKlwiO0Iub3V0cHV0PWs7bS5vdXRwdXQrPUIub3V0cHV0fX1pZih3Lmxlbmd0aCYmdC50eXBlIT09XCJwYXJlblwiKXt3W3cubGVuZ3RoLTFdLmlubmVyKz10LnZhbHVlfWlmKHQudmFsdWV8fHQub3V0cHV0KWFwcGVuZCh0KTtpZihCJiZCLnR5cGU9PT1cInRleHRcIiYmdC50eXBlPT09XCJ0ZXh0XCIpe0Iub3V0cHV0PShCLm91dHB1dHx8Qi52YWx1ZSkrdC52YWx1ZTtCLnZhbHVlKz10LnZhbHVlO3JldHVybn10LnByZXY9QjtBLnB1c2godCk7Qj10fTtjb25zdCBleHRnbG9iT3Blbj0odCxlKT0+e2NvbnN0IG49ey4uLkVbZV0sY29uZGl0aW9uczoxLGlubmVyOlwiXCJ9O24ucHJldj1CO24ucGFyZW5zPW0ucGFyZW5zO24ub3V0cHV0PW0ub3V0cHV0O2NvbnN0IG89KHUuY2FwdHVyZT9cIihcIjpcIlwiKStuLm9wZW47aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6dCx2YWx1ZTplLG91dHB1dDptLm91dHB1dD9cIlwiOkN9KTtwdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6TSgpLG91dHB1dDpvfSk7dy5wdXNoKG4pfTtjb25zdCBleHRnbG9iQ2xvc2U9dD0+e2xldCBuPXQuY2xvc2UrKHUuY2FwdHVyZT9cIilcIjpcIlwiKTtsZXQgbztpZih0LnR5cGU9PT1cIm5lZ2F0ZVwiKXtsZXQgcz1rO2lmKHQuaW5uZXImJnQuaW5uZXIubGVuZ3RoPjEmJnQuaW5uZXIuaW5jbHVkZXMoXCIvXCIpKXtzPWdsb2JzdGFyKHUpfWlmKHMhPT1rfHxlb3MoKXx8L15cXCkrJC8udGVzdChyZW1haW5pbmcoKSkpe249dC5jbG9zZT1gKSQpKSR7c31gfWlmKHQuaW5uZXIuaW5jbHVkZXMoXCIqXCIpJiYobz1yZW1haW5pbmcoKSkmJi9eXFwuW15cXFxcLy5dKyQvLnRlc3Qobykpe2NvbnN0IHU9cGFyc2Uobyx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KS5vdXRwdXQ7bj10LmNsb3NlPWApJHt1fSkke3N9KWB9aWYodC5wcmV2LnR5cGU9PT1cImJvc1wiKXttLm5lZ2F0ZWRFeHRnbG9iPXRydWV9fXB1c2goe3R5cGU6XCJwYXJlblwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpufSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpfTtpZih1LmZhc3RwYXRocyE9PWZhbHNlJiYhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdCh0KSl7bGV0IG49ZmFsc2U7bGV0IHM9dC5yZXBsYWNlKGksKCh0LGUsdSxvLHMscik9PntpZihvPT09XCJcXFxcXCIpe249dHJ1ZTtyZXR1cm4gdH1pZihvPT09XCI/XCIpe2lmKGUpe3JldHVybiBlK28rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfWlmKHI9PT0wKXtyZXR1cm4gTysocz9ILnJlcGVhdChzLmxlbmd0aCk6XCJcIil9cmV0dXJuIEgucmVwZWF0KHUubGVuZ3RoKX1pZihvPT09XCIuXCIpe3JldHVybiBoLnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiKlwiKXtpZihlKXtyZXR1cm4gZStvKyhzP2s6XCJcIil9cmV0dXJuIGt9cmV0dXJuIGU/dDpgXFxcXCR7dH1gfSkpO2lmKG49PT10cnVlKXtpZih1LnVuZXNjYXBlPT09dHJ1ZSl7cz1zLnJlcGxhY2UoL1xcXFwvZyxcIlwiKX1lbHNle3M9cy5yZXBsYWNlKC9cXFxcKy9nLCh0PT50Lmxlbmd0aCUyPT09MD9cIlxcXFxcXFxcXCI6dD9cIlxcXFxcIjpcIlwiKSl9fWlmKHM9PT10JiZ1LmNvbnRhaW5zPT09dHJ1ZSl7bS5vdXRwdXQ9dDtyZXR1cm4gbX1tLm91dHB1dD1vLndyYXBPdXRwdXQocyxtLGUpO3JldHVybiBtfXdoaWxlKCFlb3MoKSl7Rz1NKCk7aWYoRz09PVwiXFwwXCIpe2NvbnRpbnVlfWlmKEc9PT1cIlxcXFxcIil7Y29uc3QgdD1EKCk7aWYodD09PVwiL1wiJiZ1LmJhc2ghPT10cnVlKXtjb250aW51ZX1pZih0PT09XCIuXCJ8fHQ9PT1cIjtcIil7Y29udGludWV9aWYoIXQpe0crPVwiXFxcXFwiO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWNvbnN0IGU9L15cXFxcKy8uZXhlYyhyZW1haW5pbmcoKSk7bGV0IG49MDtpZihlJiZlWzBdLmxlbmd0aD4yKXtuPWVbMF0ubGVuZ3RoO20uaW5kZXgrPW47aWYobiUyIT09MCl7Rys9XCJcXFxcXCJ9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtHPU0oKX1lbHNle0crPU0oKX1pZihtLmJyYWNrZXRzPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9fWlmKG0uYnJhY2tldHM+MCYmKEchPT1cIl1cInx8Qi52YWx1ZT09PVwiW1wifHxCLnZhbHVlPT09XCJbXlwiKSl7aWYodS5wb3NpeCE9PWZhbHNlJiZHPT09XCI6XCIpe2NvbnN0IHQ9Qi52YWx1ZS5zbGljZSgxKTtpZih0LmluY2x1ZGVzKFwiW1wiKSl7Qi5wb3NpeD10cnVlO2lmKHQuaW5jbHVkZXMoXCI6XCIpKXtjb25zdCB0PUIudmFsdWUubGFzdEluZGV4T2YoXCJbXCIpO2NvbnN0IGU9Qi52YWx1ZS5zbGljZSgwLHQpO2NvbnN0IHU9Qi52YWx1ZS5zbGljZSh0KzIpO2NvbnN0IG49clt1XTtpZihuKXtCLnZhbHVlPWUrbjttLmJhY2t0cmFjaz10cnVlO00oKTtpZighZi5vdXRwdXQmJkEuaW5kZXhPZihCKT09PTEpe2Yub3V0cHV0PUN9Y29udGludWV9fX19aWYoRz09PVwiW1wiJiZEKCkhPT1cIjpcInx8Rz09PVwiLVwiJiZEKCk9PT1cIl1cIil7Rz1gXFxcXCR7R31gfWlmKEc9PT1cIl1cIiYmKEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe0c9YFxcXFwke0d9YH1pZih1LnBvc2l4PT09dHJ1ZSYmRz09PVwiIVwiJiZCLnZhbHVlPT09XCJbXCIpe0c9XCJeXCJ9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihtLnF1b3Rlcz09PTEmJkchPT0nXCInKXtHPW8uZXNjYXBlUmVnZXgoRyk7Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09J1wiJyl7bS5xdW90ZXM9bS5xdW90ZXM9PT0xPzA6MTtpZih1LmtlZXBRdW90ZXM9PT10cnVlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KX1jb250aW51ZX1pZihHPT09XCIoXCIpe2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiKVwiKXtpZihtLnBhcmVucz09PTAmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCIoXCIpKX1jb25zdCB0PXdbdy5sZW5ndGgtMV07aWYodCYmbS5wYXJlbnM9PT10LnBhcmVucysxKXtleHRnbG9iQ2xvc2Uody5wb3AoKSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6RyxvdXRwdXQ6bS5wYXJlbnM/XCIpXCI6XCJcXFxcKVwifSk7ZGVjcmVtZW50KFwicGFyZW5zXCIpO2NvbnRpbnVlfWlmKEc9PT1cIltcIil7aWYodS5ub2JyYWNrZXQ9PT10cnVlfHwhcmVtYWluaW5nKCkuaW5jbHVkZXMoXCJdXCIpKXtpZih1Lm5vYnJhY2tldCE9PXRydWUmJnUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKX1HPWBcXFxcJHtHfWB9ZWxzZXtpbmNyZW1lbnQoXCJicmFja2V0c1wiKX1wdXNoKHt0eXBlOlwiYnJhY2tldFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCJdXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8QiYmQi50eXBlPT09XCJicmFja2V0XCImJkIudmFsdWUubGVuZ3RoPT09MSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9aWYobS5icmFja2V0cz09PTApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXt0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJvcGVuaW5nXCIsXCJbXCIpKX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmBcXFxcJHtHfWB9KTtjb250aW51ZX1kZWNyZW1lbnQoXCJicmFja2V0c1wiKTtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYoQi5wb3NpeCE9PXRydWUmJnRbMF09PT1cIl5cIiYmIXQuaW5jbHVkZXMoXCIvXCIpKXtHPWAvJHtHfWB9Qi52YWx1ZSs9RzthcHBlbmQoe3ZhbHVlOkd9KTtpZih1LmxpdGVyYWxCcmFja2V0cz09PWZhbHNlfHxvLmhhc1JlZ2V4Q2hhcnModCkpe2NvbnRpbnVlfWNvbnN0IGU9by5lc2NhcGVSZWdleChCLnZhbHVlKTttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLnZhbHVlLmxlbmd0aCk7aWYodS5saXRlcmFsQnJhY2tldHM9PT10cnVlKXttLm91dHB1dCs9ZTtCLnZhbHVlPWU7Y29udGludWV9Qi52YWx1ZT1gKCR7X30ke2V9fCR7Qi52YWx1ZX0pYDttLm91dHB1dCs9Qi52YWx1ZTtjb250aW51ZX1pZihHPT09XCJ7XCImJnUubm9icmFjZSE9PXRydWUpe2luY3JlbWVudChcImJyYWNlc1wiKTtjb25zdCB0PXt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDpcIihcIixvdXRwdXRJbmRleDptLm91dHB1dC5sZW5ndGgsdG9rZW5zSW5kZXg6bS50b2tlbnMubGVuZ3RofTtOLnB1c2godCk7cHVzaCh0KTtjb250aW51ZX1pZihHPT09XCJ9XCIpe2NvbnN0IHQ9TltOLmxlbmd0aC0xXTtpZih1Lm5vYnJhY2U9PT10cnVlfHwhdCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpHfSk7Y29udGludWV9bGV0IGU9XCIpXCI7aWYodC5kb3RzPT09dHJ1ZSl7Y29uc3QgdD1BLnNsaWNlKCk7Y29uc3Qgbj1bXTtmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7QS5wb3AoKTtpZih0W2VdLnR5cGU9PT1cImJyYWNlXCIpe2JyZWFrfWlmKHRbZV0udHlwZSE9PVwiZG90c1wiKXtuLnVuc2hpZnQodFtlXS52YWx1ZSl9fWU9ZXhwYW5kUmFuZ2Uobix1KTttLmJhY2t0cmFjaz10cnVlfWlmKHQuY29tbWEhPT10cnVlJiZ0LmRvdHMhPT10cnVlKXtjb25zdCB1PW0ub3V0cHV0LnNsaWNlKDAsdC5vdXRwdXRJbmRleCk7Y29uc3Qgbj1tLnRva2Vucy5zbGljZSh0LnRva2Vuc0luZGV4KTt0LnZhbHVlPXQub3V0cHV0PVwiXFxcXHtcIjtHPWU9XCJcXFxcfVwiO20ub3V0cHV0PXU7Zm9yKGNvbnN0IHQgb2Ygbil7bS5vdXRwdXQrPXQub3V0cHV0fHx0LnZhbHVlfX1wdXNoKHt0eXBlOlwiYnJhY2VcIix2YWx1ZTpHLG91dHB1dDplfSk7ZGVjcmVtZW50KFwiYnJhY2VzXCIpO04ucG9wKCk7Y29udGludWV9aWYoRz09PVwifFwiKXtpZih3Lmxlbmd0aD4wKXt3W3cubGVuZ3RoLTFdLmNvbmRpdGlvbnMrK31wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHPT09XCIsXCIpe2xldCB0PUc7Y29uc3QgZT1OW04ubGVuZ3RoLTFdO2lmKGUmJklbSS5sZW5ndGgtMV09PT1cImJyYWNlc1wiKXtlLmNvbW1hPXRydWU7dD1cInxcIn1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTpHLG91dHB1dDp0fSk7Y29udGludWV9aWYoRz09PVwiL1wiKXtpZihCLnR5cGU9PT1cImRvdFwiJiZtLmluZGV4PT09bS5zdGFydCsxKXttLnN0YXJ0PW0uaW5kZXgrMTttLmNvbnN1bWVkPVwiXCI7bS5vdXRwdXQ9XCJcIjtBLnBvcCgpO0I9Zjtjb250aW51ZX1wdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpHLG91dHB1dDpifSk7Y29udGludWV9aWYoRz09PVwiLlwiKXtpZihtLmJyYWNlcz4wJiZCLnR5cGU9PT1cImRvdFwiKXtpZihCLnZhbHVlPT09XCIuXCIpQi5vdXRwdXQ9aDtjb25zdCB0PU5bTi5sZW5ndGgtMV07Qi50eXBlPVwiZG90c1wiO0Iub3V0cHV0Kz1HO0IudmFsdWUrPUc7dC5kb3RzPXRydWU7Y29udGludWV9aWYobS5icmFjZXMrbS5wYXJlbnM9PT0wJiZCLnR5cGUhPT1cImJvc1wiJiZCLnR5cGUhPT1cInNsYXNoXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJkb3RcIix2YWx1ZTpHLG91dHB1dDpofSk7Y29udGludWV9aWYoRz09PVwiP1wiKXtjb25zdCB0PUImJkIudmFsdWU9PT1cIihcIjtpZighdCYmdS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIiYmRCgyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInFtYXJrXCIsRyk7Y29udGludWV9aWYoQiYmQi50eXBlPT09XCJwYXJlblwiKXtjb25zdCB0PUQoKTtsZXQgZT1HO2lmKEIudmFsdWU9PT1cIihcIiYmIS9bIT08Ol0vLnRlc3QodCl8fHQ9PT1cIjxcIiYmIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSl7ZT1gXFxcXCR7R31gfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2NvbnRpbnVlfWlmKHUuZG90IT09dHJ1ZSYmKEIudHlwZT09PVwic2xhc2hcInx8Qi50eXBlPT09XCJib3NcIikpe3B1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkcsb3V0cHV0OnZ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDpIfSk7Y29udGludWV9aWYoRz09PVwiIVwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiKXtpZihEKDIpIT09XCI/XCJ8fCEvWyE9PDpdLy50ZXN0KEQoMykpKXtleHRnbG9iT3BlbihcIm5lZ2F0ZVwiLEcpO2NvbnRpbnVlfX1pZih1Lm5vbmVnYXRlIT09dHJ1ZSYmbS5pbmRleD09PTApe25lZ2F0ZSgpO2NvbnRpbnVlfX1pZihHPT09XCIrXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJwbHVzXCIsRyk7Y29udGludWV9aWYoQiYmQi52YWx1ZT09PVwiKFwifHx1LnJlZ2V4PT09ZmFsc2Upe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6RyxvdXRwdXQ6Z30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwifHxCLnR5cGU9PT1cImJyYWNlXCIpfHxtLnBhcmVucz4wKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkd9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOmd9KTtjb250aW51ZX1pZihHPT09XCJAXCIpe2lmKHUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7cHVzaCh7dHlwZTpcImF0XCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1pZihHIT09XCIqXCIpe2lmKEc9PT1cIiRcInx8Rz09PVwiXlwiKXtHPWBcXFxcJHtHfWB9Y29uc3QgdD1hLmV4ZWMocmVtYWluaW5nKCkpO2lmKHQpe0crPXRbMF07bS5pbmRleCs9dFswXS5sZW5ndGh9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiZ2xvYnN0YXJcInx8Qi5zdGFyPT09dHJ1ZSkpe0IudHlwZT1cInN0YXJcIjtCLnN0YXI9dHJ1ZTtCLnZhbHVlKz1HO0Iub3V0cHV0PWs7bS5iYWNrdHJhY2s9dHJ1ZTttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1sZXQgZT1yZW1haW5pbmcoKTtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJi9eXFwoW14/XS8udGVzdChlKSl7ZXh0Z2xvYk9wZW4oXCJzdGFyXCIsRyk7Y29udGludWV9aWYoQi50eXBlPT09XCJzdGFyXCIpe2lmKHUubm9nbG9ic3Rhcj09PXRydWUpe2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj1CLnByZXY7Y29uc3Qgbz1uLnByZXY7Y29uc3Qgcz1uLnR5cGU9PT1cInNsYXNoXCJ8fG4udHlwZT09PVwiYm9zXCI7Y29uc3Qgcj1vJiYoby50eXBlPT09XCJzdGFyXCJ8fG8udHlwZT09PVwiZ2xvYnN0YXJcIik7aWYodS5iYXNoPT09dHJ1ZSYmKCFzfHxlWzBdJiZlWzBdIT09XCIvXCIpKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1jb25zdCBhPW0uYnJhY2VzPjAmJihuLnR5cGU9PT1cImNvbW1hXCJ8fG4udHlwZT09PVwiYnJhY2VcIik7Y29uc3QgaT13Lmxlbmd0aCYmKG4udHlwZT09PVwicGlwZVwifHxuLnR5cGU9PT1cInBhcmVuXCIpO2lmKCFzJiZuLnR5cGUhPT1cInBhcmVuXCImJiFhJiYhaSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9d2hpbGUoZS5zbGljZSgwLDMpPT09XCIvKipcIil7Y29uc3QgdT10W20uaW5kZXgrNF07aWYodSYmdSE9PVwiL1wiKXticmVha31lPWUuc2xpY2UoMyk7Y29uc3VtZShcIi8qKlwiLDMpfWlmKG4udHlwZT09PVwiYm9zXCImJmVvcygpKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7bS5vdXRwdXQ9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJiFyJiZlb3MoKSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KSsodS5zdHJpY3RTbGFzaGVzP1wiKVwiOlwifCQpXCIpO0IudmFsdWUrPUc7bS5nbG9ic3Rhcj10cnVlO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe2NvbnN0IHQ9ZVsxXSE9PXZvaWQgMD9cInwkXCI6XCJcIjttLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrQi5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtCLnR5cGU9XCJnbG9ic3RhclwiO0Iub3V0cHV0PWAke2dsb2JzdGFyKHUpfSR7Yn18JHtifSR7dH0pYDtCLnZhbHVlKz1HO20ub3V0cHV0Kz1uLm91dHB1dCtCLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1pZihuLnR5cGU9PT1cImJvc1wiJiZlWzBdPT09XCIvXCIpe0IudHlwZT1cImdsb2JzdGFyXCI7Qi52YWx1ZSs9RztCLm91dHB1dD1gKD86Xnwke2J9fCR7Z2xvYnN0YXIodSl9JHtifSlgO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcrTSgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfW0ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLUIub3V0cHV0Lmxlbmd0aCk7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1nbG9ic3Rhcih1KTtCLnZhbHVlKz1HO20ub3V0cHV0Kz1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHKTtjb250aW51ZX1jb25zdCBuPXt0eXBlOlwic3RhclwiLHZhbHVlOkcsb3V0cHV0Omt9O2lmKHUuYmFzaD09PXRydWUpe24ub3V0cHV0PVwiLio/XCI7aWYoQi50eXBlPT09XCJib3NcInx8Qi50eXBlPT09XCJzbGFzaFwiKXtuLm91dHB1dD1UK24ub3V0cHV0fXB1c2gobik7Y29udGludWV9aWYoQiYmKEIudHlwZT09PVwiYnJhY2tldFwifHxCLnR5cGU9PT1cInBhcmVuXCIpJiZ1LnJlZ2V4PT09dHJ1ZSl7bi5vdXRwdXQ9RztwdXNoKG4pO2NvbnRpbnVlfWlmKG0uaW5kZXg9PT1tLnN0YXJ0fHxCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiZG90XCIpe2lmKEIudHlwZT09PVwiZG90XCIpe20ub3V0cHV0Kz14O0Iub3V0cHV0Kz14fWVsc2UgaWYodS5kb3Q9PT10cnVlKXttLm91dHB1dCs9UztCLm91dHB1dCs9U31lbHNle20ub3V0cHV0Kz1UO0Iub3V0cHV0Kz1UfWlmKEQoKSE9PVwiKlwiKXttLm91dHB1dCs9QztCLm91dHB1dCs9Q319cHVzaChuKX13aGlsZShtLmJyYWNrZXRzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIltcIik7ZGVjcmVtZW50KFwiYnJhY2tldHNcIil9d2hpbGUobS5wYXJlbnM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiKVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwiKFwiKTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9d2hpbGUobS5icmFjZXM+MCl7aWYodS5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwifVwiKSk7bS5vdXRwdXQ9by5lc2NhcGVMYXN0KG0ub3V0cHV0LFwie1wiKTtkZWNyZW1lbnQoXCJicmFjZXNcIil9aWYodS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSYmKEIudHlwZT09PVwic3RhclwifHxCLnR5cGU9PT1cImJyYWNrZXRcIikpe3B1c2goe3R5cGU6XCJtYXliZV9zbGFzaFwiLHZhbHVlOlwiXCIsb3V0cHV0OmAke2J9P2B9KX1pZihtLmJhY2t0cmFjaz09PXRydWUpe20ub3V0cHV0PVwiXCI7Zm9yKGNvbnN0IHQgb2YgbS50b2tlbnMpe20ub3V0cHV0Kz10Lm91dHB1dCE9bnVsbD90Lm91dHB1dDp0LnZhbHVlO2lmKHQuc3VmZml4KXttLm91dHB1dCs9dC5zdWZmaXh9fX1yZXR1cm4gbX07cGFyc2UuZmFzdHBhdGhzPSh0LGUpPT57Y29uc3QgdT17Li4uZX07Y29uc3Qgcj10eXBlb2YgdS5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsdS5tYXhMZW5ndGgpOnM7Y29uc3QgYT10Lmxlbmd0aDtpZihhPnIpe3Rocm93IG5ldyBTeW50YXhFcnJvcihgSW5wdXQgbGVuZ3RoOiAke2F9LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7cn1gKX10PWNbdF18fHQ7Y29uc3R7RE9UX0xJVEVSQUw6aSxTTEFTSF9MSVRFUkFMOnAsT05FX0NIQVI6bCxET1RTX1NMQVNIOmYsTk9fRE9UOkEsTk9fRE9UUzpfLE5PX0RPVFNfU0xBU0g6UixTVEFSOkUsU1RBUlRfQU5DSE9SOmh9PW4uZ2xvYkNoYXJzKHUud2luZG93cyk7Y29uc3QgZz11LmRvdD9fOkE7Y29uc3QgYj11LmRvdD9SOkE7Y29uc3QgQz11LmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgeT17bmVnYXRlZDpmYWxzZSxwcmVmaXg6XCJcIn07bGV0ICQ9dS5iYXNoPT09dHJ1ZT9cIi4qP1wiOkU7aWYodS5jYXB0dXJlKXskPWAoJHskfSlgfWNvbnN0IGdsb2JzdGFyPXQ9PntpZih0Lm5vZ2xvYnN0YXI9PT10cnVlKXJldHVybiAkO3JldHVybmAoJHtDfSg/Oig/ISR7aH0ke3QuZG90P2Y6aX0pLikqPylgfTtjb25zdCBjcmVhdGU9dD0+e3N3aXRjaCh0KXtjYXNlXCIqXCI6cmV0dXJuYCR7Z30ke2x9JHskfWA7Y2FzZVwiLipcIjpyZXR1cm5gJHtpfSR7bH0keyR9YDtjYXNlXCIqLipcIjpyZXR1cm5gJHtnfSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIiovKlwiOnJldHVybmAke2d9JHskfSR7cH0ke2x9JHtifSR7JH1gO2Nhc2VcIioqXCI6cmV0dXJuIGcrZ2xvYnN0YXIodSk7Y2FzZVwiKiovKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHtsfSR7JH1gO2Nhc2VcIioqLyouKlwiOnJldHVybmAoPzoke2d9JHtnbG9ic3Rhcih1KX0ke3B9KT8ke2J9JHskfSR7aX0ke2x9JHskfWA7Y2FzZVwiKiovLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtpfSR7bH0keyR9YDtkZWZhdWx0Ontjb25zdCBlPS9eKC4qPylcXC4oXFx3KykkLy5leGVjKHQpO2lmKCFlKXJldHVybjtjb25zdCB1PWNyZWF0ZShlWzFdKTtpZighdSlyZXR1cm47cmV0dXJuIHUraStlWzJdfX19O2NvbnN0IHg9by5yZW1vdmVQcmVmaXgodCx5KTtsZXQgUz1jcmVhdGUoeCk7aWYoUyYmdS5zdHJpY3RTbGFzaGVzIT09dHJ1ZSl7Uys9YCR7cH0/YH1yZXR1cm4gU307dC5leHBvcnRzPXBhcnNlfSw1MTA6KHQsZSx1KT0+e2NvbnN0IG49dSg3MTYpO2NvbnN0IG89dSg2OTcpO2NvbnN0IHM9dSg5Nik7Y29uc3Qgcj11KDE1NCk7Y29uc3QgaXNPYmplY3Q9dD0+dCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtjb25zdCBwaWNvbWF0Y2g9KHQsZSx1PWZhbHNlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpe2NvbnN0IG49dC5tYXAoKHQ9PnBpY29tYXRjaCh0LGUsdSkpKTtjb25zdCBhcnJheU1hdGNoZXI9dD0+e2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IHU9ZSh0KTtpZih1KXJldHVybiB1fXJldHVybiBmYWxzZX07cmV0dXJuIGFycmF5TWF0Y2hlcn1jb25zdCBuPWlzT2JqZWN0KHQpJiZ0LnRva2VucyYmdC5pbnB1dDtpZih0PT09XCJcInx8dHlwZW9mIHQhPT1cInN0cmluZ1wiJiYhbil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHBhdHRlcm4gdG8gYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLndpbmRvd3M7Y29uc3Qgcj1uP3BpY29tYXRjaC5jb21waWxlUmUodCxlKTpwaWNvbWF0Y2gubWFrZVJlKHQsZSxmYWxzZSx0cnVlKTtjb25zdCBhPXIuc3RhdGU7ZGVsZXRlIHIuc3RhdGU7bGV0IGlzSWdub3JlZD0oKT0+ZmFsc2U7aWYoby5pZ25vcmUpe2NvbnN0IHQ9ey4uLmUsaWdub3JlOm51bGwsb25NYXRjaDpudWxsLG9uUmVzdWx0Om51bGx9O2lzSWdub3JlZD1waWNvbWF0Y2goby5pZ25vcmUsdCx1KX1jb25zdCBtYXRjaGVyPSh1LG49ZmFsc2UpPT57Y29uc3R7aXNNYXRjaDppLG1hdGNoOmMsb3V0cHV0OnB9PXBpY29tYXRjaC50ZXN0KHUscixlLHtnbG9iOnQscG9zaXg6c30pO2NvbnN0IGw9e2dsb2I6dCxzdGF0ZTphLHJlZ2V4OnIscG9zaXg6cyxpbnB1dDp1LG91dHB1dDpwLG1hdGNoOmMsaXNNYXRjaDppfTtpZih0eXBlb2Ygby5vblJlc3VsdD09PVwiZnVuY3Rpb25cIil7by5vblJlc3VsdChsKX1pZihpPT09ZmFsc2Upe2wuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKGlzSWdub3JlZCh1KSl7aWYodHlwZW9mIG8ub25JZ25vcmU9PT1cImZ1bmN0aW9uXCIpe28ub25JZ25vcmUobCl9bC5pc01hdGNoPWZhbHNlO3JldHVybiBuP2w6ZmFsc2V9aWYodHlwZW9mIG8ub25NYXRjaD09PVwiZnVuY3Rpb25cIil7by5vbk1hdGNoKGwpfXJldHVybiBuP2w6dHJ1ZX07aWYodSl7bWF0Y2hlci5zdGF0ZT1hfXJldHVybiBtYXRjaGVyfTtwaWNvbWF0Y2gudGVzdD0odCxlLHUse2dsb2I6bixwb3NpeDpvfT17fSk9PntpZih0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCB0byBiZSBhIHN0cmluZ1wiKX1pZih0PT09XCJcIil7cmV0dXJue2lzTWF0Y2g6ZmFsc2Usb3V0cHV0OlwiXCJ9fWNvbnN0IHI9dXx8e307Y29uc3QgYT1yLmZvcm1hdHx8KG8/cy50b1Bvc2l4U2xhc2hlczpudWxsKTtsZXQgaT10PT09bjtsZXQgYz1pJiZhP2EodCk6dDtpZihpPT09ZmFsc2Upe2M9YT9hKHQpOnQ7aT1jPT09bn1pZihpPT09ZmFsc2V8fHIuY2FwdHVyZT09PXRydWUpe2lmKHIubWF0Y2hCYXNlPT09dHJ1ZXx8ci5iYXNlbmFtZT09PXRydWUpe2k9cGljb21hdGNoLm1hdGNoQmFzZSh0LGUsdSxvKX1lbHNle2k9ZS5leGVjKGMpfX1yZXR1cm57aXNNYXRjaDpCb29sZWFuKGkpLG1hdGNoOmksb3V0cHV0OmN9fTtwaWNvbWF0Y2gubWF0Y2hCYXNlPSh0LGUsdSk9Pntjb25zdCBuPWUgaW5zdGFuY2VvZiBSZWdFeHA/ZTpwaWNvbWF0Y2gubWFrZVJlKGUsdSk7cmV0dXJuIG4udGVzdChzLmJhc2VuYW1lKHQpKX07cGljb21hdGNoLmlzTWF0Y2g9KHQsZSx1KT0+cGljb21hdGNoKGUsdSkodCk7cGljb21hdGNoLnBhcnNlPSh0LGUpPT57aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdC5tYXAoKHQ9PnBpY29tYXRjaC5wYXJzZSh0LGUpKSk7cmV0dXJuIG8odCx7Li4uZSxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KHQsZSk9Pm4odCxlKTtwaWNvbWF0Y2guY29tcGlsZVJlPSh0LGUsdT1mYWxzZSxuPWZhbHNlKT0+e2lmKHU9PT10cnVlKXtyZXR1cm4gdC5vdXRwdXR9Y29uc3Qgbz1lfHx7fTtjb25zdCBzPW8uY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCByPW8uY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgYT1gJHtzfSg/OiR7dC5vdXRwdXR9KSR7cn1gO2lmKHQmJnQubmVnYXRlZD09PXRydWUpe2E9YF4oPyEke2F9KS4qJGB9Y29uc3QgaT1waWNvbWF0Y2gudG9SZWdleChhLGUpO2lmKG49PT10cnVlKXtpLnN0YXRlPXR9cmV0dXJuIGl9O3BpY29tYXRjaC5tYWtlUmU9KHQsZT17fSx1PWZhbHNlLG49ZmFsc2UpPT57aWYoIXR8fHR5cGVvZiB0IT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1sZXQgcz17bmVnYXRlZDpmYWxzZSxmYXN0cGF0aHM6dHJ1ZX07aWYoZS5mYXN0cGF0aHMhPT1mYWxzZSYmKHRbMF09PT1cIi5cInx8dFswXT09PVwiKlwiKSl7cy5vdXRwdXQ9by5mYXN0cGF0aHModCxlKX1pZighcy5vdXRwdXQpe3M9byh0LGUpfXJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHMsZSx1LG4pfTtwaWNvbWF0Y2gudG9SZWdleD0odCxlKT0+e3RyeXtjb25zdCB1PWV8fHt9O3JldHVybiBuZXcgUmVnRXhwKHQsdS5mbGFnc3x8KHUubm9jYXNlP1wiaVwiOlwiXCIpKX1jYXRjaCh0KXtpZihlJiZlLmRlYnVnPT09dHJ1ZSl0aHJvdyB0O3JldHVybi8kXi99fTtwaWNvbWF0Y2guY29uc3RhbnRzPXI7dC5leHBvcnRzPXBpY29tYXRjaH0sNzE2Oih0LGUsdSk9Pntjb25zdCBuPXUoOTYpO2NvbnN0e0NIQVJfQVNURVJJU0s6byxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpyLENIQVJfQ09NTUE6YSxDSEFSX0RPVDppLENIQVJfRVhDTEFNQVRJT05fTUFSSzpjLENIQVJfRk9SV0FSRF9TTEFTSDpwLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpsLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpfLENIQVJfUVVFU1RJT05fTUFSSzpSLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6RSxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmgsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpnfT11KDE1NCk7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPXQ9PnQ9PT1wfHx0PT09cjtjb25zdCBkZXB0aD10PT57aWYodC5pc1ByZWZpeCE9PXRydWUpe3QuZGVwdGg9dC5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPSh0LGUpPT57Y29uc3QgdT1lfHx7fTtjb25zdCBiPXQubGVuZ3RoLTE7Y29uc3QgQz11LnBhcnRzPT09dHJ1ZXx8dS5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IHk9W107Y29uc3QgJD1bXTtjb25zdCB4PVtdO2xldCBTPXQ7bGV0IEg9LTE7bGV0IHY9MDtsZXQgZD0wO2xldCBMPWZhbHNlO2xldCBUPWZhbHNlO2xldCBPPWZhbHNlO2xldCBrPWZhbHNlO2xldCBtPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBJPWZhbHNlO2xldCBCPWZhbHNlO2xldCBHPWZhbHNlO2xldCBEPTA7bGV0IE07bGV0IFA7bGV0IEs9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Yjtjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57TT1QO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxiKXtQPWFkdmFuY2UoKTtsZXQgdDtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7aWYoUD09PWwpe3c9dHJ1ZX1jb250aW51ZX1pZih3PT09dHJ1ZXx8UD09PWwpe0QrKzt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWwpe0QrKztjb250aW51ZX1pZih3IT09dHJ1ZSYmUD09PWkmJihQPWFkdmFuY2UoKSk9PT1pKXtMPUsuaXNCcmFjZT10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHchPT10cnVlJiZQPT09YSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09RSl7RC0tO2lmKEQ9PT0wKXt3PWZhbHNlO0w9Sy5pc0JyYWNlPXRydWU7Rz10cnVlO2JyZWFrfX19aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1wKXt5LnB1c2goSCk7JC5wdXNoKEspO0s9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKEc9PT10cnVlKWNvbnRpbnVlO2lmKE09PT1pJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfWQ9SCsxO2NvbnRpbnVlfWlmKHUubm9leHQhPT10cnVlKXtjb25zdCB0PVA9PT1ffHxQPT09c3x8UD09PW98fFA9PT1SfHxQPT09YztpZih0PT09dHJ1ZSYmcGVlaygpPT09Zil7Tz1LLmlzR2xvYj10cnVlO2s9Sy5pc0V4dGdsb2I9dHJ1ZTtHPXRydWU7aWYoUD09PWMmJkg9PT12KXtCPXRydWV9aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoUD09PW8pe2lmKE09PT1vKW09Sy5pc0dsb2JzdGFyPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PVIpe089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJih0PWFkdmFuY2UoKSkpe2lmKHQ9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYodD09PWcpe1Q9Sy5pc0JyYWNrZXQ9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2JyZWFrfX1pZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYodS5ub25lZ2F0ZSE9PXRydWUmJlA9PT1jJiZIPT09dil7ST1LLm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYodS5ub3BhcmVuIT09dHJ1ZSYmUD09PWYpe089Sy5pc0dsb2I9dHJ1ZTtpZihDPT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09Zil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7UD1hZHZhbmNlKCk7Y29udGludWV9aWYoUD09PWgpe0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTz09PXRydWUpe0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHUubm9leHQ9PT10cnVlKXtrPWZhbHNlO089ZmFsc2V9bGV0IFU9UztsZXQgWD1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtYPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7ZC09dn1pZihVJiZPPT09dHJ1ZSYmZD4wKXtVPVMuc2xpY2UoMCxkKTtGPVMuc2xpY2UoZCl9ZWxzZSBpZihPPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYodS51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJk49PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpYLGlucHV0OnQsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6TCxpc0JyYWNrZXQ6VCxpc0dsb2I6Tyxpc0V4dGdsb2I6ayxpc0dsb2JzdGFyOm0sbmVnYXRlZDpJLG5lZ2F0ZWRFeHRnbG9iOkJ9O2lmKHUudG9rZW5zPT09dHJ1ZSl7US5tYXhEZXB0aD0wO2lmKCFpc1BhdGhTZXBhcmF0b3IoUCkpeyQucHVzaChLKX1RLnRva2Vucz0kfWlmKHUucGFydHM9PT10cnVlfHx1LnRva2Vucz09PXRydWUpe2xldCBlO2ZvcihsZXQgbj0wO248eS5sZW5ndGg7bisrKXtjb25zdCBvPWU/ZSsxOnY7Y29uc3Qgcz15W25dO2NvbnN0IHI9dC5zbGljZShvLHMpO2lmKHUudG9rZW5zKXtpZihuPT09MCYmdiE9PTApeyRbbl0uaXNQcmVmaXg9dHJ1ZTskW25dLnZhbHVlPVh9ZWxzZXskW25dLnZhbHVlPXJ9ZGVwdGgoJFtuXSk7US5tYXhEZXB0aCs9JFtuXS5kZXB0aH1pZihuIT09MHx8ciE9PVwiXCIpe3gucHVzaChyKX1lPXN9aWYoZSYmZSsxPHQubGVuZ3RoKXtjb25zdCBuPXQuc2xpY2UoZSsxKTt4LnB1c2gobik7aWYodS50b2tlbnMpeyRbJC5sZW5ndGgtMV0udmFsdWU9bjtkZXB0aCgkWyQubGVuZ3RoLTFdKTtRLm1heERlcHRoKz0kWyQubGVuZ3RoLTFdLmRlcHRofX1RLnNsYXNoZXM9eTtRLnBhcnRzPXh9cmV0dXJuIFF9O3QuZXhwb3J0cz1zY2FufSw5NjoodCxlLHUpPT57Y29uc3R7UkVHRVhfQkFDS1NMQVNIOm4sUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSDpvLFJFR0VYX1NQRUNJQUxfQ0hBUlM6cyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDpyfT11KDE1NCk7ZS5pc09iamVjdD10PT50IT09bnVsbCYmdHlwZW9mIHQ9PT1cIm9iamVjdFwiJiYhQXJyYXkuaXNBcnJheSh0KTtlLmhhc1JlZ2V4Q2hhcnM9dD0+cy50ZXN0KHQpO2UuaXNSZWdleENoYXI9dD0+dC5sZW5ndGg9PT0xJiZlLmhhc1JlZ2V4Q2hhcnModCk7ZS5lc2NhcGVSZWdleD10PT50LnJlcGxhY2UocixcIlxcXFwkMVwiKTtlLnRvUG9zaXhTbGFzaGVzPXQ9PnQucmVwbGFjZShuLFwiL1wiKTtlLnJlbW92ZUJhY2tzbGFzaGVzPXQ9PnQucmVwbGFjZShvLCh0PT50PT09XCJcXFxcXCI/XCJcIjp0KSk7ZS5lc2NhcGVMYXN0PSh0LHUsbik9Pntjb25zdCBvPXQubGFzdEluZGV4T2YodSxuKTtpZihvPT09LTEpcmV0dXJuIHQ7aWYodFtvLTFdPT09XCJcXFxcXCIpcmV0dXJuIGUuZXNjYXBlTGFzdCh0LHUsby0xKTtyZXR1cm5gJHt0LnNsaWNlKDAsbyl9XFxcXCR7dC5zbGljZShvKX1gfTtlLnJlbW92ZVByZWZpeD0odCxlPXt9KT0+e2xldCB1PXQ7aWYodS5zdGFydHNXaXRoKFwiLi9cIikpe3U9dS5zbGljZSgyKTtlLnByZWZpeD1cIi4vXCJ9cmV0dXJuIHV9O2Uud3JhcE91dHB1dD0odCxlPXt9LHU9e30pPT57Y29uc3Qgbj11LmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgbz11LmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IHM9YCR7bn0oPzoke3R9KSR7b31gO2lmKGUubmVnYXRlZD09PXRydWUpe3M9YCg/Ol4oPyEke3N9KS4qJClgfXJldHVybiBzfTtlLmJhc2VuYW1lPSh0LHt3aW5kb3dzOmV9PXt9KT0+e2NvbnN0IHU9dC5zcGxpdChlPy9bXFxcXC9dLzpcIi9cIik7Y29uc3Qgbj11W3UubGVuZ3RoLTFdO2lmKG49PT1cIlwiKXtyZXR1cm4gdVt1Lmxlbmd0aC0yXX1yZXR1cm4gbn19fTt2YXIgZT17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHUpe3ZhciBuPWVbdV07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgbz1lW3VdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXt0W3VdKG8sby5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSBlW3VdfXJldHVybiBvLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB1PV9fbmNjd3Bja19yZXF1aXJlX18oMTcwKTttb2R1bGUuZXhwb3J0cz11fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz8xYmYyIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/Map.tsx":
/*!****************************!*\
  !*** ./components/Map.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-google-maps/api */ \"(app-pages-browser)/./node_modules/@react-google-maps/api/dist/esm.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst containerStyle = {\n    width: \"100%\",\n    height: \"100%\",\n    borderRadius: \"10px\",\n    padding: \"10.5rem\"\n};\nfunction map(data) {\n    _s();\n    const center = {\n        lat: Number(\"48.198279\"),\n        lng: Number(\"-114.307425\")\n    };\n    const { isLoaded } = (0,_react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.useJsApiLoader)({\n        id: \"google-map-script\",\n        googleMapsApiKey: \"\".concat(\"AIzaSyC8vDVz-yGJ1UNBKSsj0idBT6uqbfnGcJo\")\n    });\n    const [map, setMap] = react__WEBPACK_IMPORTED_MODULE_1___default().useState(null);\n    const onLoad = react__WEBPACK_IMPORTED_MODULE_1___default().useCallback(function callback(map) {\n        // This is just an example of getting and using the map instance!!! don't just blindly copy!\n        const bounds = new window.google.maps.LatLngBounds(center);\n        map.fitBounds(bounds);\n        setMap(map);\n    }, []);\n    const onUnmount = react__WEBPACK_IMPORTED_MODULE_1___default().useCallback(function callback(map) {\n        setMap(null);\n    }, []);\n    return isLoaded ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.GoogleMap, {\n        mapContainerStyle: containerStyle,\n        center: center,\n        zoom: 10,\n        onLoad: onLoad,\n        onUnmount: onUnmount,\n        options: {\n            streetViewControl: false,\n            mapTypeControl: false,\n            center: center\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.MarkerF, {\n                position: center\n            }, void 0, false, {\n                fileName: \"/Users/michaeldreesen/Documents/Programming/business-projects/perrigo-insurance/components/Map.tsx\",\n                lineNumber: 52,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/michaeldreesen/Documents/Programming/business-projects/perrigo-insurance/components/Map.tsx\",\n        lineNumber: 39,\n        columnNumber: 7\n    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n}\n_s(map, \"sc/DS85Udqb0HC94DVNruSImuio=\", false, function() {\n    return [\n        _react_google_maps_api__WEBPACK_IMPORTED_MODULE_2__.useJsApiLoader\n    ];\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().memo(map));\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFwLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQzBCO0FBQ2tEO0FBRTVFLE1BQU1JLGlCQUFpQjtJQUNyQkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLGNBQWM7SUFDZEMsU0FBUztBQUNYO0FBRUEsU0FBU0MsSUFBSUMsSUFBUzs7SUFFcEIsTUFBTUMsU0FBUztRQUNiQyxLQUFLQyxPQUFPO1FBQ1pDLEtBQUtELE9BQU87SUFDZDtJQUVBLE1BQU0sRUFBRUUsUUFBUSxFQUFFLEdBQUdiLHNFQUFjQSxDQUFDO1FBQ2xDYyxJQUFJO1FBQ0pDLGtCQUFrQixHQUErQyxPQUE1Q0MseUNBQTJDO0lBQ2xFO0lBRUEsTUFBTSxDQUFDVCxLQUFLWSxPQUFPLEdBQUdyQixxREFBYyxDQUFDO0lBRXJDLE1BQU11QixTQUFTdkIsd0RBQWlCLENBQUMsU0FBU3lCLFNBQVNoQixHQUFRO1FBQ3pELDRGQUE0RjtRQUM1RixNQUFNaUIsU0FBUyxJQUFJQyxPQUFPQyxNQUFNLENBQUNDLElBQUksQ0FBQ0MsWUFBWSxDQUFDbkI7UUFDbkRGLElBQUlzQixTQUFTLENBQUNMO1FBRWRMLE9BQU9aO0lBQ1QsR0FBRyxFQUFFO0lBRUwsTUFBTXVCLFlBQVloQyx3REFBaUIsQ0FBQyxTQUFTeUIsU0FBU2hCLEdBQVE7UUFDNURZLE9BQU87SUFDVCxHQUFHLEVBQUU7SUFFTCxPQUFPTix5QkFDSCw4REFBQ2QsNkRBQVNBO1FBQ1JnQyxtQkFBbUI3QjtRQUNuQk8sUUFBUUE7UUFDUnVCLE1BQU07UUFDTlgsUUFBUUE7UUFDUlMsV0FBV0E7UUFDWEcsU0FBUztZQUNQQyxtQkFBbUI7WUFDbkJDLGdCQUFnQjtZQUNoQjFCLFFBQVFBO1FBQ1Y7OzBCQUdBLDhEQUFDUiwyREFBT0E7Z0JBQUNtQyxVQUFVM0I7Ozs7OzswQkFDbkI7Ozs7Ozs2QkFFRjtBQUNOO0dBNUNTRjs7UUFPY1Asa0VBQWNBOzs7QUF1Q3JDLDRFQUFlRixpREFBVSxDQUFDUyxJQUFJQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvTWFwLnRzeD9lZWJmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEdvb2dsZU1hcCwgdXNlSnNBcGlMb2FkZXIsIE1hcmtlckYgfSBmcm9tICdAcmVhY3QtZ29vZ2xlLW1hcHMvYXBpJztcblxuY29uc3QgY29udGFpbmVyU3R5bGUgPSB7XG4gIHdpZHRoOiAnMTAwJScsXG4gIGhlaWdodDogJzEwMCUnLFxuICBib3JkZXJSYWRpdXM6ICcxMHB4JyxcbiAgcGFkZGluZzogXCIxMC41cmVtXCJcbn07XG5cbmZ1bmN0aW9uIG1hcChkYXRhOiBhbnkpIHtcblxuICBjb25zdCBjZW50ZXIgPSB7XG4gICAgbGF0OiBOdW1iZXIoJzQ4LjE5ODI3OScpLFxuICAgIGxuZzogTnVtYmVyKCctMTE0LjMwNzQyNScpXG4gIH07XG5cbiAgY29uc3QgeyBpc0xvYWRlZCB9ID0gdXNlSnNBcGlMb2FkZXIoe1xuICAgIGlkOiAnZ29vZ2xlLW1hcC1zY3JpcHQnLFxuICAgIGdvb2dsZU1hcHNBcGlLZXk6IGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVl9YFxuICB9KVxuXG4gIGNvbnN0IFttYXAsIHNldE1hcF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcblxuICBjb25zdCBvbkxvYWQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiBjYWxsYmFjayhtYXA6IGFueSkge1xuICAgIC8vIFRoaXMgaXMganVzdCBhbiBleGFtcGxlIG9mIGdldHRpbmcgYW5kIHVzaW5nIHRoZSBtYXAgaW5zdGFuY2UhISEgZG9uJ3QganVzdCBibGluZGx5IGNvcHkhXG4gICAgY29uc3QgYm91bmRzID0gbmV3IHdpbmRvdy5nb29nbGUubWFwcy5MYXRMbmdCb3VuZHMoY2VudGVyKTtcbiAgICBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG5cbiAgICBzZXRNYXAobWFwKVxuICB9LCBbXSlcblxuICBjb25zdCBvblVubW91bnQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiBjYWxsYmFjayhtYXA6IGFueSkge1xuICAgIHNldE1hcChudWxsKVxuICB9LCBbXSlcblxuICByZXR1cm4gaXNMb2FkZWQgPyAoXG4gICAgICA8R29vZ2xlTWFwXG4gICAgICAgIG1hcENvbnRhaW5lclN0eWxlPXtjb250YWluZXJTdHlsZX1cbiAgICAgICAgY2VudGVyPXtjZW50ZXJ9XG4gICAgICAgIHpvb209ezEwfVxuICAgICAgICBvbkxvYWQ9e29uTG9hZH1cbiAgICAgICAgb25Vbm1vdW50PXtvblVubW91bnR9XG4gICAgICAgIG9wdGlvbnM9e3tcbiAgICAgICAgICBzdHJlZXRWaWV3Q29udHJvbDogZmFsc2UsXG4gICAgICAgICAgbWFwVHlwZUNvbnRyb2w6IGZhbHNlLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHsgLyogQ2hpbGQgY29tcG9uZW50cywgc3VjaCBhcyBtYXJrZXJzLCBpbmZvIHdpbmRvd3MsIGV0Yy4gKi8gfVxuICAgICAgICA8TWFya2VyRiBwb3NpdGlvbj17Y2VudGVyfT48L01hcmtlckY+XG4gICAgICAgIDw+PC8+XG4gICAgICA8L0dvb2dsZU1hcD5cbiAgKSA6IDw+PC8+XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8obWFwKSJdLCJuYW1lcyI6WyJSZWFjdCIsIkdvb2dsZU1hcCIsInVzZUpzQXBpTG9hZGVyIiwiTWFya2VyRiIsImNvbnRhaW5lclN0eWxlIiwid2lkdGgiLCJoZWlnaHQiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nIiwibWFwIiwiZGF0YSIsImNlbnRlciIsImxhdCIsIk51bWJlciIsImxuZyIsImlzTG9hZGVkIiwiaWQiLCJnb29nbGVNYXBzQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dPT0dMRV9NQVBTX0FQSV9LRVkiLCJzZXRNYXAiLCJ1c2VTdGF0ZSIsIm9uTG9hZCIsInVzZUNhbGxiYWNrIiwiY2FsbGJhY2siLCJib3VuZHMiLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiTGF0TG5nQm91bmRzIiwiZml0Qm91bmRzIiwib25Vbm1vdW50IiwibWFwQ29udGFpbmVyU3R5bGUiLCJ6b29tIiwib3B0aW9ucyIsInN0cmVldFZpZXdDb250cm9sIiwibWFwVHlwZUNvbnRyb2wiLCJwb3NpdGlvbiIsIm1lbW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/Map.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"addLocale\", ({\n    enumerable: true,\n    get: function() {\n        return addLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2FkZC1sb2NhbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs2Q0FHYUE7OztlQUFBQTs7O29EQUY4QjtBQUVwQyxNQUFNQSxZQUF1QixTQUFDQyxJQUFBQTtxQ0FBU0MsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsSUFBQUEsT0FBQUEsSUFBQUEsSUFBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7UUFBQUEsSUFBQUEsQ0FBQUEsT0FBQUEsRUFBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O0lBQzVDLElBQUlDLEtBQStCLEVBQUUsRUFJckM7SUFDQSxPQUFPRjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L2FkZC1sb2NhbGUudHM/ZmFhZSJdLCJuYW1lcyI6WyJhZGRMb2NhbGUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2dldC1kb21haW4tbG9jYWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBT2dCQTs7O2VBQUFBOzs7b0RBSjJCO0FBRTNDLE1BQU1DLFdBQVdDLE1BQW1DLElBQWU7QUFFNUQsU0FBU0YsZ0JBQ2RLLElBQVksRUFDWkMsTUFBdUIsRUFDdkJDLE9BQWtCLEVBQ2xCQyxhQUE4QjtJQUU5QixJQUFJTixLQUErQixFQUFFLEVBZ0JyQyxNQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUudHM/MWQ0ZSJdLCJuYW1lcyI6WyJnZXREb21haW5Mb2NhbGUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsImxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJyZXF1aXJlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (typeof window === \"undefined\") {\n    globalThis.__NEXT_IMAGE_IMPORTED = true;\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!sizesInput || sizesInput === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === \"100vw\") {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            sizesInput,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OzsrRUFhaUI7cURBQ1dBLENBQUEsQ0FBQUMsbUJBQUFBLENBQUE7eUNBWU87O3lDQUVWQSxtQkFBQUEsQ0FBQTs7O0FBTXpCLE1BQUFDLGVBQUEsY0FBQUMseUJBQTRDSCxDQUFBLENBQUFDLG1CQUFBQSxDQUFBO0FBQzVDLDRDQUE4Qkc7QUFFOUIsTUFBSUMsWUFBT0MsME5BQXdCO0lBQy9CRSxPQUFBQSxXQUFtQkMsYUFBQUE7SUFDdkJELFdBQUFDLHFCQUFBO0FBbUJBO0FBQ0EsMEVBQWlEO0FBQ2pELGlEQUdFQztTQU1BQyxjQUFZQyxHQUFBQSxFQUFBQSxXQUFBQSxFQUFBQSxTQUFRLEVBQUFDLG9CQUFBLEVBQUFDLGVBQUEsRUFBQUMsV0FBQSxFQUFBQyxVQUFBO0lBQ3BCLE1BQUtKLE1BQU9BLE9BQUksZ0JBQWtCQSxJQUFLSyxHQUFBQTtRQUNyQyxDQUFBTCxPQUFBQSxHQUFBLHdCQUFBSyxLQUFBO1FBQ0Y7SUFDQUw7SUFDQUEsR0FBQSxtQkFBc0JBLEdBQUFBO0lBQ3RCTSxNQUFFQyxJQUFNLFlBQWVQLE1BQUFBLElBQUFRLE1BQUEsS0FBQUMsUUFBQUMsT0FBQTtXQUNyQixDQUFJLEtBQUtDLEdBQUFBLElBQUFBLENBQUFBO1lBQ1AsQ0FBQVgsSUFBQVcsYUFBQSxLQUFBWCxJQUFBWSxXQUFBLEVBQXdDO1lBQ3hDLHdDQUF1QjtZQUN2QjtZQUNBLHNDQUFzQjtZQUN0QjtZQUNBO1lBQ0Y7UUFDQTtZQUNFVixnQkFBZ0I7WUFDbEJBLGdCQUFBO1FBQ0E7WUFDRUosYUFBQSxnQkFBQUEsVUFBQWUsT0FBQSxFQUErQztZQUMvQywrQ0FBMEM7WUFDMUM7WUFDQSwyQ0FBd0I7WUFDeEJDLE1BQUFBLFFBQU9DLElBQUFBLE1BQWVDO21CQUFtQkMsY0FBVSxDQUFBRCxPQUFBO2dCQUFPRSxVQUFPbEI7Z0JBQUlrQixPQUFBbEI7WUFDckU7WUFDQSxJQUFJbUIsWUFBVTtZQUNkckIsSUFBQUEsVUFBVWU7c0JBQ0xHLE9BQUs7Z0JBQ1JJLEdBQUFBLEtBQUFBO2dCQUNBQyxhQUFBQTtnQkFDQUMsZUFBUXRCO2dCQUNSdUIsUUFBQUE7Z0JBQ0FDLG9CQUFBQSxJQUFzQkM7Z0JBQ3RCQyxzQkFBZ0IsSUFBQVA7Z0JBQ2hCUSxTQUFBQSxLQUFBQTtnQ0FDYztvQkFDWlgsWUFBTVc7b0JBQ1JYLE1BQUFXLGNBQUE7Z0JBQ0FDO2lDQUNZO29CQUNWWixVQUFNWTtvQkFDUlosTUFBQVksZUFBQTtnQkFDRjtZQUNGO1FBQ0E7WUFDRTNCLHdCQUFxQlksT0FBUWIsS0FBQUEsSUFBQUEscUJBQUFBLE9BQUFBLEVBQUFBO1lBQy9CQyxxQkFBQVksT0FBQSxDQUFBYjtRQUNBO1lBQ0U2QixJQUF3QnhCLEVBQUs7WUFDN0IsTUFBSUwsVUFBSThCLElBQVlDLElBQUMxQixLQUFBLFlBQWlCMkIsWUFBUSxDQUFBQyxHQUFBLFdBQUE1QjtnQkFDNUNMLElBQUk4QixZQUFDM0IsQ0FBQUEsaUJBQWlCQyxRQUFjQTtvQkFDbEMsQ0FBQUQsZUFBSStCLENBQUFBLENBQUFBLGNBQ0VDLGVBQUFBLE9BQXdCQyxHQUFBQTtvQkFDOUIsSUFBSUYscUJBQXFCbEMsSUFBQW1DLHFCQUFLLEdBQUFDLEtBQUEsR0FBQTFDLE9BQUEyQyxVQUFBO3dCQUM1QkgscUJBQW1COzRCQUNqQkksZUFBQUEsU0FDRTs0QkFFSixJQUFPQyxVQUFBRCxRQUFBLHVCQUFBRSxVQUFBOytCQUNMRjs0QkFHRixJQUFBQyxVQUFBRCxRQUFBLHVCQUFBRSxVQUFBO3dCQUNGO29CQUNGO2dCQUNBO29CQUNFeEMsSUFBQVcsYUFBZ0IsRUFBRTtvQkFDbEIsTUFBTThCLEVBQUFBLFFBQVEsS0FBQS9DLE9BQUFnRCxnQkFBQSxDQUFBMUMsSUFBQVcsYUFBQTswQkFBQzhCLFFBQUE7d0JBQVk7d0JBQVM7d0JBQVc7cUJBQy9DO3dCQUNFSCxDQUFBQSxNQUFBQSxRQUFBQSxDQUFBQSxXQUNHO3dCQUlMLElBQUFDLFVBQUFELFFBQUEsdUJBQUFFLFVBQUEsd0VBQUFHLFdBQUEsd0JBQUFGLE1BQUFHLEdBQUEsQ0FBQUMsUUFBQUMsSUFBQTtvQkFDRjtnQkFDQTtvQkFDRVIsSUFBQUEsTUFBQUEsS0FBQUEsR0FBQUE7b0JBR0YsSUFBQUMsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtnQkFDRjtZQUVBO1lBRUEsTUFBTU8saUJBQWdCL0MsSUFBSW9DLE1BQU1ZLENBQUFBLFFBQVEsT0FBT2hELElBQUk4QixZQUFhO1lBQ2hFLE1BQ0dtQixnQkFBa0JqRCxJQUFDK0MsS0FBQUEsQ0FBQUEsUUFDbkIsT0FBQ0UsSUFBQUEsWUFBa0JGLENBQUFBO2dCQUVwQlQsa0JBQUFBLENBQUFBLGlCQUNHLENBQUFXLGtCQUEwQkYsZUFBQTtnQkFFL0IsSUFBQVIsVUFBQUQsUUFBQSx1QkFBQUUsVUFBQTtZQUNGO1FBQ0Y7SUFDRjtBQUVBO1NBR01VLGdCQUFRQyxhQUFNO1FBQ2hCRCxRQUFBRSxPQUFBRCxHQUFBO1FBQ0Esa0RBQWlEO1FBQ2pEO1FBQ0EsbURBQU87ZUFBRUU7WUFBY0E7UUFDekI7SUFDQTtJQUNBLHVEQUE0QztJQUM1Qyw0Q0FBTztXQUFFQztRQUE2QkEsZUFBQUQ7SUFDeEM7QUFFQTtxQkFNTUUsV0FBQUEsR0FBTSxJQUNObkIsT0FDQW9CLFVBQ0FDLEVBQUFBLENBQUFBLE9BQ0FDO0lBaUJGLE1BQUFyRCxHQUFBLEVBQUFzRCxNQUFBLEVBQUFDLEtBQ0UsRUFBQUwsTUFBQSxFQUFBbkIsS0FBQSxFQUFBb0IsUUFBQ3hELEVBQUFBLFNBQUFBLEVBQUFBLEtBQUFBLEVBQUFBLGFBQUFBLEVBQUFBLFdBQUFBLEVBQUFBLE9BQUFBLEVBQUFBLFdBQUFBLEVBQUFBLElBQUFBLEVBQUFBLFNBQUFBLEVBQUFBLG9CQUFBQSxFQUFBQSxlQUFBQSxFQUFBQSxjQUFBQSxFQUFBQSxVQUFBQSxFQUFBQSxNQUFBQSxFQUFBQSxPQUFBQSxFQUFBQSxHQUFBQSxNQUFBQSxHQUFBQTtXQUNTLGtCQUFBOEQsWUFBQUMsR0FBQTtRQUNQLEdBQUdDLElBQUFBO1FBQ0osR0FBQUEsZ0JBQUFYLGNBQUE7UUFDQTtRQUNBLHdFQUFxRDtRQUNyRFkscURBQVNBO1FBQ1Q3QixTQUFPQTtRQUNQbUIsT0FBQUE7UUFDQUMsUUFBQUE7UUFDQVUsVUFBQUE7UUFDQVQsYUFBV0EsT0FBQUEsU0FBQUE7UUFDWEMsV0FBT0E7UUFDUEEsT0FBQUE7UUFDQSx1RUFBbUU7UUFDbkU7UUFDQTtRQUNBLDBFQUEyQjtRQUMzQjtRQUNBRSxzREFBT0E7UUFDUEQsT0FBQUE7UUFDQXRELFFBQUtBO1FBQ0w4RCxLQUFLQzthQUVELElBQUlDLE9BQUFBLFdBQWMsR0FBQXJFO2dCQUNoQnFFLGNBQVdBOzJCQUNGQSxpQkFBT0EsWUFBaUJBLGFBQVVyRTtxQkFDekMsV0FBQXFFLGlCQUFBO29CQUNBQSwrRUFBdUJyRTtvQkFDekJxRSxhQUFBeEQsT0FBQSxHQUFBYjtnQkFDRjtZQUNBO2dCQUNFLENBQUFBLEtBQUE7Z0JBQ0Y7WUFDQTtnQkFDRXNFLFNBQUE7Z0JBQ0E7Z0JBQ0E7Z0JBQ0Esa0ZBQTBDO2dCQUMxQ3RFLDBDQUFpQjtnQkFDbkJBLElBQUFLLEdBQUEsR0FBQUwsSUFBQUssR0FBQTtZQUNBO2dCQUNFd0IsSUFBVTtvQkFDUjBDLENBQUFBLEtBQUFBO29CQUNGQSxRQUFBQyxLQUFBLDhDQUFBeEU7Z0JBQ0E7b0JBQ0V1RSxJQUFBQSxZQUNHO29CQUVMQSxRQUFBQyxLQUFBO2dCQUNGO1lBQ0E7Z0JBQ0V6RSxJQUFBQSxRQUFBQSxFQUNFQztnQkFRSkQsY0FBQUMsS0FBQXlFLGFBQUEzRSxXQUFBRyxzQkFBQUMsaUJBQUFDLGFBQUFDO1lBRUY7O1lBRUVxRTtZQUNBM0U7WUFDQUc7WUFDQUM7WUFDQW9FO1lBQ0FuRTtZQUNBQztZQUNBaUU7WUFDREE7U0FFSEs7Z0JBQ0UsQ0FBQTFEO1lBQ0FqQixNQUFBQSxNQUFBQSxNQUNFQyxhQUNBeUU7WUFPSjFFLGNBQUFDLEtBQUF5RSxhQUFBM0UsV0FBQUcsc0JBQUFDLGlCQUFBQyxhQUFBQztRQUNBa0U7aUJBQ0UsQ0FBQXREO1lBQ0EyRCxxRUFBZTtZQUNmQSxlQUFJRjtnQkFDRkEsZ0JBQUE7Z0JBQ0F2RSwyRUFBZ0I7Z0JBQ2xCQSxnQkFBQTtZQUNBO2dCQUNFb0UsU0FBUXREO2dCQUNWc0QsUUFBQXREO1lBQ0Y7O0lBR047QUFHRjtTQUFzQjRELGFBQ1RDLEtBQ1hDO0lBS0EsTUFBTUMsV0FBTyxFQUFBRCxhQUFBLEtBQUFEO1VBQ1hHLE9BQUk7UUFDSkMsSUFBQUE7UUFDQUMsYUFBWUosY0FBY2xCLE1BQUs7UUFDL0J1QixZQUFBQSxjQUFhTCxLQUFjSztRQUMzQkMsYUFBQUEsY0FBZ0JOLFdBQWNNO1FBQzlCQSxnQkFBR3BCLGNBQWdCYyxjQUFjekI7UUFDbkMsR0FBQVcsZ0JBQUFjLGNBQUF6QixhQUFBO0lBRUE7UUFDRWdDLGVBQUFDLFVBQUFDLE9BQUEsQ0FBQUMsT0FBQTtRQUNBQyxtREFFRTtRQUNBVixVQUFBQSxPQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxjQUFBQSxHQUFBQSxFQUVGQTtRQUNGO0lBRUE7V0FFSSxrQkFBQWpCLFlBQUFDLEdBQUEsRUFBQTJCLE1BQUFILE9BQUNJLEVBQUFBO2tCQU9LLGtCQUFBN0IsWUFBQUMsR0FBQTtZQUNKNkIsS0FBQTtZQUNBLHNFQUFxRTtZQUNyRSxxRUFBc0Q7WUFDdEQsc0RBQUU7WUFDRjtZQUNBQyw4RUFBMEQ7WUFDekRBLE1BQUdkLGNBQUlwQixNQUFBLEdBQUFtQyxZQUFBaEIsY0FBQXpFLEdBQUE7WUFaTixHQUFBMEUsSUFBQTs7SUFnQlY7QUFPTztLQXJEZUg7TUF1RGxCbUIsUUFBb0JDLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLE9BQUFBLFVBQVdFLEVBQUFBLENBQUFBLE9BQUFBO0lBQy9CLE1BQUFELGNBQUEsSUFBQTdDLE9BQUE0QyxVQUFBLEVBQUFHLDRCQUEwREQsYUFBQTtJQUMxRCwwREFBcUJEO0lBRXJCLE1BQU1HLGNBQUFBLENBQUFBO0lBQ04sTUFBTUMsZ0JBQVNDLENBQUFBLEdBQUFBLE9BQU9OLFVBQUMsRUFBQU8saUNBQUFDLGtCQUFBO1VBQ3JCSCxTQUFVNUcsQ0FBQUEsR0FBQUEsT0FBQUEsT0FBYTJHLEVBQUFBO1FBQ3ZCLE1BQU1LLElBQUFBLGFBQVdMLGlCQUFBTSxhQUFBQyxrQkFBQTt5QkFBTUM7ZUFBZ0JDLEVBQUUzQixXQUFVO2VBQU8yQixFQUFDQyxVQUFhQztTQUN4RSxDQUFBQyxJQUFNSixDQUFBQSxDQUFBQSxHQUFBQSxJQUFBQSxJQUFBQTtRQUNOLE1BQUFBLGNBQU9DLEVBQUFELFdBQUEsQ0FBQUksSUFBQSxFQUFBRixHQUFBQyxJQUFBRCxJQUFBQztlQUFLRjtZQUFHSixHQUFBQSxDQUFBQTtZQUFVRztZQUFZQTtRQUNwQzs7UUFBZVI7S0FFbEI7SUFDQSxNQUFNdEcsRUFBQUEsTUFBQUEsRUFBQUEsaUJBQVltSCxFQUFNLEdBQUN2QztJQUV6QndDLE1BQUFBLFlBQUFBLENBQUFBLEdBQVU5RCxPQUFBNkQsTUFBQSxFQUFBdkM7UUFDUjVFLE9BQUFBLFNBQVVlLEVBQU87UUFDaEJmLFVBQUFlLE9BQUEsR0FBQTZEOztRQUFRQTtLQUVYO0lBRUF3QyxNQUFBQSx1QkFBVSxJQUFBOUQsT0FBQTZELE1BQUEsRUFBQUU7UUFDUmxILE9BQUFBLFNBQUFBLEVBQUFBO1FBQ0NBLHFCQUFBWSxPQUFBLEdBQUFzRzs7UUFBbUJBO0tBRXRCO0lBQ0EsTUFBTSxDQUFDQyxjQUFhekMsZ0JBQWUsR0FBRzBDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVM7SUFFL0MsTUFBTSxDQUFBRCxhQUFTdEMsZUFBZXdDLEdBQU1DLENBQUFBLEdBQUFBLE9BQVlDLFFBQUFBLEVBQUFBO1VBQzlDQyxFQUFBQSxPQUFBQSxhQUFBQSxFQUFBQSxNQUFBQSxPQUFhLFNBQUFDLGFBQUFGLFdBQUEsRUFBQUcsT0FBQTtRQUNiQyxlQUFTdkIsYUFBQUEsT0FBQUE7UUFDVHdCLFNBQUFBO1FBQ0FUO1FBQ0ZBO0lBRUE7Ozt1QkFJWXRDLEdBQUFBLENBQUFBLEdBQUFBLFlBQWFmLEdBQUEsRUFBQStELGNBQUE7Z0JBQ2pCM0gsR0FBQUEsYUFBYW9IO2dCQUNiOUMsYUFBYThDLFFBQVE5QyxXQUFXO2dCQUNoQ3NELGFBQU1SLFFBQVk5QyxXQUFBO2dCQUNsQjNFLE1BQUFBLFFBQVdBLElBQUFBO2dCQUNYRyxXQUFBQTtnQkFDQUMsc0JBQWlCQTtnQkFDakJ5RSxpQkFBZ0JBO2dCQUNoQnZFLGdCQUFZdUg7Z0JBQ1p4RCxZQUFLRSxNQUFBQSxLQUFBQTs7WUFHUmtEO29CQUVHbEMsUUFBQUEsR0FBYUEsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBQUEsR0FBQUEsRUFBQUEsY0FBQUE7Z0JBQ2JQLGFBQUFBOytCQUVBQTs7O0lBR1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeD81MWUxIl0sIm5hbWVzIjpbIl8iLCJyZXF1aXJlIiwiX2ltYWdlbG9hZGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJjb25maWdFbnYiLCJ3aW5kb3ciLCJlbnYiLCJnbG9iYWxUaGlzIiwiX19ORVhUX0lNQUdFX0lNUE9SVEVEIiwib25Mb2FkUmVmIiwiaGFuZGxlTG9hZGluZyIsImltZyIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImNhdGNoIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJldmVudCIsIndyaXRhYmxlIiwidmFsdWUiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwcmV2ZW50ZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJwcm9jZXNzIiwiZ2V0QXR0cmlidXRlIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwid2lkdGhWaWV3cG9ydFJhdGlvIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJpbm5lcldpZHRoIiwid2Fybk9uY2UiLCJfd2Fybm9uY2UiLCJvcmlnU3JjIiwidmFsaWQiLCJnZXRDb21wdXRlZFN0eWxlIiwicG9zaXRpb24iLCJtYXAiLCJTdHJpbmciLCJqb2luIiwid2lkdGhNb2RpZmllZCIsInRvU3RyaW5nIiwiaGVpZ2h0TW9kaWZpZWQiLCJCb29sZWFuIiwidXNlIiwiX3JlYWN0IiwiZmV0Y2hQcmlvcml0eSIsImZldGNocHJpb3JpdHkiLCJoZWlnaHQiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwic3JjU2V0Iiwic2l6ZXMiLCJyZXN0IiwiX2pzeHJ1bnRpbWUiLCJqc3giLCJnZXREeW5hbWljUHJvcHMiLCJsb2FkaW5nIiwiZGF0YS1uaW1nIiwicmVmIiwidXNlQ2FsbGJhY2siLCJmb3J3YXJkZWRSZWYiLCJvbkVycm9yIiwiY29uc29sZSIsImVycm9yIiwicGxhY2Vob2xkZXIiLCJvbkxvYWQiLCJzZXRTaG93QWx0VGV4dCIsIkltYWdlUHJlbG9hZCIsInBhcmFtIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJpc0FwcFJvdXRlciIsIl9yZWFjdGRvbSIsImRlZmF1bHQiLCJwcmVsb2FkIiwiUmVhY3RET00iLCJfaGVhZCIsImxpbmsiLCJyZWwiLCJocmVmIiwidW5kZWZpbmVkIiwiSW1hZ2UiLCJ1c2VDb250ZXh0IiwicGFnZXNSb3V0ZXIiLCJSb3V0ZXJDb250ZXh0IiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiY29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZSIsIkltYWdlQ29uZmlnQ29udGV4dCIsImFsbFNpemVzIiwiX2ltYWdlY29uZmlnIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiZGV2aWNlU2l6ZXMiLCJjIiwiYSIsImIiLCJzb3J0IiwidXNlUmVmIiwidXNlRWZmZWN0Iiwib25Mb2FkaW5nQ29tcGxldGUiLCJzaG93QWx0VGV4dCIsInVzZVN0YXRlIiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJfZ2V0aW1ncHJvcHMiLCJwcm9wcyIsImltZ0NvbmYiLCJibHVyQ29tcGxldGUiLCJJbWFnZUVsZW1lbnQiLCJmaWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ./resolve-href */ \"(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/add-locale.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"(app-pages-browser)/./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (typeof window === \"undefined\") {\n        return;\n    }\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const doPrefetch = async ()=>{\n        if (isAppRouter) {\n            // note that `appRouter.prefetch()` is currently sync,\n            // so we have to wrap this call in an async function to be able to catch() errors below.\n            return router.prefetch(href, appOptions);\n        } else {\n            return router.prefetch(href, as, options);\n        }\n    };\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    doPrefetch().catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * A React component that extends the HTML `<a>` element to provide [prefetching](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#2-prefetching)\n * and client-side navigation between routes.\n *\n * It is the primary way to navigate between routes in Next.js.\n *\n * Read more: [Next.js docs: `<Link>`](https://nextjs.org/docs/app/api-reference/components/link)\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n            children: children\n        });\n    }\n    const pagesRouter = _react.default.useContext(_routercontextsharedruntime.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontextsharedruntime.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + (typeof window !== \"undefined\" ? \"\\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + (typeof window !== \"undefined\" ? \" \\nOpen your browser's console to view the Component stack trace.\" : \"\"));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart:  false ? 0 : function onTouchStart(e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ (0, _jsxruntime.jsx)(\"a\", {\n        ...restProps,\n        ...childProps,\n        children: children\n    });\n}, \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\")), \"wKD5mb5mk47bkaStGb/Fvd6RWZE=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7NkJBUzRCQSx5QkFBQUMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTt5Q0FDRDt3Q0FDRDt1Q0FDSTs7Ozt1Q0FRRUEsbUJBQUFBLENBQUE7NkNBQ0E7NkNBQ0o7O0FBbUc1QixNQUFNQyxzQkFBaUJDLG1CQUFBQSxDQUFBQSwrSkFBQUE7QUFVdkIsTUFBQUQsYUFDRUUsSUFBQUE7U0FPSUMsU0FBT0MsTUFBQUEsRUFBV0MsSUFBQSxFQUFBQyxFQUFBLEVBQUFDLE9BQWEsRUFBQUMsVUFBQSxFQUFBQyxXQUFBO1FBQ2pDLE9BQUFMLFdBQUE7UUFDRjtJQUVBO0lBQ0EsZ0pBQXVDO1FBQ3JDLENBQUFLLGVBQUEsS0FBQUMsWUFBQUMsVUFBQSxFQUFBTixPQUFBO1FBQ0Y7SUFFQTtJQUNBLDRFQUFZO0lBQ1osWUFBS0U7UUFDSCxDQUFBQSxRQUFNSyxxQkFDSjtRQUNBLE1BQUFBLFNBT0YsT0FBTUMsUUFBQUEsTUFBQUEsS0FBZ0JSLGNBQWtCRSxRQUFNSyxNQUFBQSxHQUFBQSxZQUFBQSxTQUFBQSxPQUFBQSxNQUFBQSxHQUFBQTtRQUU5QyxNQUFBQyxnQkFBQVIsT0FBQSxNQUFBQyxLQUFBLE1BQUFNO1FBQ0Esa0VBQW1DO1lBQ2pDWixXQUFBYyxHQUFBLENBQUFELGdCQUFBO1lBQ0Y7UUFFQTtRQUNBYiwrQkFBZWE7UUFDakJiLFdBQUFlLEdBQUEsQ0FBQUY7SUFFQTtVQUNFRyxhQUFJUDtZQUNGQSxhQUFBO1lBQ0E7WUFDQSx3RkFBb0REO1lBQ3RELE9BQU9OLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUc7ZUFDTDtZQUNGLE9BQUFOLE9BQUFDLFFBQUEsQ0FBQUUsTUFBQUMsSUFBQUM7UUFDRjtJQUVBO0lBQ0E7SUFDQSwwREFBc0Q7SUFDdEQ7SUFDQVMseURBQW9CQztpQkFDZEMsS0FBUUMsQ0FBRyxDQUFDQztZ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Y0FBQTVGLE9BQUFDLE9BQUEsQ0FBQTRGLFlBQUEsQ0FBQXJDLE9BQUF3QixjQUFBLGtCQUFBYyxZQUFBQyxHQUFBO1FBQUcsR0FBR2YsU0FBQUE7cUJBQ25CekU7O0lBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jbGllbnQvbGluay50c3g/YWNmMCJdLCJuYW1lcyI6WyJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfIiwicmVxdWlyZSIsInByZWZldGNoZWQiLCJTZXQiLCJyb3V0ZXIiLCJwcmVmZXRjaCIsIndpbmRvdyIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJhcHBPcHRpb25zIiwiaXNBcHBSb3V0ZXIiLCJfaXNsb2NhbHVybCIsImlzTG9jYWxVUkwiLCJsb2NhbGUiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwiZG9QcmVmZXRjaCIsImVyciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImV2ZW50VGFyZ2V0IiwibmF0aXZlRXZlbnQiLCJ3aGljaCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJsaW5rQ2xpY2tlZCIsImUiLCJyZXBsYWNlIiwic2hhbGxvdyIsInNjcm9sbCIsIm5vZGVOYW1lIiwiaXNBbmNob3JOb2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJSZWFjdCIsIl9yZWFjdCIsImRlZmF1bHQiLCJzdGFydFRyYW5zaXRpb24iLCJmb3JtYXRTdHJpbmdPclVybCIsInVybE9iak9yU3RyaW5nIiwiX2Zvcm1hdHVybCIsImZvcm1hdFVybCIsImNoaWxkcmVuIiwiY2hpbGRyZW5Qcm9wIiwibGVnYWN5QmVoYXZpb3IiLCJhIiwiYXBwUm91dGVyIiwidXNlQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJwYWdlc1JvdXRlciIsInByZWZldGNoRW5hYmxlZCIsInByZWZldGNoUHJvcCIsIl9yb3V0ZXJyZWR1Y2VydHlwZXMiLCJQcmVmZXRjaEtpbmQiLCJBVVRPIiwiRlVMTCIsImFyZ3MiLCJjcmVhdGVQcm9wRXJyb3IiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsInByb3BzIiwicGFzc0hyZWYiLCJvbkNsaWNrIiwib25Nb3VzZUVudGVyIiwib25Ub3VjaFN0YXJ0Iiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJjdXJyZW50IiwiY29uc29sZSIsIndhcm4iLCJhc1Byb3AiLCJocmVmUHJvcCIsInBhdGhuYW1lIiwiaGFzRHluYW1pY1NlZ21lbnQiLCJzcGxpdCIsInNvbWUiLCJzZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwidXNlTWVtbyIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJfcmVzb2x2ZWhyZWYiLCJyZXNvbHZlSHJlZiIsInByZXZpb3VzQXMiLCJ1c2VSZWYiLCJjaGlsZCIsIkNoaWxkcmVuIiwib25seSIsInR5cGUiLCJjaGlsZFJlZiIsInNldEludGVyc2VjdGlvblJlZiIsImlzVmlzaWJsZSIsInJlc2V0VmlzaWJsZSIsInVzZUludGVyc2VjdGlvbiIsInJvb3RNYXJnaW4iLCJfdXNlaW50ZXJzZWN0aW9uIiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInByZXZpb3VzSHJlZiIsInVzZUVmZmVjdCIsImFwcFByZWZldGNoS2luZCIsInJlZiIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbk1vdXNlRW50ZXJQcm9wIiwicHJpb3JpdHkiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJvblRvdWNoU3RhcnRQcm9wIiwidW5kZWZpbmVkIiwiY2hpbGRQcm9wcyIsImN1ckxvY2FsZSIsImlzTG9jYWxlRG9tYWluIiwibG9jYWxlRG9tYWluIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJfZ2V0ZG9tYWlubG9jYWxlIiwiZGVmYXVsdExvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiX2FkZGJhc2VwYXRoIiwiX2FkZGxvY2FsZSIsInJlc3RQcm9wcyIsImNsb25lRWxlbWVudCIsIl9qc3hydW50aW1lIiwianN4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    cancelIdleCallback: function() {\n        return cancelIdleCallback;\n    },\n    requestIdleCallback: function() {\n        return requestIdleCallback;\n    }\n});\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return self.setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFnQmFBLG9CQUFrQjtlQUFsQkE7O0lBaEJBQyxxQkFBbUI7ZUFBbkJBOzs7QUFBTixNQUFNQSxzQkFDWCxPQUFRQyxTQUFTLGVBQ2ZBLEtBQUtELG1CQUFtQixJQUN4QkMsS0FBS0QsbUJBQW1CLENBQUNFLElBQUksQ0FBQ0MsV0FDaEMsU0FBVUMsRUFBdUI7SUFDL0IsSUFBSUMsUUFBUUMsS0FBS0MsR0FBRztJQUNwQixPQUFPTixLQUFLTyxVQUFVLENBQUM7UUFDckJKLEdBQUc7WUFDREssWUFBWTtZQUNaQyxlQUFlO2dCQUNiLE9BQU9DLEtBQUtDLEdBQUcsQ0FBQyxHQUFHLEtBQU1OLENBQUFBLEtBQUtDLEdBQUcsS0FBS0YsS0FBQUE7WUFDeEM7UUFDRjtJQUNGLEdBQUc7QUFDTDtBQUVLLE1BQU1OLHFCQUNYLE9BQVFFLFNBQVMsZUFDZkEsS0FBS0Ysa0JBQWtCLElBQ3ZCRSxLQUFLRixrQkFBa0IsQ0FBQ0csSUFBSSxDQUFDQyxXQUMvQixTQUFVVSxFQUFVO0lBQ2xCLE9BQU9DLGFBQWFEO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3JlcXVlc3QtaWRsZS1jYWxsYmFjay50cz8wNWY0Il0sIm5hbWVzIjpbImNhbmNlbElkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJzZWxmIiwiYmluZCIsIndpbmRvdyIsImNiIiwic3RhcnQiLCJEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImRpZFRpbWVvdXQiLCJ0aW1lUmVtYWluaW5nIiwiTWF0aCIsIm1heCIsImlkIiwiY2xlYXJUaW1lb3V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/resolve-href.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"resolveHref\", ({\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n}));\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _omit = __webpack_require__(/*! ../shared/lib/router/utils/omit */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _utils1 = __webpack_require__(/*! ../shared/lib/router/utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\", 1);\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=resolve-href.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3Jlc29sdmUtaHJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQXlCZ0JBOzs7ZUFBQUE7Ozt5Q0F2QnVCO3VDQUNGO2tDQUNoQjttQ0FDb0I7b0RBQ0U7d0NBQ2hCO29DQUNJOzJDQUNEO0FBZ0J2QixTQUFTQSxZQUNkQyxNQUFrQixFQUNsQkMsSUFBUyxFQUNUQyxTQUFtQjtJQUVuQiw0Q0FBNEM7SUFDNUMsSUFBSUM7SUFDSixJQUFJQyxjQUFjLE9BQU9ILFNBQVMsV0FBV0EsT0FBT0ksQ0FBQUEsR0FBQUEsV0FBQUEsb0JBQW9CLEVBQUNKO0lBRXpFLDZEQUE2RDtJQUM3RCxtREFBbUQ7SUFDbkQsTUFBTUssZ0JBQWdCRixZQUFZRyxLQUFLLENBQUM7SUFDeEMsTUFBTUMscUJBQXFCRixnQkFDdkJGLFlBQVlLLEtBQUssQ0FBQ0gsYUFBYSxDQUFDLEVBQUUsQ0FBQ0ksTUFBTSxJQUN6Q047SUFFSixNQUFNTyxXQUFXSCxtQkFBbUJJLEtBQUssQ0FBQyxLQUFLO0lBRS9DLElBQUksQ0FBQ0QsUUFBUSxDQUFDLEVBQUUsSUFBSSxJQUFJSixLQUFLLENBQUMsY0FBYztRQUMxQ00sUUFBUUMsS0FBSyxDQUNYLG1CQUFpQlYsY0FBWSx1Q0FBb0NKLE9BQU9lLFFBQVEsR0FBQztRQUVuRixNQUFNQyxnQkFBZ0JDLENBQUFBLEdBQUFBLE9BQUFBLHdCQUF3QixFQUFDVDtRQUMvQ0osY0FBYyxDQUFDRSxnQkFBZ0JBLGFBQWEsQ0FBQyxFQUFFLEdBQUcsTUFBTVU7SUFDMUQ7SUFFQSwyREFBMkQ7SUFDM0QsSUFBSSxDQUFDRSxDQUFBQSxHQUFBQSxZQUFBQSxVQUFVLEVBQUNkLGNBQWM7UUFDNUIsT0FBUUYsWUFBWTtZQUFDRTtTQUFZLEdBQUdBO0lBQ3RDO0lBRUEsSUFBSTtRQUNGRCxPQUFPLElBQUlnQixJQUNUZixZQUFZZ0IsVUFBVSxDQUFDLE9BQU9wQixPQUFPcUIsTUFBTSxHQUFHckIsT0FBT2UsUUFBUSxFQUM3RDtJQUVKLEVBQUUsT0FBT08sR0FBRztRQUNWLGtEQUFrRDtRQUNsRG5CLE9BQU8sSUFBSWdCLElBQUksS0FBSztJQUN0QjtJQUVBLElBQUk7UUFDRixNQUFNSSxXQUFXLElBQUlKLElBQUlmLGFBQWFEO1FBQ3RDb0IsU0FBU1IsUUFBUSxHQUFHUyxDQUFBQSxHQUFBQSx3QkFBQUEsMEJBQTBCLEVBQUNELFNBQVNSLFFBQVE7UUFDaEUsSUFBSVUsaUJBQWlCO1FBRXJCLElBQ0VDLENBQUFBLEdBQUFBLFFBQUFBLGNBQWMsRUFBQ0gsU0FBU1IsUUFBUSxLQUNoQ1EsU0FBU0ksWUFBWSxJQUNyQnpCLFdBQ0E7WUFDQSxNQUFNMEIsUUFBUUMsQ0FBQUEsR0FBQUEsYUFBQUEsc0JBQXNCLEVBQUNOLFNBQVNJLFlBQVk7WUFFMUQsTUFBTSxFQUFFRyxNQUFNLEVBQUVDLE1BQU0sRUFBRSxHQUFHQyxDQUFBQSxHQUFBQSxlQUFBQSxhQUFhLEVBQ3RDVCxTQUFTUixRQUFRLEVBQ2pCUSxTQUFTUixRQUFRLEVBQ2pCYTtZQUdGLElBQUlFLFFBQVE7Z0JBQ1ZMLGlCQUFpQnBCLENBQUFBLEdBQUFBLFdBQUFBLG9CQUFvQixFQUFDO29CQUNwQ1UsVUFBVWU7b0JBQ1ZHLE1BQU1WLFNBQVNVLElBQUk7b0JBQ25CTCxPQUFPTSxDQUFBQSxHQUFBQSxNQUFBQSxJQUFJLEVBQUNOLE9BQU9HO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxvRUFBb0U7UUFDcEUsTUFBTUksZUFDSlosU0FBU2EsTUFBTSxLQUFLakMsS0FBS2lDLE1BQU0sR0FDM0JiLFNBQVN0QixJQUFJLENBQUNRLEtBQUssQ0FBQ2MsU0FBU2EsTUFBTSxDQUFDMUIsTUFBTSxJQUMxQ2EsU0FBU3RCLElBQUk7UUFFbkIsT0FBT0MsWUFDSDtZQUFDaUM7WUFBY1Ysa0JBQWtCVTtTQUFhLEdBQzlDQTtJQUNOLEVBQUUsT0FBT2IsR0FBRztRQUNWLE9BQU9wQixZQUFZO1lBQUNFO1NBQVksR0FBR0E7SUFDckM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NsaWVudC9yZXNvbHZlLWhyZWYudHM/ZTZkMiJdLCJuYW1lcyI6WyJyZXNvbHZlSHJlZiIsInJvdXRlciIsImhyZWYiLCJyZXNvbHZlQXMiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybFByb3RvTWF0Y2giLCJtYXRjaCIsInVybEFzU3RyaW5nTm9Qcm90byIsInNsaWNlIiwibGVuZ3RoIiwidXJsUGFydHMiLCJzcGxpdCIsImNvbnNvbGUiLCJlcnJvciIsInBhdGhuYW1lIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImlzTG9jYWxVUkwiLCJVUkwiLCJzdGFydHNXaXRoIiwiYXNQYXRoIiwiXyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwicXVlcnkiLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwicmVzdWx0IiwicGFyYW1zIiwiaW50ZXJwb2xhdGVBcyIsImhhc2giLCJvbWl0IiwicmVzb2x2ZWRIcmVmIiwib3JpZ2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/resolve-href.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"(app-pages-browser)/./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OzttREErRmdCQTs7O2VBQUFBOzs7bUNBL0Z5QztpREFJbEQ7QUFxQlAsTUFBTUMsMEJBQTBCLE9BQU9DLHlCQUF5QjtBQUVoRSxNQUFNQyxZQUFZLElBQUlDO0FBQ3RCLE1BQU1DLFNBQXVCLEVBQUU7QUFFL0IsU0FBU0MsZUFBZUMsT0FBb0M7SUFDMUQsTUFBTUMsS0FBSztRQUNUQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNoQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FDMUIsQ0FBQ0MsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtJQUUzRCxJQUFJSztJQUVKLElBQUlILFVBQVU7UUFDWkcsV0FBV1osVUFBVWEsR0FBRyxDQUFDSjtRQUN6QixJQUFJRyxVQUFVO1lBQ1osT0FBT0E7UUFDVDtJQUNGO0lBRUEsTUFBTUUsV0FBVyxJQUFJYjtJQUNyQixNQUFNYyxXQUFXLElBQUloQixxQkFBcUIsQ0FBQ2lCO1FBQ3pDQSxRQUFRQyxPQUFPLENBQUMsQ0FBQ0M7WUFDZixNQUFNQyxXQUFXTCxTQUFTRCxHQUFHLENBQUNLLE1BQU1FLE1BQU07WUFDMUMsTUFBTUMsWUFBWUgsTUFBTUksY0FBYyxJQUFJSixNQUFNSyxpQkFBaUIsR0FBRztZQUNwRSxJQUFJSixZQUFZRSxXQUFXO2dCQUN6QkYsU0FBU0U7WUFDWDtRQUNGO0lBQ0YsR0FBR2pCO0lBQ0hRLFdBQVc7UUFDVFA7UUFDQVU7UUFDQUQ7SUFDRjtJQUVBWixPQUFPc0IsSUFBSSxDQUFDbkI7SUFDWkwsVUFBVXlCLEdBQUcsQ0FBQ3BCLElBQUlPO0lBQ2xCLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTYyxRQUNQQyxPQUFnQixFQUNoQlIsUUFBeUIsRUFDekJmLE9BQW9DO0lBRXBDLE1BQU0sRUFBRUMsRUFBRSxFQUFFVSxRQUFRLEVBQUVELFFBQVEsRUFBRSxHQUFHWCxlQUFlQztJQUNsRFUsU0FBU1csR0FBRyxDQUFDRSxTQUFTUjtJQUV0QkosU0FBU1csT0FBTyxDQUFDQztJQUNqQixPQUFPLFNBQVNDO1FBQ2RkLFNBQVNlLE1BQU0sQ0FBQ0Y7UUFDaEJaLFNBQVNhLFNBQVMsQ0FBQ0Q7UUFFbkIsdURBQXVEO1FBQ3ZELElBQUliLFNBQVNnQixJQUFJLEtBQUssR0FBRztZQUN2QmYsU0FBU2dCLFVBQVU7WUFDbkIvQixVQUFVNkIsTUFBTSxDQUFDeEI7WUFDakIsTUFBTTJCLFFBQVE5QixPQUFPK0IsU0FBUyxDQUM1QixDQUFDdEIsTUFBUUEsSUFBSUwsSUFBSSxLQUFLRCxHQUFHQyxJQUFJLElBQUlLLElBQUlKLE1BQU0sS0FBS0YsR0FBR0UsTUFBTTtZQUUzRCxJQUFJeUIsUUFBUSxDQUFDLEdBQUc7Z0JBQ2Q5QixPQUFPZ0MsTUFBTSxDQUFDRixPQUFPO1lBQ3ZCO1FBQ0Y7SUFDRjtBQUNGO0FBRU8sU0FBU25DLGdCQUFtQ3NDLEtBSWpDO0lBSmlDLE1BQ2pEQyxPQUFPLEVBQ1A1QixVQUFVLEVBQ1Y2QixRQUFRLEVBQ1EsR0FKaUNGO0lBS2pELE1BQU1HLGFBQXNCRCxZQUFZLENBQUN2QztJQUV6QyxNQUFNLENBQUN5QyxTQUFTQyxXQUFXLEdBQUdDLENBQUFBLEdBQUFBLE9BQUFBLFFBQVEsRUFBQztJQUN2QyxNQUFNQyxhQUFhQyxDQUFBQSxHQUFBQSxPQUFBQSxNQUFNLEVBQVc7SUFDcEMsTUFBTUMsYUFBYUMsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDLENBQUNsQjtRQUM5QmUsV0FBV0ksT0FBTyxHQUFHbkI7SUFDdkIsR0FBRyxFQUFFO0lBRUxvQixDQUFBQSxHQUFBQSxPQUFBQSxTQUFTLEVBQUM7UUFDUixJQUFJakQseUJBQXlCO1lBQzNCLElBQUl3QyxjQUFjQyxTQUFTO1lBRTNCLE1BQU1aLFVBQVVlLFdBQVdJLE9BQU87WUFDbEMsSUFBSW5CLFdBQVdBLFFBQVFxQixPQUFPLEVBQUU7Z0JBQzlCLE1BQU1wQixZQUFZRixRQUNoQkMsU0FDQSxDQUFDTixZQUFjQSxhQUFhbUIsV0FBV25CLFlBQ3ZDO29CQUFFZixNQUFNOEIsV0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsUUFBU1UsT0FBTztvQkFBRXRDO2dCQUFXO2dCQUd2QyxPQUFPb0I7WUFDVDtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNXLFNBQVM7Z0JBQ1osTUFBTVUsZUFBZUMsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDLElBQU1WLFdBQVc7Z0JBQzFELE9BQU8sSUFBTVcsQ0FBQUEsR0FBQUEscUJBQUFBLGtCQUFrQixFQUFDRjtZQUNsQztRQUNGO0lBQ0EsdURBQXVEO0lBQ3pELEdBQUc7UUFBQ1g7UUFBWTlCO1FBQVk0QjtRQUFTRztRQUFTRyxXQUFXSSxPQUFPO0tBQUM7SUFFakUsTUFBTU0sZUFBZVAsQ0FBQUEsR0FBQUEsT0FBQUEsV0FBVyxFQUFDO1FBQy9CTCxXQUFXO0lBQ2IsR0FBRyxFQUFFO0lBRUwsT0FBTztRQUFDSTtRQUFZTDtRQUFTYTtLQUFhO0FBQzVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9zcmMvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24udHN4PzU3ZWUiXSwibmFtZXMiOlsidXNlSW50ZXJzZWN0aW9uIiwiaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIm9ic2VydmVycyIsIk1hcCIsImlkTGlzdCIsImNyZWF0ZU9ic2VydmVyIiwib3B0aW9ucyIsImlkIiwicm9vdCIsIm1hcmdpbiIsInJvb3RNYXJnaW4iLCJleGlzdGluZyIsImZpbmQiLCJvYmoiLCJpbnN0YW5jZSIsImdldCIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY2FsbGJhY2siLCJ0YXJnZXQiLCJpc1Zpc2libGUiLCJpc0ludGVyc2VjdGluZyIsImludGVyc2VjdGlvblJhdGlvIiwicHVzaCIsInNldCIsIm9ic2VydmUiLCJlbGVtZW50IiwidW5vYnNlcnZlIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsInBhcmFtIiwicm9vdFJlZiIsImRpc2FibGVkIiwiaXNEaXNhYmxlZCIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwidXNlU3RhdGUiLCJlbGVtZW50UmVmIiwidXNlUmVmIiwic2V0RWxlbWVudCIsInVzZUNhbGxiYWNrIiwiY3VycmVudCIsInVzZUVmZmVjdCIsInRhZ05hbWUiLCJpZGxlQ2FsbGJhY2siLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVzZXRWaXNpYmxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQUVhQTs7O2VBQUFBOzs7OzRFQUZLO0FBRVgsTUFBTUEsa0JBQXNDQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBQyxDQUFDO0FBRXhFLElBQUlDLElBQXlCLEVBQWM7SUFDekNILGdCQUFnQkksV0FBVyxHQUFHO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS50cz85NjQxIl0sIm5hbWVzIjpbIkFtcFN0YXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsWUFBWUMsS0FBQTtJQUFBLE1BQzFCQyxXQUFXLEtBQUssRUFDaEJDLFNBQVMsS0FBSyxFQUNkQyxXQUFXLEtBQUssRUFDakIsR0FKMkJILFVBQUEsU0FJeEIsQ0FBQyxJQUp1QkE7SUFLMUIsT0FBT0MsWUFBYUMsVUFBVUM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2FtcC1tb2RlLnRzP2NlMDQiXSwibmFtZXMiOlsiaXNJbkFtcE1vZGUiLCJwYXJhbSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// regexp is based on https://github.com/sindresorhus/escape-string-regexp\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"escapeStringRegexp\", ({\n    enumerable: true,\n    get: function() {\n        return escapeStringRegexp;\n    }\n}));\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBFQUEwRTs7Ozs7c0RBSTFEQTs7O2VBQUFBOzs7QUFIaEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxrQkFBa0I7QUFFakIsU0FBU0YsbUJBQW1CRyxHQUFXO0lBQzVDLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDekIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDdEM7SUFDQSxPQUFPQztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9lc2NhcGUtcmVnZXhwLnRzP2RjYjEiXSwibmFtZXMiOlsiZXNjYXBlU3RyaW5nUmVnZXhwIiwicmVIYXNSZWdFeHAiLCJyZVJlcGxhY2VSZWdFeHAiLCJzdHIiLCJ0ZXN0IiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, decoding = \"async\", layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    if (typeof defaultLoader === \"undefined\") {\n        throw new Error(\"images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config\");\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if (typeof window !== \"undefined\" && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (typeof window !== \"undefined\") {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiI7Ozs7K0NBMk9nQkE7OztlQUFBQTs7O3NDQTNPUzswQ0FDTzt5Q0FDRztBQTZFbkMsTUFBTUMsdUJBQXVCO0lBQUM7SUFBUTtJQUFTQztDQUFVO0FBa0J6RCxTQUFTQyxnQkFDUEMsR0FBb0M7SUFFcEMsT0FBT0EsSUFBdUJDLE9BQU8sS0FBS0g7QUFDNUM7QUFFQSxTQUFTSSxrQkFDUEYsR0FBb0M7SUFFcEMsT0FBT0EsSUFBeUJBLEdBQUcsS0FBS0Y7QUFDMUM7QUFFQSxTQUFTSyxlQUFlSCxHQUEwQjtJQUNoRCxPQUNFLE9BQU9BLFFBQVEsWUFDZEQsQ0FBQUEsZ0JBQWdCQyxRQUNmRSxrQkFBa0JGLElBQUFBO0FBRXhCO0FBRUEsTUFBTUksVUFBVSxJQUFJQztBQUlwQixJQUFJQztBQUVKLFNBQVNDLE9BQU9DLENBQVU7SUFDeEIsSUFBSSxPQUFPQSxNQUFNLGFBQWE7UUFDNUIsT0FBT0E7SUFDVDtJQUNBLElBQUksT0FBT0EsTUFBTSxVQUFVO1FBQ3pCLE9BQU9DLE9BQU9DLFFBQVEsQ0FBQ0YsS0FBS0EsSUFBSUc7SUFDbEM7SUFDQSxJQUFJLE9BQU9ILE1BQU0sWUFBWSxXQUFXSSxJQUFJLENBQUNKLElBQUk7UUFDL0MsT0FBT0ssU0FBU0wsR0FBRztJQUNyQjtJQUNBLE9BQU9HO0FBQ1Q7QUFFQSxTQUFTRyxVQUNQQyxLQUFzQyxFQUN0Q0MsS0FBeUIsRUFDekJDLEtBQXlCO0lBRnpCLE1BQUVDLFdBQVcsRUFBRUMsUUFBUSxFQUFlLEdBQXRDSjtJQUlBLElBQUlFLE9BQU87UUFDVCx5REFBeUQ7UUFDekQsTUFBTUcsa0JBQWtCO1FBQ3hCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixJQUFLLElBQUlDLE9BQVFBLFFBQVFGLGdCQUFnQkcsSUFBSSxDQUFDTixRQUFTSyxNQUFPO1lBQzVERCxhQUFhRyxJ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QztRQUNBd0M7UUFDQXhCLE9BQU8yRTtRQUNQbEQsU0FBUytEO1FBQ1R2RjtRQUNBeUI7SUFDRjtJQUVBLElBQUkrRCxJQUF5QixFQUFjO1FBQ3pDLElBQUksT0FBT2tCLFdBQVcsYUFBYTtZQUNqQyxJQUFJNEI7WUFDSixJQUFJO2dCQUNGQSxVQUFVLElBQUlwQyxJQUFJbUMsY0FBY3RKLEdBQUc7WUFDckMsRUFBRSxPQUFPd0osR0FBRztnQkFDVkQsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWN0SixHQUFHLEVBQUUySCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzNEO1lBQ0F0SixRQUFRdUosR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQUUxSjtnQkFBS2dEO2dCQUFVUztZQUFZO1FBQ3pEO0lBQ0Y7SUFFQSxNQUFNbUcsUUFBa0I7UUFDdEIsR0FBRzFGLElBQUk7UUFDUGpCLFNBQVNtRCxTQUFTLFNBQVNuRDtRQUMzQlU7UUFDQTNDLE9BQU8yRTtRQUNQeEMsUUFBUXlDO1FBQ1JoQztRQUNBVjtRQUNBRyxPQUFPO1lBQUUsR0FBR29GLFFBQVE7WUFBRSxHQUFHUyxnQkFBZ0I7UUFBQztRQUMxQ2pJLE9BQU9xSSxjQUFjckksS0FBSztRQUMxQjBCLFFBQVEyRyxjQUFjM0csTUFBTTtRQUM1QjNDLEtBQUtzRCxlQUFlZ0csY0FBY3RKLEdBQUc7SUFDdkM7SUFDQSxNQUFNNkosT0FBTztRQUFFckg7UUFBYVE7UUFBVVM7UUFBYUw7SUFBSztJQUN4RCxPQUFPO1FBQUV3RztRQUFPQztJQUFLO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLnRzP2VjOTEiXSwibmFtZXMiOlsiZ2V0SW1nUHJvcHMiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsInBhcmFtIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvdmVycmlkZVNyYyIsIm9uTG9hZCIsIm9uTG9hZGluZ0NvbXBsZXRlIiwicGxhY2Vob2xkZXIiLCJibHVyRGF0YVVSTCIsImZldGNoUHJpb3JpdHkiLCJkZWNvZGluZyIsImxheW91dCIsIm9iamVjdEZpdCIsIm9iamVjdFBvc2l0aW9uIiwibGF6eUJvdW5kYXJ5IiwibGF6eVJvb3QiLCJyZXN0IiwiaW1nQ29uZiIsInNob3dBbHRUZXh0IiwiYmx1ckNvbXBsZXRlIiwiZGVmYXVsdExvYWRlciIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJpbWFnZVNpemVzIiwic29ydCIsImEiLCJiIiwiRXJyb3IiLCJpc0RlZmF1bHRMb2FkZXIiLCJjdXN0b21JbWFnZUxvYWRlciIsIm9iaiIsIl8iLCJvcHRzIiwibGF5b3V0VG9TdHlsZSIsImludHJpbnNpYyIsIm1heFdpZHRoIiwicmVzcG9uc2l2ZSIsImxheW91dFRvU2l6ZXMiLCJsYXlvdXRTdHlsZSIsImxheW91dFNpemVzIiwic3RhdGljU3JjIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0Iiwic3RhdGljSW1hZ2VEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInJhdGlvIiwicm91bmQiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwicXVhbGl0eUludCIsInByb2Nlc3MiLCJvdXRwdXQiLCJwb3NpdGlvbiIsImlzTmFOIiwiaW5jbHVkZXMiLCJTdHJpbmciLCJ3YXJuT25jZSIsIlZBTElEX0JMVVJfRVhUIiwidXJsU3RyIiwidXJsIiwiVVJMIiwiZXJyIiwicGF0aG5hbWUiLCJzZWFyY2giLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJtZXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    defaultHead: function() {\n        return defaultHead;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBcU1BQSxTQUFtQjs7O0lBeExIQztpQkFBQUE7Ozs7Ozs7OzJEQVRnQkMsQ0FBQSxDQUFBQyxtQkFBQUEsQ0FBQTs7eUNBRUpBLG1CQUFBQSxDQUFBOztBQU9yQixNQUFBQyxZQUFTSCxtQkFBQUEsQ0FBWUkscUdBQUFBO1NBQUFBLFlBQUFBLFNBQUFBO0lBQzFCLElBQUFBLGNBQWEsUUFBQUEsWUFBQTs7bUJBQU9DLEdBQVEsSUFBQUMsWUFBQUMsR0FBQTs7UUFBVztLQUN2QztRQUNFQyxDQUFBQSxXQUFTO2FBQU9DLElBQUFBLENBQUssa0JBQUFILFlBQUFDLEdBQUE7WUFBV0csTUFBQUE7O1FBQ2xDO0lBQ0E7SUFDRixPQUFBRjtBQUVBO1NBSUVHLGlCQUFBQyxJQUFBLEVBQUFDLEtBQUE7SUFDQSw4RkFBNEQ7UUFDMUQsT0FBT0QsVUFBQUEsWUFBQUEsT0FBQUEsVUFBQUEsVUFBQUE7UUFDVCxPQUFBQTtJQUNBO0lBQ0Esa0NBQXlCRTtRQUN2QkQsTUFBQUUsSUFBT0gsS0FBS0ksT0FDVkMsT0FBQSxDQUFBSCxRQUFBO1FBQ0FJLE9BQUFBLEtBQUFBLE1BQU1DLENBRUpDLE9BQ0VDLE9BQUFBLENBQ0FDLFFBQUFBLENBQUFBLE9BQUFBLENBQUFBLE1BQUFBLEtBQUFBLENBQUFBLFFBQUFBLEVBQUFBLE1BQUFBLGdCQUdTQTtnQkFHUCxPQUFPRCxrQkFBQUEsWUFBQUEsT0FBQUEsa0JBQUFBLFVBQUFBO2dCQUNULE9BQUFBO1lBQ0E7WUFFRixPQUFFQSxhQUFBTCxNQUFBLENBQUFNO1FBR1I7SUFDQTtJQUNGLE9BQUFWLEtBQUFJLE1BQUEsQ0FBQUg7QUFFQTtNQUFtQlUsWUFBQTtJQUFRO0lBQWE7SUFBVztJQUFXO0NBRTlEOzs7OztZQU1RQztJQUNOLE1BQU1DLE9BQU8sSUFBSUM7SUFDakIsTUFB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QSxDQUNFLEdBQUF6QyxPQUFBd0MsVUFBQSxFQUFDRyxpQ0FBTUQsa0JBQUE7V0FDTEUsV0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsWUFBeUJDLEdBQUFBLEVBQUFBLFlBQUFBLE9BQUFBLEVBQUFBO1FBQ3pCSix5QkFBYUE7UUFDYnpELGFBQVc4RDttQkFFVlQsQ0FBQUEsR0FBQUEsU0FBQUEsV0FBQUEsRUFBQUE7O0lBR1A7O0tBWmdCQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvaGVhZC50c3g/MzY3MCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZGVmYXVsdEhlYWQiLCJfIiwicmVxdWlyZSIsIl93YXJub25jZSIsImluQW1wTW9kZSIsImNoYXJTZXQiLCJfanN4cnVudGltZSIsImpzeCIsImhlYWQiLCJuYW1lIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJGcmFnbWVudCIsInR5cGUiLCJjb25jYXQiLCJkZWZhdWx0IiwiUmVhY3QiLCJDaGlsZHJlbiIsIl9yZWFjdCIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIlNldCIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsImFkZCIsImkiLCJtZXRhdHlwZSIsImxlbiIsImhhc093blByb3BlcnR5IiwiY2F0ZWdvcmllcyIsImhhcyIsImNhdGVnb3J5IiwicHJvcHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImMiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwibmV3UHJvcHMiLCJzdGFydHNXaXRoIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiY2hpbGRyZW4iLCJwYXJhbSIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiRWZmZWN0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJyZWR1Y2VDb21wb25lbnRzIiwiaXNJbkFtcE1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQzs7OzttREFDZUE7OztlQUFBQTs7O0FBQVQsU0FBU0EsZ0JBQWdCQyxLQWMvQjtJQWQrQixNQUM5QkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFNBQVMsRUFRVixHQWQrQk47SUFlOUIsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUVqRCxNQUFNUSxVQUNKRixZQUFZQyxZQUFZLGtCQUFnQkQsV0FBUyxNQUFHQyxZQUFVLE1BQUs7SUFDckUsTUFBTUUsc0JBQXNCRCxVQUN4QixTQUNBSixjQUFjLFlBQ2QsYUFDQUEsY0FBYyxVQUNkLG1CQUNBO0lBRUosT0FBTywrQ0FBNkNJLFVBQVEsOEZBQTJGSCxNQUFJLG9RQUFpUUEsTUFBSSxnR0FBNkZJLHNCQUFvQix3Q0FBcUNOLGNBQVk7QUFDcGtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy50cz9jNzljIl0sIm5hbWVzIjpbImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O3NEQUlhQTs7O2VBQUFBOzs7OzRFQUpLO3lDQUVpQjtBQUU1QixNQUFNQSxxQkFDWEMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQXNCQyxhQUFBQSxrQkFBa0I7QUFFN0QsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0osbUJBQW1CSyxXQUFXLEdBQUc7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzPzNkNzUiXSwibmFtZXMiOlsiSW1hZ2VDb25maWdDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    localPatterns: undefined,\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQWFBLGVBQWE7ZUFBYkE7O0lBOEhBQyxvQkFBa0I7ZUFBbEJBOzs7QUE5SE4sTUFBTUQsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDRDtBQXdITSxNQUFNQyxxQkFBMEM7SUFDckRDLGFBQWE7UUFBQztRQUFLO1FBQUs7UUFBSztRQUFNO1FBQU07UUFBTTtRQUFNO0tBQUs7SUFDMURDLFlBQVk7UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSztRQUFLO0tBQUk7SUFDL0NDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUI7SUFDckJDLGlCQUFpQjtJQUNqQkMsU0FBUztRQUFDO0tBQWE7SUFDdkJDLHFCQUFxQjtJQUNyQkMsdUJBQXdCO0lBQ3hCQyx3QkFBd0I7SUFDeEJDLGVBQWVDO0lBQ2ZDLGdCQUFnQixFQUFFO0lBQ2xCQyxhQUFhO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy50cz8xMzRhIl0sIm5hbWVzIjpbIlZBTElEX0xPQURFUlMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJjb250ZW50RGlzcG9zaXRpb25UeXBlIiwibG9jYWxQYXR0ZXJucyIsInVuZGVmaW5lZCIsInJlbW90ZVBhdHRlcm5zIiwidW5vcHRpbWl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith(\"/\") && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OzsyQ0F5RkE7OztlQUFBQTs7O0FBdkZBLFNBQVNDLGNBQWNDLEtBS007SUFMTixNQUNyQkMsTUFBTSxFQUNOQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsT0FBTyxFQUNvQixHQUxOSjtJQU1yQixJQUFJSyxJQUF5QixFQUFjO1FBQ3pDLE1BQU1DLGdCQUFnQixFQUFFO1FBRXhCLHlEQUF5RDtRQUN6RCxJQUFJLENBQUNKLEtBQUtJLGNBQWNDLElBQUksQ0FBQztRQUM3QixJQUFJLENBQUNKLE9BQU9HLGNBQWNDLElBQUksQ0FBQztRQUUvQixJQUFJRCxjQUFjRSxNQUFNLEdBQUcsR0FBRztZQUM1QixNQUFNLElBQUlDLE1BQ1Isc0NBQW9DSCxjQUFjSSxJQUFJLENBQ3BELFFBQ0EsZ0dBQStGQyxLQUFLQyxTQUFTLENBQzdHO2dCQUFFVjtnQkFBS0M7Z0JBQU9DO1lBQVE7UUFHNUI7UUFFQSxJQUFJRixJQUFJVyxVQUFVLENBQUMsT0FBTztZQUN4QixNQUFNLElBQUlKLE1BQ1IsMEJBQXdCUCxNQUFJO1FBRWhDO1FBRUEsSUFBSUEsSUFBSVcsVUFBVSxDQUFDLFFBQVFaLE9BQU9hLGFBQWEsRUFBRTtZQUMvQyxJQUNFVCxJQUU2QixFQUM3QjtnQkFDQSx1RUFBdUU7Z0JBQ3ZFLE1BQU0sRUFBRVksYUFBYSxFQUFFLEdBQUdDLG1CQUFBQSxDQUFRO2dCQUNsQyxJQUFJLENBQUNELGNBQWNoQixPQUFPYSxhQUFhLEVBQUVaLE1BQU07b0JBQzdDLE1BQU0sSUFBSU8sTUFDUix1QkFBcUJQLE1BQUksa0dBQ3RCO2dCQUVQO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQ0EsSUFBSVcsVUFBVSxDQUFDLFFBQVNaLENBQUFBLE9BQU9rQixPQUFPLElBQUlsQixPQUFPbUIsY0FBYyxHQUFHO1lBQ3JFLElBQUlDO1lBQ0osSUFBSTtnQkFDRkEsWUFBWSxJQUFJQyxJQUFJcEI7WUFDdEIsRUFBRSxPQUFPcUIsS0FBSztnQkFDWkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlkLE1BQ1IsMEJBQXdCUCxNQUFJO1lBRWhDO1lBRUEsSUFDRUcsSUFFNkIsRUFDN0I7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVxQixjQUFjLEVBQUUsR0FBR1IsbUJBQUFBLENBQVE7Z0JBQ25DLElBQUksQ0FBQ1EsZUFBZXpCLE9BQU9rQixPQUFPLEVBQUVsQixPQUFPbUIsY0FBYyxFQUFFQyxZQUFZO29CQUNyRSxNQUFNLElBQUlaLE1BQ1IsdUJBQXFCUCxNQUFJLGtDQUFpQ21CLFVBQVVNLFFBQVEsR0FBQyxnRUFDMUU7Z0JBRVA7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPMUIsT0FBVTJCLElBQUksR0FBQyxVQUFPQyxtQkFBbUIzQixPQUFLLFFBQUtDLFFBQU0sUUFDOURDLENBQUFBLFdBQVcsTUFFWEMsQ0FBQUEsTUFBOEIsR0FDMUIsQ0FBc0MsR0FDdEM7QUFFUjtBQUVBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWNnQyxrQkFBa0IsR0FBRztNQUVuQ2pDLFdBQWVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIudHM/ZDI4MCJdLCJuYW1lcyI6WyJfZGVmYXVsdCIsImRlZmF1bHRMb2FkZXIiLCJwYXJhbSIsImNvbmZpZyIsInNyYyIsIndpZHRoIiwicXVhbGl0eSIsInByb2Nlc3MiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkVycm9yIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwibG9jYWxQYXR0ZXJucyIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc0xvY2FsTWF0Y2giLCJyZXF1aXJlIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiVVJMIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiaGFzUmVtb3RlTWF0Y2giLCJob3N0bmFtZSIsInBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJfX25leHRfaW1nX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, \"http://n\");\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWtCZ0JBLGVBQWE7ZUFBYkE7O0lBZEFDLG1CQUFpQjtlQUFqQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxrQkFBa0JDLE9BQXFCLEVBQUVDLEdBQVE7SUFDL0QsSUFBSUQsUUFBUUUsTUFBTSxLQUFLQyxXQUFXO1FBQ2hDLElBQUlILFFBQVFFLE1BQU0sS0FBS0QsSUFBSUMsTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBRVlGO0lBQVosSUFBSSxDQUFDSSxDQUFBQSxHQUFBQSxXQUFBQSxNQUFNLEVBQUNKLENBQUFBLG9CQUFBQSxRQUFRSyxRQUFRLFlBQWhCTCxvQkFBb0IsTUFBTTtRQUFFTSxLQUFLO0lBQUssR0FBR0MsSUFBSSxDQUFDTixJQUFJSSxRQUFRLEdBQUc7UUFDdkUsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRU8sU0FBU1AsY0FDZFUsYUFBeUMsRUFDekNDLGVBQXVCO0lBRXZCLElBQUksQ0FBQ0QsZUFBZTtRQUNsQix1RUFBdUU7UUFDdkUsT0FBTztJQUNUO0lBQ0EsTUFBTVAsTUFBTSxJQUFJUyxJQUFJRCxpQkFBaUI7SUFDckMsT0FBT0QsY0FBY0csSUFBSSxDQUFDLENBQUNDLElBQU1iLGtCQUFrQmEsR0FBR1g7QUFDeEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL21hdGNoLWxvY2FsLXBhdHRlcm4udHM/NjM1ZCJdLCJuYW1lcyI6WyJoYXNMb2NhbE1hdGNoIiwibWF0Y2hMb2NhbFBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwic2VhcmNoIiwidW5kZWZpbmVkIiwibWFrZVJlIiwicGF0aG5hbWUiLCJkb3QiLCJ0ZXN0IiwibG9jYWxQYXR0ZXJucyIsInVybFBhdGhBbmRRdWVyeSIsIlVSTCIsInNvbWUiLCJwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\", {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUF5Q2dCQSxnQkFBYztlQUFkQTs7SUFyQ0FDLG9CQUFrQjtlQUFsQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxtQkFBbUJDLE9BQXNCLEVBQUVDLEdBQVE7SUFDakUsSUFBSUQsUUFBUUUsUUFBUSxLQUFLQyxXQUFXO1FBQ2xDLE1BQU1DLGNBQWNILElBQUlDLFFBQVEsQ0FBQ0csS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUMzQyxJQUFJTCxRQUFRRSxRQUFRLEtBQUtFLGFBQWE7WUFDcEMsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJSixRQUFRTSxJQUFJLEtBQUtILFdBQVc7UUFDOUIsSUFBSUgsUUFBUU0sSUFBSSxLQUFLTCxJQUFJSyxJQUFJLEVBQUU7WUFDN0IsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJTixRQUFRTyxRQUFRLEtBQUtKLFdBQVc7UUFDbEMsTUFBTSxJQUFJSyxNQUNSLCtDQUE2Q0MsS0FBS0MsU0FBUyxDQUFDVjtJQUVoRSxPQUFPO1FBQ0wsSUFBSSxDQUFDVyxDQUFBQSxHQUFBQSxXQUFBQSxNQUFNLEVBQUNYLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDaEQsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJUCxRQUFRYSxNQUFNLEtBQUtWLFdBQVc7UUFDaEMsSUFBSUgsUUFBUWEsTUFBTSxLQUFLWixJQUFJWSxNQUFNLEVBQUU7WUFDakMsT0FBTztRQUNUO0lBQ0Y7UUFHWWI7SUFEWiw4Q0FBOEM7SUFDOUMsSUFBSSxDQUFDVyxDQUFBQSxHQUFBQSxXQUFBQSxNQUFNLEVBQUNYLENBQUFBLG9CQUFBQSxRQUFRYyxRQUFRLFlBQWhCZCxvQkFBb0IsTUFBTTtRQUFFZSxLQUFLO0lBQUssR0FBR0gsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDdkUsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRU8sU0FBU2hCLGVBQ2RrQixPQUFpQixFQUNqQkMsY0FBK0IsRUFDL0JoQixHQUFRO0lBRVIsT0FDRWUsUUFBUUUsSUFBSSxDQUFDLENBQUNDLFNBQVdsQixJQUFJTSxRQUFRLEtBQUtZLFdBQzFDRixlQUFlQyxJQUFJLENBQUMsQ0FBQ0UsSUFBTXJCLG1CQUFtQnFCLEdBQUduQjtBQUVyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4udHM/ZDYxZCJdLCJuYW1lcyI6WyJoYXNSZW1vdGVNYXRjaCIsIm1hdGNoUmVtb3RlUGF0dGVybiIsInBhdHRlcm4iLCJ1cmwiLCJwcm90b2NvbCIsInVuZGVmaW5lZCIsImFjdHVhbFByb3RvIiwic2xpY2UiLCJwb3J0IiwiaG9zdG5hbWUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJtYWtlUmUiLCJ0ZXN0Iiwic2VhcmNoIiwicGF0aG5hbWUiLCJkb3QiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiOzs7O2lEQUdhQTs7O2VBQUFBOzs7OzRFQUhLO0FBR1gsTUFBTUEsZ0JBQWdCQyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FBb0I7QUFFcEUsSUFBSUMsSUFBeUIsRUFBYztJQUN6Q0gsY0FBY0ksV0FBVyxHQUFHO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cz82MzZjIl0sIm5hbWVzIjpbIlJvdXRlckNvbnRleHQiLCJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1Q0FBdUM7QUFDdkMsc0RBQXNEO0FBQ3RELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsZ0VBQWdFO0FBQ2hFLHNFQUFzRTtBQUN0RSxzRUFBc0U7QUFDdEUsNEVBQTRFO0FBQzVFLHFFQUFxRTtBQUNyRSx3QkFBd0I7QUFDeEIsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSx5REFBeUQ7QUFDekQsRUFBRTtBQUNGLDBFQUEwRTtBQUMxRSw2REFBNkQ7QUFDN0QsNEVBQTRFO0FBQzVFLDJFQUEyRTtBQUMzRSx3RUFBd0U7QUFDeEUsNEVBQTRFO0FBQzVFLHlDQUF5Qzs7Ozs7Ozs7Ozs7OztJQVF6QkEsV0FBUztlQUFUQTs7SUE2REFDLHNCQUFvQjtlQUFwQkE7O0lBZkhDLGVBQWE7ZUFBYkE7Ozs7bUZBbERnQjtBQUU3QixNQUFNQyxtQkFBbUI7QUFFbEIsU0FBU0gsVUFBVUksTUFBaUI7SUFDekMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFFBQVEsRUFBRSxHQUFHRjtJQUN6QixJQUFJRyxXQUFXSCxPQUFPRyxRQUFRLElBQUk7SUFDbEMsSUFBSUMsV0FBV0osT0FBT0ksUUFBUSxJQUFJO0lBQ2xDLElBQUlDLE9BQU9MLE9BQU9LLElBQUksSUFBSTtJQUMxQixJQUFJQyxRQUFRTixPQUFPTSxLQUFLLElBQUk7SUFDNUIsSUFBSUMsT0FBdUI7SUFFM0JOLE9BQU9BLE9BQU9PLG1CQUFtQlAsTUFBTVEsT0FBTyxDQUFDLFFBQVEsT0FBTyxNQUFNO0lBRXBFLElBQUlULE9BQU9PLElBQUksRUFBRTtRQUNmQSxPQUFPTixPQUFPRCxPQUFPTyxJQUFJO0lBQzNCLE9BQU8sSUFBSUwsVUFBVTtRQUNuQkssT0FBT04sT0FBUSxFQUFDQyxTQUFTUSxPQUFPLENBQUMsT0FBTyxNQUFJUixXQUFTLE1BQUtBLFFBQUFBO1FBQzFELElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNmSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDM0I7SUFDRjtJQUVBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3RDQSxRQUFRTSxPQUFPQyxhQUFZQyxzQkFBc0IsQ0FBQ1I7SUFDcEQ7SUFFQSxJQUFJUyxTQUFTZixPQUFPZSxNQUFNLElBQUtULFNBQVMsTUFBSUEsU0FBWTtJQUV4RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNhLFFBQVEsQ0FBQyxNQUFNYixZQUFZO0lBRXJELElBQ0VILE9BQU9pQixPQUFPLElBQ2IsQ0FBQyxDQUFDZCxZQUFZSixpQkFBaUJtQixJQUFJLENBQUNmLFNBQUFBLEtBQWNJLFNBQVMsT0FDNUQ7UUFDQUEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRO1FBQ3ZCLElBQUlILFlBQVlBLFFBQVEsQ0FBQyxFQUFFLEtBQUssS0FBS0EsV0FBVyxNQUFNQTtJQUN4RCxPQUFPLElBQUksQ0FBQ0csTUFBTTtRQUNoQkEsT0FBTztJQUNUO0lBRUEsSUFBSUYsUUFBUUEsSUFBSSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxPQUFPLE1BQU1BO0lBQzFDLElBQUlVLFVBQVVBLE1BQU0sQ0FBQyxFQUFFLEtBQUssS0FBS0EsU0FBUyxNQUFNQTtJQUVoRFgsV0FBV0EsU0FBU0ssT0FBTyxDQUFDLFNBQVNEO0lBQ3JDTyxTQUFTQSxPQUFPTixPQUFPLENBQUMsS0FBSztJQUU3QixPQUFPLEtBQUdOLFdBQVdJLE9BQU9ILFdBQVdXLFNBQVNWO0FBQ2xEO0FBRU8sTUFBTVAsZ0JBQWdCO0lBQzNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRU0sU0FBU0QscUJBQXFCc0IsR0FBYztJQUNqRCxJQUFJQyxJQUF5QixFQUFlO1FBQzFDLElBQUlELFFBQVEsUUFBUSxPQUFPQSxRQUFRLFVBQVU7WUFDM0NFLE9BQU9DLElBQUksQ0FBQ0gsS0FBS0ksT0FBTyxDQUFDLENBQUNDO2dCQUN4QixJQUFJLENBQUMxQixjQUFjMkIsUUFBUSxDQUFDRCxNQUFNO29CQUNoQ0UsUUFBUUMsSUFBSSxDQUNWLHVEQUFxREg7Z0JBRXpEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzVCLFVBQVV1QjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwudHM/MWI4NyJdLCJuYW1lcyI6WyJmb3JtYXRVcmwiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybE9iamVjdEtleXMiLCJzbGFzaGVkUHJvdG9jb2xzIiwidXJsT2JqIiwiYXV0aCIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhhc2giLCJxdWVyeSIsImhvc3QiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXBsYWNlIiwiaW5kZXhPZiIsInBvcnQiLCJTdHJpbmciLCJxdWVyeXN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsIiwicHJvY2VzcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getSortedRoutes: function() {\n        return _sortedroutes.getSortedRoutes;\n    },\n    isDynamicRoute: function() {\n        return _isdynamic.isDynamicRoute;\n    }\n});\nconst _sortedroutes = __webpack_require__(/*! ./sorted-routes */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nconst _isdynamic = __webpack_require__(/*! ./is-dynamic */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBQVNBLGlCQUFlO2VBQWZBLGNBQUFBLGVBQWU7O0lBQ2ZDLGdCQUFjO2VBQWRBLFdBQUFBLGNBQWM7OzswQ0FEUzt1Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LnRzPzcyZDUiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiaXNEeW5hbWljUm91dGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"interpolateAs\", ({\n    enumerable: true,\n    get: function() {\n        return interpolateAs;\n    }\n}));\nconst _routematcher = __webpack_require__(/*! ./route-matcher */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./route-regex */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeregex.getRouteRegex)(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat, optional } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\" + (repeat ? \"...\" : \"\") + param + \"]\";\n        if (optional) {\n            replaced = (!value ? \"/\" : \"\") + \"[\" + replaced + \"]\";\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n} //# sourceMappingURL=interpolate-as.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMuanMiLCJtYXBwaW5ncyI6Ijs7OztpREFLZ0JBOzs7ZUFBQUE7OzswQ0FIZ0I7d0NBQ0Y7QUFFdkIsU0FBU0EsY0FDZEMsS0FBYSxFQUNiQyxVQUFrQixFQUNsQkMsS0FBcUI7SUFFckIsSUFBSUMsb0JBQW9CO0lBRXhCLE1BQU1DLGVBQWVDLENBQUFBLEdBQUFBLFlBQUFBLGFBQWEsRUFBQ0w7SUFDbkMsTUFBTU0sZ0JBQWdCRixhQUFhRyxNQUFNO0lBQ3pDLE1BQU1DLGlCQUVIUCxDQUFBQSxlQUFlRCxRQUFRUyxDQUFBQSxHQUFBQSxjQUFBQSxlQUFlLEVBQUNMLGNBQWNILGNBQWMsT0FDcEUsZ0RBQWdEO0lBQ2hELHNFQUFzRTtJQUN0RUM7SUFFRkMsb0JBQW9CSDtJQUNwQixNQUFNVSxTQUFTQyxPQUFPQyxJQUFJLENBQUNOO0lBRTNCLElBQ0UsQ0FBQ0ksT0FBT0csS0FBSyxDQUFDLENBQUNDO1FBQ2IsSUFBSUMsUUFBUVAsY0FBYyxDQUFDTSxNQUFNLElBQUk7UUFDckMsTUFBTSxFQUFFRSxNQUFNLEVBQUVDLFFBQVEsRUFBRSxHQUFHWCxhQUFhLENBQUNRLE1BQU07UUFFakQsaUNBQWlDO1FBQ2pDLDBEQUEwRDtRQUMxRCxJQUFJSSxXQUFXLE1BQUlGLENBQUFBLFNBQVMsUUFBUSxNQUFLRixRQUFNO1FBQy9DLElBQUlHLFVBQVU7WUFDWkMsV0FBVyxDQUFHLENBQUNILFFBQVEsTUFBTSxNQUFHLE1BQUdHLFdBQVM7UUFDOUM7UUFDQSxJQUFJRixVQUFVLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUEsUUFBUTtZQUFDQTtTQUFNO1FBRXBELE9BQ0UsQ0FBQ0UsWUFBWUgsU0FBU04sY0FBQUEsS0FDdEIsNkNBQTZDO1FBQzVDTCxDQUFBQSxvQkFDQ0Esa0JBQW1Ca0IsT0FBTyxDQUN4QkgsVUFDQUYsU0FDSUQsTUFDR08sR0FBRyxDQUVGLHVEQUF1RDtRQUN2RCxrREFBa0Q7UUFDbEQsb0NBQW9DO1FBQ3BDLENBQUNDLFVBQVlDLG1CQUFtQkQsVUFFakNFLElBQUksQ0FBQyxPQUNSRCxtQkFBbUJULFdBQ3BCO0lBRVgsSUFDQTtRQUNBWixvQkFBb0IsR0FBRyxtQ0FBbUM7O0lBRTFELHVFQUF1RTtJQUN2RSxrREFBa0Q7SUFDcEQ7SUFDQSxPQUFPO1FBQ0xPO1FBQ0FnQixRQUFRdkI7SUFDVjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW50ZXJwb2xhdGUtYXMudHM/OWUzMSJdLCJuYW1lcyI6WyJpbnRlcnBvbGF0ZUFzIiwicm91dGUiLCJhc1BhdGhuYW1lIiwicXVlcnkiLCJpbnRlcnBvbGF0ZWRSb3V0ZSIsImR5bmFtaWNSZWdleCIsImdldFJvdXRlUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZ3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZXZlcnkiLCJwYXJhbSIsInZhbHVlIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJyZXBsYWNlZCIsIkFycmF5IiwiaXNBcnJheSIsInJlcGxhY2UiLCJtYXAiLCJzZWdtZW50IiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwiam9pbiIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return isDynamicRoute;\n    }\n}));\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {\n        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;\n    }\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcyIsIm1hcHBpbmdzIjoiOzs7O2tEQVFnQkE7OztlQUFBQTs7O2dEQUxUO0FBRVAscUNBQXFDO0FBQ3JDLE1BQU1DLGFBQWE7QUFFWixTQUFTRCxlQUFlRSxLQUFhO0lBQzFDLElBQUlDLENBQUFBLEdBQUFBLG9CQUFBQSwwQkFBMEIsRUFBQ0QsUUFBUTtRQUNyQ0EsUUFBUUUsQ0FBQUEsR0FBQUEsb0JBQUFBLG1DQUFtQyxFQUFDRixPQUFPRyxnQkFBZ0I7SUFDckU7SUFFQSxPQUFPSixXQUFXSyxJQUFJLENBQUNKO0FBQ3pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cz84MmRjIl0sIm5hbWVzIjpbImlzRHluYW1pY1JvdXRlIiwiVEVTVF9ST1VURSIsInJvdXRlIiwiaXNJbnRlcmNlcHRpb25Sb3V0ZUFwcFBhdGgiLCJleHRyYWN0SW50ZXJjZXB0aW9uUm91dGVJbmZvcm1hdGlvbiIsImludGVyY2VwdGVkUm91dGUiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-local-url.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isLocalURL\", ({\n    enumerable: true,\n    get: function() {\n        return isLocalURL;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../../client/has-base-path */ \"(app-pages-browser)/./node_modules/next/dist/client/has-base-path.js\");\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils.isAbsoluteUrl)(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils.getLocationOrigin)();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n} //# sourceMappingURL=is-local-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OENBTWdCQTs7O2VBQUFBOzs7bUNBTmlDO3lDQUNyQjtBQUtyQixTQUFTQSxXQUFXQyxHQUFXO0lBQ3BDLGdFQUFnRTtJQUNoRSxJQUFJLENBQUNDLENBQUFBLEdBQUFBLE9BQUFBLGFBQWEsRUFBQ0QsTUFBTSxPQUFPO0lBQ2hDLElBQUk7UUFDRiw0REFBNEQ7UUFDNUQsTUFBTUUsaUJBQWlCQyxDQUFBQSxHQUFBQSxPQUFBQSxpQkFBaUI7UUFDeEMsTUFBTUMsV0FBVyxJQUFJQyxJQUFJTCxLQUFLRTtRQUM5QixPQUFPRSxTQUFTRSxNQUFNLEtBQUtKLGtCQUFrQkssQ0FBQUEsR0FBQUEsYUFBQUEsV0FBVyxFQUFDSCxTQUFTSSxRQUFRO0lBQzVFLEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsLnRzPzA0ZTUiXSwibmFtZXMiOlsiaXNMb2NhbFVSTCIsInVybCIsImlzQWJzb2x1dGVVcmwiLCJsb2NhdGlvbk9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJvcmlnaW4iLCJoYXNCYXNlUGF0aCIsInBhdGhuYW1lIiwiXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/omit.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"omit\", ({\n    enumerable: true,\n    get: function() {\n        return omit;\n    }\n}));\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n} //# sourceMappingURL=omit.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvb21pdC5qcyIsIm1hcHBpbmdzIjoiOzs7O3dDQUFnQkE7OztlQUFBQTs7O0FBQVQsU0FBU0EsS0FDZEMsTUFBUyxFQUNUQyxJQUFTO0lBRVQsTUFBTUMsVUFBc0MsQ0FBQztJQUM3Q0MsT0FBT0YsSUFBSSxDQUFDRCxRQUFRSSxPQUFPLENBQUMsQ0FBQ0M7UUFDM0IsSUFBSSxDQUFDSixLQUFLSyxRQUFRLENBQUNELE1BQVc7WUFDNUJILE9BQU8sQ0FBQ0csSUFBSSxHQUFHTCxNQUFNLENBQUNLLElBQUk7UUFDNUI7SUFDRjtJQUNBLE9BQU9IO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9vbWl0LnRzP2I3YTgiXSwibmFtZXMiOlsib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiT2JqZWN0IiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/omit.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    assign: function() {\n        return assign;\n    },\n    searchParamsToUrlQuery: function() {\n        return searchParamsToUrlQuery;\n    },\n    urlQueryToSearchParams: function() {\n        return urlQueryToSearchParams;\n    }\n});\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBNENnQkEsUUFBTTtlQUFOQTs7SUExQ0FDLHdCQUFzQjtlQUF0QkE7O0lBNEJBQyx3QkFBc0I7ZUFBdEJBOzs7QUE1QlQsU0FBU0QsdUJBQ2RFLFlBQTZCO0lBRTdCLE1BQU1DLFFBQXdCLENBQUM7SUFDL0JELGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUMzQixJQUFJLE9BQU9ILEtBQUssQ0FBQ0csSUFBSSxLQUFLLGFBQWE7WUFDckNILEtBQUssQ0FBQ0csSUFBSSxHQUFHRDtRQUNmLE9BQU8sSUFBSUUsTUFBTUMsT0FBTyxDQUFDTCxLQUFLLENBQUNHLElBQUksR0FBRztZQUNsQ0gsS0FBSyxDQUFDRyxJQUFJLENBQWNHLElBQUksQ0FBQ0o7UUFDakMsT0FBTztZQUNMRixLQUFLLENBQUNHLElBQUksR0FBRztnQkFBQ0gsS0FBSyxDQUFDRyxJQUFJO2dCQUFZRDthQUFNO1FBQzVDO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsU0FBU08sdUJBQXVCQyxLQUFjO0lBQzVDLElBQ0UsT0FBT0EsVUFBVSxZQUNoQixPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFDckMsT0FBT0EsVUFBVSxXQUNqQjtRQUNBLE9BQU9FLE9BQU9GO0lBQ2hCLE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVPLFNBQVNWLHVCQUNkYSxRQUF3QjtJQUV4QixNQUFNQyxTQUFTLElBQUlDO0lBQ25CQyxPQUFPQyxPQUFPLENBQUNKLFVBQVVWLE9BQU8sQ0FBQyxDQUFBTztZQUFDLENBQUNMLEtBQUtELE1BQU0sR0FBQU07UUFDNUMsSUFBSUosTUFBTUMsT0FBTyxDQUFDSCxRQUFRO1lBQ3hCQSxNQUFNRCxPQUFPLENBQUMsQ0FBQ2UsT0FBU0osT0FBT0ssTUFBTSxDQUFDZCxLQUFLSSx1QkFBdUJTO1FBQ3BFLE9BQU87WUFDTEosT0FBT00sR0FBRyxDQUFDZixLQUFLSSx1QkFBdUJMO1FBQ3pDO0lBQ0Y7SUFDQSxPQUFPVTtBQUNUO0FBRU8sU0FBU2hCLE9BQ2R1QixNQUF1QjtJQUN2QixRQUFBQyxPQUFBQyxVQUFBQyxNQUFBLEVBQUFDLG1CQUFBLElBQUFuQixNQUFBZ0IsT0FBQSxJQUFBQSxPQUFBLFFBQUFJLE9BQUEsR0FBQUEsT0FBQUosTUFBQUksT0FBQTtRQUFHRCxnQkFBQUEsQ0FBSEMsT0FBQSxLQUFBSCxTQUFBLENBQUFHLEtBQXNDOztJQUV0Q0QsaUJBQWlCdEIsT0FBTyxDQUFDLENBQUNGO1FBQ3hCSyxNQUFNcUIsSUFBSSxDQUFDMUIsYUFBYTJCLElBQUksSUFBSXpCLE9BQU8sQ0FBQyxDQUFDRSxNQUFRZ0IsT0FBT1EsTUFBTSxDQUFDeEI7UUFDL0RKLGFBQWFFLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQyxNQUFRZ0IsT0FBT0YsTUFBTSxDQUFDZCxLQUFLRDtJQUMxRDtJQUNBLE9BQU9pQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcXVlcnlzdHJpbmcudHM/ODJmYSJdLCJuYW1lcyI6WyJhc3NpZ24iLCJzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJwYXJhbSIsImlzTmFOIiwiU3RyaW5nIiwidXJsUXVlcnkiLCJyZXN1bHQiLCJVUkxTZWFyY2hQYXJhbXMiLCJPYmplY3QiLCJlbnRyaWVzIiwiaXRlbSIsImFwcGVuZCIsInNldCIsInRhcmdldCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzZWFyY2hQYXJhbXNMaXN0IiwiX2tleSIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getRouteMatcher\", ({\n    enumerable: true,\n    get: function() {\n        return getRouteMatcher;\n    }\n}));\nconst _utils = __webpack_require__(/*! ../../utils */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re, groups } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQVdnQkE7OztlQUFBQTs7O21DQVZZO0FBVXJCLFNBQVNBLGdCQUFnQkMsS0FBMEI7SUFBMUIsTUFBRUMsRUFBRSxFQUFFQyxNQUFNLEVBQWMsR0FBMUJGO0lBQzlCLE9BQU8sQ0FBQ0c7UUFDTixNQUFNQyxhQUFhSCxHQUFHSSxJQUFJLENBQUNGO1FBQzNCLElBQUksQ0FBQ0MsWUFBWTtZQUNmLE9BQU87UUFDVDtRQUVBLE1BQU1FLFNBQVMsQ0FBQ047WUFDZCxJQUFJO2dCQUNGLE9BQU9PLG1CQUFtQlA7WUFDNUIsRUFBRSxPQUFPUSxHQUFHO2dCQUNWLE1BQU0sSUFBSUMsT0FBQUEsV0FBVyxDQUFDO1lBQ3hCO1FBQ0Y7UUFDQSxNQUFNQyxTQUFxRCxDQUFDO1FBRTVEQyxPQUFPQyxJQUFJLENBQUNWLFFBQVFXLE9BQU8sQ0FBQyxDQUFDQztZQUMzQixNQUFNQyxJQUFJYixNQUFNLENBQUNZLFNBQVM7WUFDMUIsTUFBTUUsSUFBSVosVUFBVSxDQUFDVyxFQUFFRSxHQUFHLENBQUM7WUFDM0IsSUFBSUQsTUFBTUUsV0FBVztnQkFDbkJSLE1BQU0sQ0FBQ0ksU0FBUyxHQUFHLENBQUNFLEVBQUVHLE9BQU8sQ0FBQyxPQUMxQkgsRUFBRUksS0FBSyxDQUFDLEtBQUtDLEdBQUcsQ0FBQyxDQUFDQyxRQUFVaEIsT0FBT2dCLFVBQ25DUCxFQUFFUSxNQUFNLEdBQ1I7b0JBQUNqQixPQUFPVTtpQkFBRyxHQUNYVixPQUFPVTtZQUNiO1FBQ0Y7UUFDQSxPQUFPTjtJQUNUO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzPzMxNzkiXSwibmFtZXMiOlsiZ2V0Um91dGVNYXRjaGVyIiwicGFyYW0iLCJyZSIsImdyb3VwcyIsInBhdGhuYW1lIiwicm91dGVNYXRjaCIsImV4ZWMiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJfIiwiRGVjb2RlRXJyb3IiLCJwYXJhbXMiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwic3BsaXQiLCJtYXAiLCJlbnRyeSIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getNamedMiddlewareRegex: function() {\n        return getNamedMiddlewareRegex;\n    },\n    getNamedRouteRegex: function() {\n        return getNamedRouteRegex;\n    },\n    getRouteRegex: function() {\n        return getRouteRegex;\n    },\n    parseParameter: function() {\n        return parseParameter;\n    }\n});\nconst _interceptionroutes = __webpack_require__(/*! ../../../../server/future/helpers/interception-routes */ \"(app-pages-browser)/./node_modules/next/dist/server/future/helpers/interception-routes.js\");\nconst _escaperegexp = __webpack_require__(/*! ../../escape-regexp */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/escape-regexp.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./remove-trailing-slash */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\nfunction parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (markerMatch && paramMatches) {\n                const { key, optional, repeat } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n            } else if (paramMatches) {\n                const { key, repeat, optional } = parseParameter(paramMatches[1]);\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let i = 0;\n    return ()=>{\n        let routeKey = \"\";\n        let j = ++i;\n        while(j > 0){\n            routeKey += String.fromCharCode(97 + (j - 1) % 26);\n            j = Math.floor((j - 1) / 26);\n        }\n        return routeKey;\n    };\n}\nfunction getSafeKeyFromSegment(param) {\n    let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;\n    const { key, optional, repeat } = parseParameter(segment);\n    // replace any non-word characters since they can break\n    // the named regex\n    let cleanedKey = key.replace(/\\W/g, \"\");\n    if (keyPrefix) {\n        cleanedKey = \"\" + keyPrefix + cleanedKey;\n    }\n    let invalidKey = false;\n    // check if the key is still invalid and fallback to using a known\n    // safe key\n    if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n        invalidKey = true;\n    }\n    if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n        invalidKey = true;\n    }\n    if (invalidKey) {\n        cleanedKey = getSafeRouteKey();\n    }\n    if (keyPrefix) {\n        routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n    } else {\n        routeKeys[cleanedKey] = key;\n    }\n    // if the segment has an interception marker, make sure that's part of the regex pattern\n    // this is to ensure that the route with the interception marker doesn't incorrectly match\n    // the non-intercepted route (ie /app/(.)[username] should not match /app/[username])\n    const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : \"\";\n    return repeat ? optional ? \"(?:/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?))?\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">.+?)\" : \"/\" + interceptionPrefix + \"(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n    const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=>segment.startsWith(m));\n            const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n            ;\n            if (hasInterceptionMarker && paramMatches) {\n                const [usedMarker] = segment.split(paramMatches[0]);\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    interceptionMarker: usedMarker,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n                });\n            } else if (paramMatches) {\n                return getSafeKeyFromSegment({\n                    getSafeRouteKey,\n                    segment: paramMatches[1],\n                    routeKeys,\n                    keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n                });\n            } else {\n                return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n    const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n    return {\n        ...getRouteRegex(normalizedRoute),\n        namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n        routeKeys: result.routeKeys\n    };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);\n    const { catchAll = true } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\" + catchAllRegex + \"$\"\n        };\n    }\n    const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBMk5nQkEseUJBQXVCO2VBQXZCQTs7SUFoQkFDLG9CQUFrQjtlQUFsQkE7O0lBbklBQyxlQUFhO2VBQWJBOztJQTlDQUMsZ0JBQWM7ZUFBZEE7OztnREExQjJCOzBDQUNSO2lEQUNDO0FBRXBDLE1BQU1DLDBCQUEwQjtBQUNoQyxNQUFNQyxrQ0FBa0M7QUFxQmpDLFNBQVNGLGVBQWVHLEtBQWE7SUFDMUMsTUFBTUMsV0FBV0QsTUFBTUUsVUFBVSxDQUFDLFFBQVFGLE1BQU1HLFFBQVEsQ0FBQztJQUN6RCxJQUFJRixVQUFVO1FBQ1pELFFBQVFBLE1BQU1JLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDMUI7SUFDQSxNQUFNQyxTQUFTTCxNQUFNRSxVQUFVLENBQUM7SUFDaEMsSUFBSUcsUUFBUTtRQUNWTCxRQUFRQSxNQUFNSSxLQUFLLENBQUM7SUFDdEI7SUFDQSxPQUFPO1FBQUVFLEtBQUtOO1FBQU9LO1FBQVFKO0lBQVM7QUFDeEM7QUFFQSxTQUFTTSxxQkFBcUJDLEtBQWE7SUFDekMsTUFBTUMsV0FBV0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDRixPQUFPSixLQUFLLENBQUMsR0FBR08sS0FBSyxDQUFDO0lBQzNELE1BQU1DLFNBQXlDLENBQUM7SUFDaEQsSUFBSUMsYUFBYTtJQUNqQixPQUFPO1FBQ0xDLG9CQUFvQkwsU0FDakJNLEdBQUcsQ0FBQyxDQUFDQztZQUNKLE1BQU1DLGNBQWNDLG9CQUFBQSwwQkFBMEIsQ0FBQ0MsSUFBSSxDQUFDLENBQUNDLElBQ25ESixRQUFRZCxVQUFVLENBQUNrQjtZQUVyQixNQUFNQyxlQUFlTCxRQUFRTSxLQUFLLENBQUMsdUJBQXVCLHVCQUF1Qjs7WUFFakYsSUFBSUwsZUFBZUksY0FBYztnQkFDL0IsTUFBTSxFQUFFZixHQUFHLEVBQUVMLFFBQVEsRUFBRUksTUFBTSxFQUFFLEdBQUdSLGVBQWV3QixZQUFZLENBQUMsRUFBRTtnQkFDaEVULE1BQU0sQ0FBQ04sSUFBSSxHQUFHO29CQUFFaUIsS0FBS1Y7b0JBQWNSO29CQUFRSjtnQkFBUztnQkFDcEQsT0FBTyxNQUFJdUIsQ0FBQUEsR0FBQUEsY0FBQUEsa0JBQWtCLEVBQUNQLGVBQWE7WUFDN0MsT0FBTyxJQUFJSSxjQUFjO2dCQUN2QixNQUFNLEVBQUVmLEdBQUcsRUFBRUQsTUFBTSxFQUFFSixRQUFRLEVBQUUsR0FBR0osZUFBZXdCLFlBQVksQ0FBQyxFQUFFO2dCQUNoRVQsTUFBTSxDQUFDTixJQUFJLEdBQUc7b0JBQUVpQixLQUFLVjtvQkFBY1I7b0JBQVFKO2dCQUFTO2dCQUNwRCxPQUFPSSxTQUFVSixXQUFXLGdCQUFnQixXQUFZO1lBQzFELE9BQU87Z0JBQ0wsT0FBTyxNQUFJdUIsQ0FBQUEsR0FBQUEsY0FBQUEsa0JBQWtCLEVBQUNSO1lBQ2hDO1FBQ0YsR0FDQ1MsSUFBSSxDQUFDO1FBQ1JiO0lBQ0Y7QUFDRjtBQU9PLFNBQVNoQixjQUFjOEIsZUFBdUI7SUFDbkQsTUFBTSxFQUFFWixrQkFBa0IsRUFBRUYsTUFBTSxFQUFFLEdBQUdMLHFCQUFxQm1CO0lBQzVELE9BQU87UUFDTEMsSUFBSSxJQUFJQyxPQUFPLE1BQUlkLHFCQUFtQjtRQUN0Q0YsUUFBUUE7SUFDVjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2lCO0lBQ1AsSUFBSUMsSUFBSTtJQUVSLE9BQU87UUFDTCxJQUFJQyxXQUFXO1FBQ2YsSUFBSUMsSUFBSSxFQUFFRjtRQUNWLE1BQU9FLElBQUksRUFBRztZQUNaRCxZQUFZRSxPQUFPQyxZQUFZLENBQUMsS0FBTSxDQUFDRixJQUFJLEtBQUs7WUFDaERBLElBQUlHLEtBQUtDLEtBQUssQ0FBQyxDQUFDSixJQUFJLEtBQUs7UUFDM0I7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSxTQUFTTSxzQkFBc0JyQyxLQVk5QjtJQVo4QixNQUM3QnNDLGtCQUFrQixFQUNsQkMsZUFBZSxFQUNmdkIsT0FBTyxFQUNQd0IsU0FBUyxFQUNUQyxTQUFTLEVBT1YsR0FaOEJ6QztJQWE3QixNQUFNLEVBQUVNLEdBQUcsRUFBRUwsUUFBUSxFQUFFSSxNQUFNLEVBQUUsR0FBR1IsZUFBZW1CO0lBRWpELHVEQUF1RDtJQUN2RCxrQkFBa0I7SUFDbEIsSUFBSTBCLGFBQWFwQyxJQUFJcUMsT0FBTyxDQUFDLE9BQU87SUFFcEMsSUFBSUYsV0FBVztRQUNiQyxhQUFhLEtBQUdELFlBQVlDO0lBQzlCO0lBQ0EsSUFBSUUsYUFBYTtJQUVqQixrRUFBa0U7SUFDbEUsV0FBVztJQUNYLElBQUlGLFdBQVdHLE1BQU0sS0FBSyxLQUFLSCxXQUFXRyxNQUFNLEdBQUcsSUFBSTtRQUNyREQsYUFBYTtJQUNmO0lBQ0EsSUFBSSxDQUFDRSxNQUFNQyxTQUFTTCxXQUFXdEMsS0FBSyxDQUFDLEdBQUcsTUFBTTtRQUM1Q3dDLGFBQWE7SUFDZjtJQUVBLElBQUlBLFlBQVk7UUFDZEYsYUFBYUg7SUFDZjtJQUVBLElBQUlFLFdBQVc7UUFDYkQsU0FBUyxDQUFDRSxXQUFXLEdBQUcsS0FBR0QsWUFBWW5DO0lBQ3pDLE9BQU87UUFDTGtDLFNBQVMsQ0FBQ0UsV0FBVyxHQUFHcEM7SUFDMUI7SUFFQSx3RkFBd0Y7SUFDeEYsMEZBQTBGO0lBQzFGLHFGQUFxRjtJQUNyRixNQUFNMEMscUJBQXFCVixxQkFDdkJkLENBQUFBLEdBQUFBLGNBQUFBLGtCQUFrQixFQUFDYyxzQkFDbkI7SUFFSixPQUFPakMsU0FDSEosV0FDRSxTQUFPK0MscUJBQW1CLFFBQUtOLGFBQVcsWUFDMUMsTUFBSU0scUJBQW1CLFFBQUtOLGFBQVcsVUFDekMsTUFBSU0scUJBQW1CLFFBQUtOLGFBQVc7QUFDN0M7QUFFQSxTQUFTTywwQkFBMEJ6QyxLQUFhLEVBQUUwQyxlQUF3QjtJQUN4RSxNQUFNekMsV0FBV0MsQ0FBQUEsR0FBQUEscUJBQUFBLG1CQUFtQixFQUFDRixPQUFPSixLQUFLLENBQUMsR0FBR08sS0FBSyxDQUFDO0lBQzNELE1BQU00QixrQkFBa0JWO0lBQ3hCLE1BQU1XLFlBQXlDLENBQUM7SUFDaEQsT0FBTztRQUNMVyx5QkFBeUIxQyxTQUN0Qk0sR0FBRyxDQUFDLENBQUNDO1lBQ0osTUFBTW9DLHdCQUF3QmxDLG9CQUFBQSwwQkFBMEIsQ0FBQ21DLElBQUksQ0FBQyxDQUFDakMsSUFDN0RKLFFBQVFkLFVBQVUsQ0FBQ2tCO1lBRXJCLE1BQU1DLGVBQWVMLFFBQVFNLEtBQUssQ0FBQyx1QkFBdUIsdUJBQXVCOztZQUVqRixJQUFJOEIseUJBQXlCL0IsY0FBYztnQkFDekMsTUFBTSxDQUFDaUMsV0FBVyxHQUFHdEMsUUFBUUwsS0FBSyxDQUFDVSxZQUFZLENBQUMsRUFBRTtnQkFFbEQsT0FBT2dCLHNCQUFzQjtvQkFDM0JFO29CQUNBRCxvQkFBb0JnQjtvQkFDcEJ0QyxTQUFTSyxZQUFZLENBQUMsRUFBRTtvQkFDeEJtQjtvQkFDQUMsV0FBV1Msa0JBQ1BuRCxrQ0FDQXdEO2dCQUNOO1lBQ0YsT0FBTyxJQUFJbEMsY0FBYztnQkFDdkIsT0FBT2dCLHNCQUFzQjtvQkFDM0JFO29CQUNBdkIsU0FBU0ssWUFBWSxDQUFDLEVBQUU7b0JBQ3hCbUI7b0JBQ0FDLFdBQVdTLGtCQUFrQnBELDBCQUEwQnlEO2dCQUN6RDtZQUNGLE9BQU87Z0JBQ0wsT0FBTyxNQUFJL0IsQ0FBQUEsR0FBQUEsY0FBQUEsa0JBQWtCLEVBQUNSO1lBQ2hDO1FBQ0YsR0FDQ1MsSUFBSSxDQUFDO1FBQ1JlO0lBQ0Y7QUFDRjtBQVVPLFNBQVM3QyxtQkFDZCtCLGVBQXVCLEVBQ3ZCOEIsY0FBdUI7SUFFdkIsTUFBTUMsU0FBU1IsMEJBQTBCdkIsaUJBQWlCOEI7SUFDMUQsT0FBTztRQUNMLEdBQUc1RCxjQUFjOEIsZ0JBQWdCO1FBQ2pDZ0MsWUFBWSxNQUFJRCxPQUFPTix1QkFBdUIsR0FBQztRQUMvQ1gsV0FBV2lCLE9BQU9qQixTQUFTO0lBQzdCO0FBQ0Y7QUFNTyxTQUFTOUMsd0JBQ2RnQyxlQUF1QixFQUN2QmlDLE9BRUM7SUFFRCxNQUFNLEVBQUU3QyxrQkFBa0IsRUFBRSxHQUFHUCxxQkFBcUJtQjtJQUNwRCxNQUFNLEVBQUVrQyxXQUFXLElBQUksRUFBRSxHQUFHRDtJQUM1QixJQUFJN0MsdUJBQXVCLEtBQUs7UUFDOUIsSUFBSStDLGdCQUFnQkQsV0FBVyxPQUFPO1FBQ3RDLE9BQU87WUFDTEYsWUFBWSxPQUFLRyxnQkFBYztRQUNqQztJQUNGO0lBRUEsTUFBTSxFQUFFVix1QkFBdUIsRUFBRSxHQUFHRiwwQkFDbEN2QixpQkFDQTtJQUVGLElBQUlvQyx1QkFBdUJGLFdBQVcsZUFBZTtJQUNyRCxPQUFPO1FBQ0xGLFlBQVksTUFBSVAsMEJBQTBCVyx1QkFBcUI7SUFDakU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LnRzPzE2YTEiXSwibmFtZXMiOlsiZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXgiLCJnZXROYW1lZFJvdXRlUmVnZXgiLCJnZXRSb3V0ZVJlZ2V4IiwicGFyc2VQYXJhbWV0ZXIiLCJORVhUX1FVRVJZX1BBUkFNX1BSRUZJWCIsIk5FWFRfSU5URVJDRVBUSU9OX01BUktFUl9QUkVGSVgiLCJwYXJhbSIsIm9wdGlvbmFsIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJyZXBlYXQiLCJrZXkiLCJnZXRQYXJhbWV0cml6ZWRSb3V0ZSIsInJvdXRlIiwic2VnbWVudHMiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwic3BsaXQiLCJncm91cHMiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwibWFwIiwic2VnbWVudCIsIm1hcmtlck1hdGNoIiwiSU5URVJDRVBUSU9OX1JPVVRFX01BUktFUlMiLCJmaW5kIiwibSIsInBhcmFtTWF0Y2hlcyIsIm1hdGNoIiwicG9zIiwiZXNjYXBlU3RyaW5nUmVnZXhwIiwiam9pbiIsIm5vcm1hbGl6ZWRSb3V0ZSIsInJlIiwiUmVnRXhwIiwiYnVpbGRHZXRTYWZlUm91dGVLZXkiLCJpIiwicm91dGVLZXkiLCJqIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiTWF0aCIsImZsb29yIiwiZ2V0U2FmZUtleUZyb21TZWdtZW50IiwiaW50ZXJjZXB0aW9uTWFya2VyIiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXlzIiwia2V5UHJlZml4IiwiY2xlYW5lZEtleSIsInJlcGxhY2UiLCJpbnZhbGlkS2V5IiwibGVuZ3RoIiwiaXNOYU4iLCJwYXJzZUludCIsImludGVyY2VwdGlvblByZWZpeCIsImdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUiLCJwcmVmaXhSb3V0ZUtleXMiLCJuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSIsImhhc0ludGVyY2VwdGlvbk1hcmtlciIsInNvbWUiLCJ1c2VkTWFya2VyIiwidW5kZWZpbmVkIiwicHJlZml4Um91dGVLZXkiLCJyZXN1bHQiLCJuYW1lZFJlZ2V4Iiwib3B0aW9ucyIsImNhdGNoQWxsIiwiY2F0Y2hBbGxSZWdleCIsImNhdGNoQWxsR3JvdXBlZFJlZ2V4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return getSortedRoutes;\n    }\n}));\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh(prefix) {\n        if (prefix === void 0) prefix = \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\" + prefix + c + \"/\")).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(prefix + \"[\" + this.slugName + \"]/\"));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"' + r + '\" and \"' + r + \"[[...\" + this.optionalRestSlugName + ']]\").');\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(prefix + \"[...\" + this.restSlugName + \"]/\"));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(prefix + \"[[...\" + this.optionalRestSlugName + \"]]/\"));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\" + segmentName + \"').\");\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\" + segmentName + \"').\");\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\" + previousSlug + \"' !== '\" + nextSlug + \"').\");\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"' + nextSlug + '\" repeat within a single dynamic path');\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"' + slug + '\" and \"' + nextSlug + '\" differ only by non-word symbols within a single dynamic path');\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...' + this.restSlugName + ']\" and \"' + urlPaths[0] + '\" ).');\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...' + this.optionalRestSlugName + ']]\" and \"' + urlPaths[0] + '\").');\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"' + urlPaths[0] + '\").');\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvc29ydGVkLXJvdXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O21EQXFNZ0JBOzs7ZUFBQUE7OztBQXJNaEIsTUFBTUM7SUFPSkMsT0FBT0MsT0FBZSxFQUFRO1FBQzVCLElBQUksQ0FBQ0MsT0FBTyxDQUFDRCxRQUFRRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQyxVQUFVLEVBQUUsRUFBRTtJQUN2RDtJQUVBQyxTQUFtQjtRQUNqQixPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUNyQjtJQUVRQSxRQUFRQyxNQUFvQixFQUFZO1FBQWhDQSxJQUFBQSxXQUFBQSxLQUFBQSxHQUFBQSxTQUFpQjtRQUMvQixNQUFNQyxnQkFBZ0I7ZUFBSSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSTtTQUFHLENBQUNDLElBQUk7UUFDcEQsSUFBSSxJQUFJLENBQUNDLFFBQVEsS0FBSyxNQUFNO1lBQzFCSixjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxPQUFPO1FBQ3BEO1FBQ0EsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxNQUFNO1lBQzlCUCxjQUFjSyxNQUFNLENBQUNMLGNBQWNNLE9BQU8sQ0FBQyxVQUFVO1FBQ3ZEO1FBQ0EsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixLQUFLLE1BQU07WUFDdENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDekQ7UUFFQSxNQUFNRyxTQUFTVCxjQUNaVSxHQUFHLENBQUMsQ0FBQ0MsSUFBTSxJQUFJLENBQUNWLFFBQVEsQ0FBQ1csR0FBRyxDQUFDRCxHQUFJYixPQUFPLENBQUMsS0FBR0MsU0FBU1ksSUFBRSxNQUN2REUsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQVM7bUJBQUlEO21CQUFTQzthQUFLLEVBQUUsRUFBRTtRQUVoRCxJQUFJLElBQUksQ0FBQ1gsUUFBUSxLQUFL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Q0FBQ3pCLFFBQVEsQ0FBQ3NDLEdBQUcsQ0FBQ2IsYUFBYSxJQUFJcEM7UUFDckM7UUFFQSxJQUFJLENBQUNXLFFBQVEsQ0FDVlcsR0FBRyxDQUFDYyxhQUNKakMsT0FBTyxDQUFDNkIsU0FBU0gsS0FBSyxDQUFDLElBQUlJLFdBQVdDO0lBQzNDOzthQWpNQVAsV0FBQUEsR0FBdUI7YUFDdkJoQixRQUFBQSxHQUFpQyxJQUFJdUM7YUFDckNwQyxRQUFBQSxHQUEwQjthQUMxQkcsWUFBQUEsR0FBOEI7YUFDOUJDLG9CQUFBQSxHQUFzQzs7QUE4THhDO0FBRU8sU0FBU25CLGdCQUNkb0QsZUFBc0M7SUFFdEMsa0ZBQWtGO0lBQ2xGLDRFQUE0RTtJQUM1RSwyQ0FBMkM7SUFFM0MseUVBQXlFO0lBQ3pFLDJCQUEyQjtJQUMzQixvQ0FBb0M7SUFDcEMsOEVBQThFO0lBQzlFLHdFQUF3RTtJQUN4RSxnSEFBZ0g7SUFDaEgsNEVBQTRFO0lBQzVFLE1BQU1DLE9BQU8sSUFBSXBEO0lBRWpCLDZGQUE2RjtJQUM3Rm1ELGdCQUFnQk4sT0FBTyxDQUFDLENBQUNRLFdBQWFELEtBQUtuRCxNQUFNLENBQUNvRDtJQUNsRCw0R0FBNEc7SUFDNUcsT0FBT0QsS0FBSzdDLE1BQU07QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL3NyYy9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLnRzP2Q1M2IiXSwibmFtZXMiOlsiZ2V0U29ydGVkUm91dGVzIiwiVXJsTm9kZSIsImluc2VydCIsInVybFBhdGgiLCJfaW5zZXJ0Iiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwic21vb3NoIiwiX3Ntb29zaCIsInByZWZpeCIsImNoaWxkcmVuUGF0aHMiLCJjaGlsZHJlbiIsImtleXMiLCJzb3J0Iiwic2x1Z05hbWUiLCJzcGxpY2UiLCJpbmRleE9mIiwicmVzdFNsdWdOYW1lIiwib3B0aW9uYWxSZXN0U2x1Z05hbWUiLCJyb3V0ZXMiLCJtYXAiLCJjIiwiZ2V0IiwicmVkdWNlIiwicHJldiIsImN1cnIiLCJwdXNoIiwicGxhY2Vob2xkZXIiLCJyIiwic2xpY2UiLCJFcnJvciIsInVuc2hpZnQiLCJ1cmxQYXRocyIsInNsdWdOYW1lcyIsImlzQ2F0Y2hBbGwiLCJsZW5ndGgiLCJuZXh0U2VnbWVudCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNlZ21lbnROYW1lIiwiaXNPcHRpb25hbCIsInN1YnN0cmluZyIsImhhbmRsZVNsdWciLCJwcmV2aW91c1NsdWciLCJuZXh0U2x1ZyIsImZvckVhY2giLCJzbHVnIiwicmVwbGFjZSIsImhhcyIsInNldCIsIk1hcCIsIm5vcm1hbGl6ZWRQYWdlcyIsInJvb3QiLCJwYWdlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = typeof window === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7MkNBb0JBOzs7ZUFBd0JBOzs7bUNBbkI2QjtBQWVyRCxNQUFNQyxXQUFXLE9BQU9DLFdBQVc7QUFDbkMsTUFBTUMsNEJBQTRCRixXQUFXLEtBQU8sSUFBSUcsT0FBQUEsZUFBZTtBQUN2RSxNQUFNQyxzQkFBc0JKLFdBQVcsS0FBTyxJQUFJSyxPQUFBQSxTQUFTO0FBRTVDLFNBQVNOLFdBQVdPLEtBQXNCOztJQUN2RCxNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFFakQsU0FBU0c7UUFDUCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUMvQyxNQUFNQyxlQUFlQyxPQUFBQSxRQUFRLENBQUNDLE9BQU8sQ0FDbkNDLE1BQU1DLElBQUksQ0FBQ1IsWUFBWUcsZ0JBQWdCLEVBQTBCTSxNQUFNLENBQ3JFQztZQUdKVixZQUFZVyxVQUFVLENBQUNWLHdCQUF3QkcsY0FBY0w7UUFDL0Q7SUFDRjtJQUVBLElBQUlOLFVBQVU7WUFDWk87UUFBQUEsZUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsZ0NBQUFBLFlBQWFHLGdCQUFnQixxQkFBN0JILDhCQUErQlksR0FBRyxDQUFDYixNQUFNYyxRQUFRO1FBQ2pEWDtJQUNGO0lBRUFQLDBCQUEwQjtZQUN4Qks7UUFBQUEsZUFBQUEsT0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsZ0NBQUFBLFlBQWFHLGdCQUFnQixxQkFBN0JILDhCQUErQlksR0FBRyxDQUFDYixNQUFNYyxRQUFRO1FBQ2pELE9BQU87Z0JBQ0xiO1lBQUFBLGVBQUFBLE9BQUFBLEtBQUFBLElBQUFBLENBQUFBLGdDQUFBQSxZQUFhRyxnQkFBZ0IscUJBQTdCSCw4QkFBK0JjLE1BQU0sQ0FBQ2YsTUFBTWMsUUFBUTtRQUN0RDtJQUNGO0lBRUEsa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRmxCLDBCQUEwQjtRQUN4QixJQUFJSyxhQUFhO1lBQ2ZBLFlBQVllLGNBQWMsR0FBR2I7UUFDL0I7UUFDQSxPQUFPO1lBQ0wsSUFBSUYsYUFBYTtnQkFDZkEsWUFBWWUsY0FBYyxHQUFHYjtZQUMvQjtRQUNGO0lBQ0Y7SUFFQUwsb0JBQW9CO1FBQ2xCLElBQUlHLGVBQWVBLFlBQVllLGNBQWMsRUFBRTtZQUM3Q2YsWUFBWWUsY0FBYztZQUMxQmYsWUFBWWUsY0FBYyxHQUFHO1FBQy9CO1FBQ0EsT0FBTztZQUNMLElBQUlmLGVBQWVBLFlBQVllLGNBQWMsRUFBRTtnQkFDN0NmLFlBQVllLGNBQWM7Z0JBQzFCZixZQUFZZSxjQUFjLEdBQUc7WUFDL0I7UUFDRjtJQUNGO0lBRUEsT0FBTztBQUNUO0dBeER3QnZCOztRQW1CdEJHO1FBWUFBO1FBV0FFOzs7S0ExQ3NCTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL3NoYXJlZC9saWIvc2lkZS1lZmZlY3QudHN4P2U4ZGQiXSwibmFtZXMiOlsiU2lkZUVmZmVjdCIsImlzU2VydmVyIiwid2luZG93IiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VFZmZlY3QiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiYWRkIiwiY2hpbGRyZW4iLCJkZWxldGUiLCJfcGVuZGluZ1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\" + urlParts.slice(1).join(\"?\") : \"\");\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== \"undefined\";\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.name = \"PageNotFoundError\";\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFvYWFBLGFBQVc7ZUFBWEE7O0lBb0JBQyx5QkFBdUI7ZUFBdkJBOztJQVBBQyxtQkFBaUI7ZUFBakJBOztJQVpBQyxnQkFBYztlQUFkQTs7SUFDQUMsbUJBQWlCO2VBQWpCQTs7SUFUQUMsSUFBRTtlQUFGQTs7SUFDQUMsSUFBRTtlQUFGQTs7SUFsWEFDLFlBQVU7ZUFBVkE7O0lBc1FHQyxVQUFRO2VBQVJBOztJQStCQUMsZ0JBQWM7ZUFBZEE7O0lBWEFDLG1CQUFpQjtlQUFqQkE7O0lBS0FDLFFBQU07ZUFBTkE7O0lBUEhDLGVBQWE7ZUFBYkE7O0lBbUJHQyxXQUFTO2VBQVRBOztJQWtCTUMscUJBQW1CO2VBQW5CQTs7SUFkTkMsMEJBQXdCO2VBQXhCQTs7SUErR0FDLGdCQUFjO2VBQWRBOzs7QUE5WlQsTUFBTVQsYUFBYTtJQUFDO0lBQU87SUFBTztJQUFPO0lBQU87SUFBTztDQUFPO0FBc1E5RCxTQUFTQyxTQUNkUyxFQUFLO0lBRUwsSUFBSUMsT0FBTztJQUNYLElBQUlDO0lBRUosT0FBUTt5Q0FBSUMsT0FBQUEsSUFBQUEsTUFBQUEsT0FBQUEsT0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsT0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsS0FBQUE7O1FBQ1YsSUFBSSxDQUFDRixNQUFNO1lBQ1RBLE9BQU87WUFDUEMsU0FBU0YsTUFBTUc7UUFDakI7UUFDQSxPQUFPRDtJQUNUO0FBQ0Y7QUFFQSwwREFBMEQ7QUFDMUQsZ0VBQWdFO0FBQ2hFLE1BQU1FLHFCQUFxQjtBQUNwQixNQUFNVCxnQkFBZ0IsQ0FBQ1UsTUFBZ0JELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUUvRCxTQUFTWjtJQUNkLE1BQU0sRUFBRWMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLElBQUksRUFB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O0lBQ3JDVSxZQUFZQyxJQUFZLEVBQUVaLE9BQWUsQ0FBRTtRQUN6QyxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUcsMENBQXdDWSxPQUFLLE1BQUdaO0lBQ2pFO0FBQ0Y7QUFFTyxNQUFNakQsZ0NBQWdDa0Q7SUFFM0NVLGFBQWM7UUFDWixLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNiLE9BQU8sR0FBSTtJQUNsQjtBQUNGO0FBV08sU0FBU2xDLGVBQWVnRCxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFaEIsU0FBU2MsTUFBTWQsT0FBTztRQUFFaUIsT0FBT0gsTUFBTUcsS0FBSztJQUFDO0FBQ3JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvc2hhcmVkL2xpYi91dGlscy50cz8xYmQ1Il0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInBlcmZvcm1hbmNlIiwiZXZlcnkiLCJtZXRob2QiLCJjb25zdHJ1Y3RvciIsInBhZ2UiLCJjb2RlIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9mYjE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/YzI1NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fcomponents%2FMap.tsx%22%2C%22ids%22%3A%5B%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fmichaeldreesen%2FDocuments%2FProgramming%2Fbusiness-projects%2Fperrigo-insurance%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Flink.js%22%2C%22ids%22%3A%5B%22*%22%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);